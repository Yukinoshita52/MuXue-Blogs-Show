<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis AOF、RDB 持久化策略</title>
      <link href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
      <url>/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h1><h2 id="Redis-为什么需要持久化？"><a href="#Redis-为什么需要持久化？" class="headerlink" title="Redis 为什么需要持久化？"></a>Redis 为什么需要持久化？</h2><p>Redis 是基于内存的数据库，内存访问速度快，但<strong>内存数据在进程退出或机器宕机后必然丢失</strong>。因此，Redis 提供持久化机制，将内存中的数据以一定策略写入磁盘，用于服务重启后的数据恢复。</p><p>需要明确一个前提结论：</p><blockquote><p>Redis 持久化只能<strong>降低数据丢失风险</strong>，并不能保证强一致性或绝对不丢数据。<br>实际丢失多少数据，取决于持久化策略、刷盘频率以及宕机发生的时间点。</p></blockquote><p>Redis 提供两种核心持久化机制：</p><ul><li><strong>AOF（Append Only File）日志</strong></li><li><strong>RDB（Redis DataBase）快照</strong></li></ul><h2 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h2><h3 id="AOF-是什么"><a href="#AOF-是什么" class="headerlink" title="AOF 是什么"></a>AOF 是什么</h3><p>AOF（Append Only File）通过<strong>记录写命令</strong>的方式持久化数据。Redis 会将所有会修改数据的命令，按执行顺序追加写入日志文件。</p><p>AOF 默认是关闭的，可通过配置开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>AOF 只记录<strong>写操作命令</strong>，不记录读操作，因为读命令无法用于数据恢复。</p><h3 id="AOF-的写入流程"><a href="#AOF-的写入流程" class="headerlink" title="AOF 的写入流程"></a>AOF 的写入流程</h3><p>一次写命令的大致流程如下：</p><ol><li>Redis 执行写命令，修改内存数据</li><li>将写命令追加到 <strong>AOF buffer</strong></li><li>根据 <code>appendfsync</code> 策略，决定是否调用 <code>fsync()</code> 将数据刷入磁盘</li></ol><p>注意：<br>AOF 持久化写入的是<strong>命令本身，而不是数据结果</strong>。</p><h3 id="AOF-的刷盘策略"><a href="#AOF-的刷盘策略" class="headerlink" title="AOF 的刷盘策略"></a>AOF 的刷盘策略</h3><p>Redis 提供三种 AOF 刷盘策略：</p><ul><li><code>appendfsync always</code><ul><li>每条写命令都调用 <code>fsync()</code></li><li>数据安全性最高</li><li>性能最差</li></ul></li><li><code>appendfsync everysec</code>（默认）<ul><li>每秒刷盘一次</li><li>宕机时最多丢失 1 秒的数据</li><li>性能和安全性较为平衡</li></ul></li><li><code>appendfsync no</code><ul><li>不主动刷盘，由操作系统决定</li><li>宕机时可能丢失操作系统缓冲区中的<strong>全部数据</strong></li><li>数据丢失量不可控</li></ul></li></ul><h3 id="AOF-文件膨胀与重写机制"><a href="#AOF-文件膨胀与重写机制" class="headerlink" title="AOF 文件膨胀与重写机制"></a>AOF 文件膨胀与重写机制</h3><p>由于 AOF 会持续追加写命令，文件体积会不断增大。为此，Redis 提供 <strong>AOF 重写（rewrite）机制</strong>。</p><p>需要强调的是：</p><blockquote><p>AOF 重写并不是简单地“压缩旧 AOF 文件”，<br>而是<strong>根据当前内存中的数据状态，重新生成一份等价的最小命令集</strong>。</p></blockquote><h4 id="AOF-重写过程"><a href="#AOF-重写过程" class="headerlink" title="AOF 重写过程"></a>AOF 重写过程</h4><ol><li>Redis fork 出一个子进程</li><li>子进程根据当前内存数据生成新的 AOF 文件</li><li>重写期间，主进程的新写命令写入：<ul><li>原 AOF 文件</li><li>AOF 重写缓冲区</li></ul></li><li>重写完成后：<ul><li>将重写缓冲区中的命令追加到新 AOF 文件</li><li>原子性替换旧 AOF 文件</li></ul></li></ol><h4 id="fork-与写时复制（Copy-On-Write）"><a href="#fork-与写时复制（Copy-On-Write）" class="headerlink" title="fork 与写时复制（Copy-On-Write）"></a>fork 与写时复制（Copy-On-Write）</h4><ul><li>fork 时子进程共享父进程的内存页</li><li>主进程发生写操作时，通过写时复制保证子进程的数据一致性</li><li>重写过程不会阻塞正常的写请求</li></ul><h2 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h2><h3 id="RDB-是什么"><a href="#RDB-是什么" class="headerlink" title="RDB 是什么"></a>RDB 是什么</h3><p>RDB 通过<strong>生成某一时刻内存数据的完整快照</strong>来持久化数据，类似于给 Redis 的数据拍一张“照片”。</p><p>RDB 默认开启。</p><h3 id="RDB-的生成方式"><a href="#RDB-的生成方式" class="headerlink" title="RDB 的生成方式"></a>RDB 的生成方式</h3><p>Redis 提供两个命令生成 RDB 文件：</p><ul><li><code>save</code><ul><li>在主线程执行</li><li><strong>完全阻塞 Redis</strong></li></ul></li><li><code>bgsave</code><ul><li>fork 子进程生成快照</li><li>fork 时存在短暂阻塞</li><li>是生产环境常用方式</li></ul></li></ul><p>RDB 通常通过配置自动触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>含义为：</p><ul><li>900 秒内至少 1 次修改</li><li>300 秒内至少 10 次修改</li><li>60 秒内至少 10000 次修改</li></ul><p>满足任意条件，Redis 就会执行 <code>bgsave</code>。</p><h3 id="RDB-的特点与风险"><a href="#RDB-的特点与风险" class="headerlink" title="RDB 的特点与风险"></a>RDB 的特点与风险</h3><ul><li>RDB 是<strong>全量快照</strong></li><li>每次生成都会遍历并序列化所有数据</li><li>快照操作相对较重</li></ul><p>因此：</p><ul><li>执行频率高 → 性能开销大</li><li>执行间隔长 → 宕机时数据丢失多</li></ul><p>RDB 本质上是一个：<br><strong>重操作 + 恢复快 + 丢数据多</strong> 的方案。</p><h2 id="Redis-启动时的数据恢复流程"><a href="#Redis-启动时的数据恢复流程" class="headerlink" title="Redis 启动时的数据恢复流程"></a>Redis 启动时的数据恢复流程</h2><p>Redis 重启后，持久化文件的加载顺序为：</p><ol><li>如果开启了 AOF，且 AOF 文件存在<br>→ <strong>优先使用 AOF 文件恢复数据</strong></li><li>否则使用 RDB 文件恢复数据</li><li>若两者都不存在<br>→ 数据为空</li></ol><p>注意：<br>“同时开启 AOF 和 RDB”并不意味着“同时恢复”，<br>而是 <strong>AOF 在恢复阶段具有更高优先级</strong>。</p><h2 id="AOF-与-RDB-的对比"><a href="#AOF-与-RDB-的对比" class="headerlink" title="AOF 与 RDB 的对比"></a>AOF 与 RDB 的对比</h2><div class="table-container"><table><thead><tr><th>对比维度</th><th>AOF</th><th>RDB</th></tr></thead><tbody><tr><td>数据安全性</td><td>较高（可配置）</td><td>较低</td></tr><tr><td>数据丢失量</td><td>秒级或可控</td><td>取决于快照周期</td></tr><tr><td>持久化开销</td><td>较轻</td><td>较重</td></tr><tr><td>文件体积</td><td>较大</td><td>较小</td></tr><tr><td>恢复速度</td><td>较慢</td><td>较快</td></tr><tr><td>适用场景</td><td>对数据可靠性要求较高</td><td>缓存、允许丢数据</td></tr></tbody></table></div><h2 id="混合持久化（Hybrid-Persistence）"><a href="#混合持久化（Hybrid-Persistence）" class="headerlink" title="混合持久化（Hybrid Persistence）"></a>混合持久化（Hybrid Persistence）</h2><p>Redis 4.0 引入混合持久化机制，本质上是 <strong>AOF 重写的优化</strong>：</p><ul><li>AOF 重写时：<ul><li>文件前半部分是 <strong>RDB 格式的全量数据</strong></li><li>后半部分是 <strong>AOF 格式的增量命令</strong></li></ul></li><li>兼顾：<ul><li>RDB 恢复速度快</li><li>AOF 数据丢失少</li></ul></li></ul><p>混合持久化在 Redis 4.0+ 且开启 AOF 的情况下默认启用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis 持久化的目标是<strong>降低数据丢失风险，而不是保证零丢失</strong></li><li>AOF 更安全，但恢复慢、文件大</li><li>RDB 更轻量，恢复快，但可能丢失更多数据</li><li>实际生产环境通常：<ul><li>同时开启 AOF + RDB</li><li>使用 AOF（everysec）+ 混合持久化作为折中方案</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 过期删除策略+缓存淘汰策略</title>
      <link href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-过期删除策略"><a href="#Redis-过期删除策略" class="headerlink" title="Redis 过期删除策略"></a>Redis 过期删除策略</h1><p>在介绍 Redis 的过期删除机制之前，需要先说明：<br><strong>定时删除、惰性删除、定期删除</strong>是对过期数据清理思路的抽象划分，用于分析不同策略在 CPU 开销与内存占用之间的取舍。实际的高性能缓存系统通常不会采用其中某一种，而是进行组合设计。</p><h2 id="常见的过期删除策略"><a href="#常见的过期删除策略" class="headerlink" title="常见的过期删除策略"></a>常见的过期删除策略</h2><h3 id="1-定时删除"><a href="#1-定时删除" class="headerlink" title="1. 定时删除"></a>1. 定时删除</h3><p>定时删除指的是：<br><strong>当键到达过期时间的瞬间立即删除该键。</strong></p><p>其实现通常需要：</p><ul><li>为每一个设置了过期时间的 key 维护独立的定时事件（如定时器或最小堆）</li><li>到期后触发删除回调</li></ul><p>优点：</p><ul><li>过期键能够被及时清理</li><li>内存利用率高</li></ul><p>缺点：</p><ul><li>定时事件数量与过期 key 数量近似线性相关</li><li>当过期 key 较多时，定时回调会占用大量 CPU</li><li>严重影响主线程吞吐量</li></ul><p>因此，Redis 并未采用这种高精度但高成本的策略。</p><h3 id="2-惰性删除"><a href="#2-惰性删除" class="headerlink" title="2. 惰性删除"></a>2. 惰性删除</h3><p>惰性删除的核心思想是：<br><strong>不主动删除过期 key，仅在访问时检查其是否过期。</strong></p><p>执行流程：</p><ul><li>客户端访问 key</li><li>Redis 判断 key 是否已过期</li><li>若已过期，立即删除并返回 key 不存在</li></ul><p>优点：</p><ul><li>对 CPU 非常友好</li><li>不做无意义的主动扫描</li></ul><p>缺点：</p><ul><li>如果某些 key 长期不被访问，即使已经过期，也会一直占用内存</li><li>单独使用会造成内存浪费</li></ul><h3 id="3-定期删除（主动过期）"><a href="#3-定期删除（主动过期）" class="headerlink" title="3. 定期删除（主动过期）"></a>3. 定期删除（主动过期）</h3><p>定期删除是 Redis 的后台主动清理机制：</p><ul><li>Redis 后台周期性执行过期扫描</li><li><strong>随机抽样</strong>一部分设置了过期时间的 key</li><li>删除其中已经过期的 key</li><li>执行时间受 <code>hz</code> 配置与时间片限制</li></ul><p>需要注意：</p><ul><li>并非全量扫描</li><li>并非严格“到点即删”</li><li>本质是一种<strong>近似清理机制</strong></li></ul><h2 id="Redis-的过期删除策略总结"><a href="#Redis-的过期删除策略总结" class="headerlink" title="Redis 的过期删除策略总结"></a>Redis 的过期删除策略总结</h2><p>Redis 并未采用定时删除，而是通过以下组合方式清理过期 key：</p><blockquote><p><strong>惰性删除 + 定期删除（主动过期）</strong></p></blockquote><p>该组合策略在保证访问语义正确性的前提下：</p><ul><li>避免定时删除带来的高 CPU 开销</li><li>防止惰性删除导致的大量过期 key 长期占用内存</li></ul><blockquote><p>Redis 的过期删除机制<strong>几乎不可精调</strong>，只能通过 <code>hz</code> 和 <code>active-expire-effort</code> 间接控制后台主动过期的执行频率和强度；惰性删除行为本身不可配置。</p></blockquote><h1 id="Redis-缓存淘汰策略"><a href="#Redis-缓存淘汰策略" class="headerlink" title="Redis 缓存淘汰策略"></a>Redis 缓存淘汰策略</h1><p>缓存淘汰策略与过期删除策略的目标和触发条件不同，二者不能混淆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有实践省流如下：</span></span><br><span class="line">CONFIG GET maxmemory-policy          <span class="comment"># 1. 命令行查看当前缓存淘汰策略</span></span><br><span class="line">CONFIG SET maxmemory-policy &lt;policy&gt; <span class="comment"># 2. 修改运行时缓存淘汰策略</span></span><br><span class="line">maxmemory-policy &lt;policy&gt;            <span class="comment"># 3. 修改配置文件，使得缓存淘汰策略重启后仍生效</span></span><br><span class="line">CONFIG GET maxmemory-samples         <span class="comment"># 4. 查看当前 LRU / LFU 采样数量</span></span><br><span class="line">CONFIG SET maxmemory-samples &lt;N&gt;     <span class="comment"># 5. 修改运行时采样数量（立即生效，重启失效）</span></span><br><span class="line">maxmemory-samples &lt;N&gt;                <span class="comment"># 6. 修改配置文件，使采样数量重启后仍生效</span></span><br></pre></td></tr></table></figure><h2 id="与过期删除策略的区别"><a href="#与过期删除策略的区别" class="headerlink" title="与过期删除策略的区别"></a>与过期删除策略的区别</h2><h3 id="1-作用范围不同"><a href="#1-作用范围不同" class="headerlink" title="1. 作用范围不同"></a>1. 作用范围不同</h3><ul><li>过期删除策略：<br>仅作用于<strong>设置了过期时间且已经过期的 key</strong></li><li>缓存淘汰策略：<br>作用于<strong>尚未过期但需要被移除的 key</strong><br>可仅限于设置了过期时间的 key，或作用于所有 key</li></ul><blockquote><p>已经过期的 key 不会进入缓存淘汰流程，而是直接被删除。</p></blockquote><h3 id="2-触发时机不同"><a href="#2-触发时机不同" class="headerlink" title="2. 触发时机不同"></a>2. 触发时机不同</h3><ul><li>过期删除策略：<ul><li>访问 key 时触发（惰性删除）</li><li>后台周期性触发（定期删除）</li></ul></li><li>缓存淘汰策略：<ul><li><strong>仅在配置了 <code>maxmemory</code></strong></li><li><strong>且内存使用达到上限时触发</strong></li></ul></li></ul><h2 id="Redis-支持的内存淘汰策略"><a href="#Redis-支持的内存淘汰策略" class="headerlink" title="Redis 支持的内存淘汰策略"></a>Redis 支持的内存淘汰策略</h2><blockquote><p>在 64 位系统上，Redis 默认不限制内存（<code>maxmemory=0</code>），因此不会触发内存淘汰机制。<br> 只有在显式设置 <code>maxmemory</code> 后，Redis 才可能在内存达到上限时，根据配置的淘汰策略执行缓存淘汰。</p></blockquote><p>Redis 提供以下内存淘汰策略：</p><ul><li><code>noeviction</code>（默认）<br>不进行内存淘汰，写命令在内存不足时直接返回错误，读操作不受影响</li><li><code>volatile-random</code><br>从设置了过期时间的 key 中随机淘汰</li><li><code>volatile-ttl</code><br>优先淘汰<strong>剩余 TTL 较小</strong>的 key（近似实现）</li><li><code>volatile-lru</code><br>从设置了过期时间的 key 中，淘汰最久未使用的 key（近似 LRU）</li><li><code>volatile-lfu</code><br>从设置了过期时间的 key 中，淘汰使用频率最低的 key（近似 LFU）</li><li><code>allkeys-random</code><br>从所有 key 中随机淘汰</li><li><code>allkeys-lru</code><br>从所有 key 中淘汰最久未使用的 key（近似 LRU）</li><li><code>allkeys-lfu</code><br>从所有 key 中淘汰使用频率最低的 key（近似 LFU）</li></ul><h2 id="查看与修改内存淘汰策略"><a href="#查看与修改内存淘汰策略" class="headerlink" title="查看与修改内存淘汰策略"></a>查看与修改内存淘汰策略</h2><p>查看当前淘汰策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET maxmemory-policy</span><br></pre></td></tr></table></figure><p>修改方式：</p><ol><li>运行时修改（立即生效，重启失效）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory-policy &lt;policy&gt;</span><br></pre></td></tr></table></figure><ol><li>修改配置文件（重启后生效）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy &lt;policy&gt;</span><br></pre></td></tr></table></figure><p>运行时配置用于即时调整行为，配置文件用于持久化配置，二者配合可保证实例行为一致。</p><h2 id="Redis-中-LRU-的实现机制"><a href="#Redis-中-LRU-的实现机制" class="headerlink" title="Redis 中 LRU 的实现机制"></a>Redis 中 LRU 的实现机制</h2><p>传统 LRU 通常通过双向链表实现，能够精确淘汰最久未使用的元素，但需要额外维护链表结构，成本较高。</p><p>Redis 并未维护全局 LRU 链表，而是采用<strong>近似 LRU 算法</strong>：</p><ul><li>每个 key 记录最近一次访问时间</li><li>内存淘汰时，随机抽取 N 个 key</li><li>从样本中淘汰访问时间最早的 key</li></ul><p>采样数量由参数 <code>maxmemory-samples</code> 控制：</p><ul><li>样本数越大，淘汰结果越接近真实 LRU</li><li>默认值为 5，可按需调整</li></ul><h2 id="Redis-中-LFU-的实现机制"><a href="#Redis-中-LFU-的实现机制" class="headerlink" title="Redis 中 LFU 的实现机制"></a>Redis 中 LFU 的实现机制</h2><p>LFU 用于淘汰使用频率最低的 key。</p><p>Redis 的 LFU 实现同样是近似算法：</p><ul><li>每个 key 维护访问频率计数</li><li>计数并非简单递增，而是概率性增长</li><li>同时引入时间衰减机制，避免历史热点永久占优</li><li>内存淘汰时，采用“随机抽样 + 比较频率”的方式选择淘汰目标</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Redis 通过<strong>惰性删除 + 定期删除</strong>清理过期 key（过期删除策略）</li><li>缓存淘汰仅在配置 <code>maxmemory</code> 且内存达到上限时触发、有八种（缓存淘汰策略）</li><li>过期删除针对过期键、缓存淘汰针对未过期键但设置了过期时间的键+未设置过期时间的键<ul><li>tips：如果缓存淘汰时采样到的数据中有已经过期的键呢？那么算是缓存淘汰吗？</li><li>不是！会直接删除，不属于缓存淘汰的范围中。</li></ul></li><li>LRU / LFU 在 Redis 中均为近似实现，可通过采样参数进行调优</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 使用实践</title>
      <link href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-使用实践"><a href="#Redis-使用实践" class="headerlink" title="Redis 使用实践"></a>Redis 使用实践</h1><p>Redis 有以下经典实用场景：</p><ul><li><strong>缓存系统</strong>：加速热点数据访问（如电商商品详情页）</li><li><p><strong>分布式锁</strong>：利用 SET NX 命令实现分布式同步</p></li><li><p><strong>实时统计</strong>：计数器、UV 统计、在线用户数</p></li><li><p><strong>消息队列</strong>：基于 List 的阻塞队列（BLPOP/BLPUSH）</p></li><li><p><strong>实时分析</strong>：结合 Bitmap 和 HyperLogLog 做用户行为分析</p></li></ul><p>还有其他 Redis 相关实践，例如 Lua 脚本的使用、选择部署模式（单示例、主从、Cluster）不在此列。</p><h2 id="Redis-作为缓存系统实践案例"><a href="#Redis-作为缓存系统实践案例" class="headerlink" title="Redis 作为缓存系统实践案例"></a>Redis 作为缓存系统实践案例</h2><p><a href="https://github.com/Yukinoshita52/CoTrip-backend">CoTrip</a>项目中对热点数据进行了缓存，对用户的行程信息做了缓存，大幅提高进入“我的行程”页面时的响应速度。</p><p>还对 baiduAPI 的调用结果做了缓存……原因有两个，调用第三方 API 比较耗时，还有就是超额度了要收费，所以这里加上的缓存是不过期的，长期保存在 Redis 中的，毕竟是个学校作业的项目，也不想因为每次刷新一下就调 API 然后超额度。这主要出于成本考虑的。</p><blockquote><p>由于服务器配置不高（2核2G磁盘40G），运行个MySQL+Redis+Minio已经极限了，完全没法再运行个jar包甚至加上前端了……除非再买一条服务器（正好阿里云一台、腾讯云一台…也行（？））</p></blockquote><h2 id="Redis-作为分布式锁实践案例"><a href="#Redis-作为分布式锁实践案例" class="headerlink" title="Redis 作为分布式锁实践案例"></a>Redis 作为分布式锁实践案例</h2><p>在某线上学习项目中（业务代码不便开源），存在多个服务实例同时操作同一份共享资源的场景，例如：<br>一件商品被多个用户同时下单购买、库存量的变化。</p><p>为避免并发条件下的数据不一致问题，引入了 <strong>Redis 分布式锁</strong> 进行控制。</p><h3 id="为什么选择-Redis-Redisson"><a href="#为什么选择-Redis-Redisson" class="headerlink" title="为什么选择 Redis + Redisson"></a>为什么选择 Redis + Redisson</h3><p>相比手动使用 <code>SETNX</code> 实现分布式锁，Redisson 提供了更完整的封装：</p><ul><li>自动处理锁的原子性</li><li>支持可重入锁</li><li>内置 WatchDog 机制，避免锁误释放</li><li>接口语义接近本地 <code>ReentrantLock</code>，降低使用成本</li></ul><h3 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h3><p>以下为简化后的示例代码，用于说明核心使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问或修改共享资源的业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键实现说明"><a href="#关键实现说明" class="headerlink" title="关键实现说明"></a>关键实现说明</h3><ul><li><code>lock.lock()</code><ul><li>默认是阻塞获取锁</li><li>使用 Redisson 的 WatchDog 机制自动续期</li><li>只要线程存活且未释放锁，锁不会因过期被误删</li></ul></li><li><code>finally</code> 中释放锁<ul><li>保证业务异常情况下锁能够被正确释放</li><li>避免死锁风险</li></ul></li><li><code>lockKey</code> 的设计<ul><li>锁粒度应尽量细</li><li>通常由业务唯一标识（如用户 ID、资源 ID）组成</li></ul></li></ul><p>该方式在项目中有效避免了并发写入导致的数据覆盖问题，同时保持了较低的实现复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 线程模型</title>
      <link href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h1><p>Redis 常被描述为“单线程高性能”的代表，但<strong>单线程并不等于简单或低效</strong>。准确理解 Redis 的线程模型，需要区分：<strong>命令执行、网络 I/O、后台任务</strong>这三条路径。</p><h2 id="Redis-的单线程指的是什么"><a href="#Redis-的单线程指的是什么" class="headerlink" title="Redis 的单线程指的是什么"></a>Redis 的单线程指的是什么</h2><p>是指—— Redis 的<strong>命令执行路径（command execution）是单线程的</strong>。</p><p>具体来说：</p><ul><li>所有客户端命令，统一在 <strong>主线程</strong> 中，按顺序完成：读取 → 解析 → 执行 → 返回结果  </li></ul><p>这意味着：</p><ul><li>不需要加锁、命令天然具备原子性、数据结构实现可以极度简化</li></ul><blockquote><p>但是，<strong>Redis 并不是整个进程只有一个线程</strong></p></blockquote><h2 id="基于内存的设计"><a href="#基于内存的设计" class="headerlink" title="基于内存的设计"></a>基于内存的设计</h2><p>Redis 将所有核心数据结构存放在内存中，而不是磁盘。</p><p>这带来的不仅是“快”这么简单：</p><ul><li>避免磁盘 I/O 阻塞</li><li>单次命令执行时间高度可控</li><li>延迟分布稳定，适合单线程顺序执行模型</li></ul><p>相比之下，频繁访问磁盘的系统（如传统关系型数据库）更容易出现阻塞点，不适合纯单线程执行所有逻辑。</p><h3 id="关于数据不丢失的问题"><a href="#关于数据不丢失的问题" class="headerlink" title="关于数据不丢失的问题"></a>关于数据不丢失的问题</h3><p>Redis 支持多种<strong>持久化策略</strong>（RDB、AOF），用于在内存数据与磁盘之间建立快照或日志。但持久化并不等于“绝对不丢数据”，只是降低风险。持久化机制本身不属于线程模型讨论范围。</p><h2 id="高效的数据结构设计"><a href="#高效的数据结构设计" class="headerlink" title="高效的数据结构设计"></a>高效的数据结构设计</h2><p>Redis 并非简单地“用内存换速度”，而是在数据结构层面进行了大量优化：</p><ul><li>SDS（简单动态字符串）</li><li>dict（渐进式 rehash）</li><li>skiplist</li><li>quicklist</li><li>listpack</li></ul><p>这些结构的共同特征是：</p><ul><li>操作时间复杂度低</li><li>单次操作耗时稳定</li><li>避免长时间阻塞主线程</li></ul><p>这是 Redis 能够坚持单线程执行命令的<strong>重要前提</strong>：<br><strong>任何一条命令都不应该执行过久</strong>。</p><h2 id="I-O-多路复用与-Reactor-模型"><a href="#I-O-多路复用与-Reactor-模型" class="headerlink" title="I/O 多路复用与 Reactor 模型"></a>I/O 多路复用与 Reactor 模型</h2><h3 id="I-O-多路复用解决的问题"><a href="#I-O-多路复用解决的问题" class="headerlink" title="I/O 多路复用解决的问题"></a>I/O 多路复用解决的问题</h3><p>Redis 需要同时处理大量客户端连接，如果为每个连接分配一个线程，线程切换成本会迅速失控。</p><p>解决方案是 <strong>I/O 多路复用</strong>：</p><ul><li>Linux：epoll</li><li>BSD / macOS：kqueue</li><li>其他平台：select / poll</li></ul><p>Redis 主线程通过 I/O 多路复用机制：</p><ul><li>监听多个 socket</li><li>感知“哪个连接可读 / 可写”</li><li>在同一个线程中依次处理事件</li></ul><blockquote><p>还有持久化任务（AOF 重写、RDB 持久化）、异步删除也是通过多线程来做的。</p></blockquote><h3 id="Redis-的-Reactor-模型"><a href="#Redis-的-Reactor-模型" class="headerlink" title="Redis 的 Reactor 模型"></a>Redis 的 Reactor 模型</h3><p>Redis 基于 I/O 多路复用实现了一种 <strong>Reactor 模型</strong>：</p><ul><li>主线程作为事件循环</li><li>等待 socket 事件发生</li><li>事件触发后：<ul><li>读取请求</li><li>解析命令</li><li>执行命令</li><li>写回响应</li></ul></li></ul><p>整个过程<strong>不涉及线程切换</strong>，避免了上下文切换和锁竞争的开销。</p><h2 id="Redis-6-0-之后的-I-O-线程"><a href="#Redis-6-0-之后的-I-O-线程" class="headerlink" title="Redis 6.0 之后的 I/O 线程"></a>Redis 6.0 之后的 I/O 线程</h2><p>从 Redis 6.0 开始，引入了 <strong>I/O 线程</strong>，但这并不改变核心模型。</p><p>关键点如下：</p><ul><li><strong>I/O 线程只负责网络读写</strong></li><li>命令解析与执行仍在主线程</li><li>不存在多线程同时修改数据结构</li></ul><p>引入 I/O 线程的原因是：</p><ul><li>在高并发场景下</li><li>网络读写成为瓶颈</li><li>CPU 资源被浪费在 socket I/O 上</li></ul><p>因此，Redis 通过 I/O 线程并行处理网络数据，而<strong>刻意不并行执行命令</strong>。</p><h2 id="为什么-Redis-不用多线程执行命令"><a href="#为什么-Redis-不用多线程执行命令" class="headerlink" title="为什么 Redis 不用多线程执行命令"></a>为什么 Redis 不用多线程执行命令</h2><p>Redis 不采用多线程并行执行命令，主要基于以下几点考虑：</p><ul><li>多线程会引入上下文切换、线程调度等额外开销，在高频、短耗时的命令场景下，这些成本并不低。</li><li>为保证多线程环境下命令的顺序一致性与原子性，必须引入锁或其他同步机制，进一步增加运行时开销。</li><li>数据结构需要从原本的单线程模型，重构为并发安全的版本，设计复杂度和维护成本显著上升。</li><li>额外的线程还会带来一定的内存和系统资源占用。</li></ul><p>在 Redis 的典型使用场景中，单线程已经可以在内存中以极低的延迟完成命令解析与执行。相比潜在的性能收益，多线程执行命令所带来的复杂性和不确定性更高。</p><p>因此，Redis 选择保持命令执行的单线程模型，将多线程仅用于网络 I/O 等更容易并行、且收益明确的环节。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Redis 的<strong>命令执行是单线程的</strong></li><li>高性能来自：<ul><li>内存模型</li><li>高效数据结构</li><li>I/O 多路复用</li></ul></li><li>Redis 6.0 的多线程仅用于 <strong>网络 I/O</strong></li><li>单线程不是缺陷，而是经过权衡后的设计结果</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术图谱</title>
      <link href="/2025/12/20/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
      <url>/2025/12/20/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="技术图谱"><a href="#技术图谱" class="headerlink" title="技术图谱"></a>技术图谱</h1><blockquote><p>这个置顶帖暂时先这么写着，后续改成导航一样的……有技术路线、也有其他方面的（感觉得等这阵子忙完……）</p><p>附带优先级（数字高优先级越高）</p></blockquote><p>【200】项目学习</p><p>【100】MySQL：增强表述</p><p>【100】Redis：博客todo：4️⃣事务（+Lua）、5️⃣三种架构（主从复制模式、哨兵Sentinel模式、集群Cluster模式）、6️⃣缓存穿透、缓存击穿、缓存雪崩 +增强表述</p><p>【100】Spring框架：博客todo：IoC 和 AOP 的博客。（这部分感觉偏实际开发）</p><p>【100】leetcode算法，最近太忙了都没刷……现阶段确实不需要刷了……先提高工程能力再说，以前刷的够多了……<a href="https://leetcode.cn/u/mu-xue-avid/">个人主页</a>，等项目做完了回归每天刷题节奏（但是少刷点一天2题差不多）</p><p>【70】消息队列：现在只会简单的使用+懂一点基本的概念（Topic、生产者、消费者），用来开发应该没问题，建议上面的扎实了以后来补一块技术。</p><p>【15】Java 集合框架（没写博客梳理）：Map、Collection：（List、Set、Queue）</p><p>【15】JUC：没写博客梳理，建议写博客（关于表述：经常用到的话总能说出来……吧，多去用！）</p><p>【10】设计模式（提高）</p><p>【5】Java 基础（经常使用，但没写博客系统梳理过）：面向对象、语言特性、数据结构、常见类、异常、泛型、反射、注解、SPI、I/O、Java 8新特性</p><p>【0】JVM：写了博客（需要拆分内容），语言表述能力不行，优先级暂时不高</p><p>【0】Linux博客梳理</p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker个人实践记录</title>
      <link href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Docker 实践</h1><blockquote><p>都是 windows 平台</p></blockquote><h2 id="日常-MySQL">日常 MySQL</h2><p>当然数据库启动后，可以使用很多可视化工具进行查看。不过我比较喜欢使用 docker 命令管理（主要是感觉开个终端查看也很方便）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 查看正在运行的容器</span><br><span class="line">docker ps </span><br><span class="line"></span><br><span class="line">-- 进入容器内部</span><br><span class="line">docker exec -it &lt;mysql-x.x&gt; bash </span><br><span class="line"></span><br><span class="line">-- 进入后：</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; mysql -uroot -p123456</span></span><br><span class="line"></span><br><span class="line">-- 然后就是数据库操作：</span><br><span class="line">show databases;</span><br><span class="line">use ...;</span><br><span class="line">show tables;</span><br><span class="line">desc ...;</span><br><span class="line">select * from ... limit 0,10;</span><br></pre></td></tr></table></figure><h2 id="查看容器卷挂载情况">查看容器卷挂载情况</h2><p>场景：我项目学习时，需要使用到 canal 对数据库的 binlog 进行订阅，然后发送消息，再去实现 Redis 数据的同步更新。</p><p>因为 canal 是依赖于 binlog 日志的，所以要开启 MySQL 的 binlog 日志。由于没开，所以写进行配置——查到配置是要写进 my.conf 配置文件，但是由于是 docker 容器，所以得看一下卷挂载路径，否则进入容器内部、即使修改了配置文件，下次启动时还是会失效。</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916050.png" alt="image-20251216155252457" style="zoom: 55%;" /><p>在查资料时，学到了下面一个指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看容器启动时的各种参数</span><br><span class="line">docker inspect &lt;container&gt;</span><br><span class="line"></span><br><span class="line">-- windows 平台可以使用以下的过滤语句</span><br><span class="line">-- linux 使用 | grep（但是win显然不是）</span><br><span class="line">docker inspect mysql-5.7 | Select-String -Pattern &quot;Source|Destination|Env&quot;</span><br></pre></td></tr></table></figure><p>使用<code>| Select-String -Pattern &quot;&quot;</code>进行过滤操作（直接使用 inspect 也行，就是信息有点多）</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916052.png" alt="image-20251216155706445" style="zoom: 90%;" /><p>然后根据旧容器的信息，整理出来新的容器启动参数（为了对旧数据迁移、新增-v配置挂载参数）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql-5.7 </span><br><span class="line">-p 3306:3306 </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 </span><br><span class="line">-e MYSQL_ROOT_HOST=% </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意下面的 -v 是数据卷挂载，由于之前的数据挂载是虚拟的，所以迁移时要带上（否则旧数据丢失）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个内容是在 docker inspect 的完整输出里面“amount”参数里可以找到</span></span><br><span class="line">-v 8fccc55c224db88d6d18cf70cb95670c4500977e9553d6c33272e1942225e21c:/var/lib/mysql </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增的配置文件挂载：</span></span><br><span class="line">-v E:/develop_tools/Docker_data/mysql-5.7/conf/canal.cnf:/etc/mysql/conf.d/canal.cnf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定镜像：</span></span><br><span class="line">-d mysql:5.7.36</span><br></pre></td></tr></table></figure><p>进入容器后，进行验证，发现确实映射到了宿主机的文件：</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916053.png" alt="image-20251216161519163" style="zoom: 85%;" /><p>但是修改完了还是没能让 binlog 开启：</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916054.png" alt="image-20251216162713237" style="zoom: 65%;" /><p>（问ai说是字符编码有问题（？））所以使用 vscode 修改其编码为 UTF-8 和 LF（实际没去验证，但是还是改了）：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916055.png" alt="image-20251216161644773"></p><p>但是修改完后，查看 binlog 有无开启，还是没开启的状态。所以问题不在于此……</p><p>终极方法使用<code>docker logs mysql-5.7</code>查看日志信息——</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916056.png" alt="image-20251216162832834" style="zoom: 50%;" /><p>关键信息：<code>mysqld: [Warning] World-writable config file '/etc/mysql/conf.d/canal.cnf' is ignored.</code></p><p>意思就是这个配置文件的权限太大了，mysql任务不安全，于是忽略了这个配置文件。</p><p>使用 <code>chmod</code> 命令移除其他用户的写入权限（将权限设置为 <code>644</code> 或 <code>600</code> 等）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-5.7 /bin/bash -c &quot;chmod 644 /etc/mysql/conf.d/canal.cnf&quot;</span><br></pre></td></tr></table></figure><p>之后<code>docker restart mysql-5.7</code>，问题解决：</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251220170916057.png" alt="image-20251216163652851" style="zoom: 85%;" />]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON处理工具</title>
      <link href="/2025/12/14/Java/JSON%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/12/14/Java/JSON%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1>JSON 处理工具</h1><p>使用依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson2.JSONObject;</span><br></pre></td></tr></table></figure><p>使用 JSONObject 和 JSON 即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 底层数据结构</title>
      <link href="/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>Redis 底层数据结构</h1><p>Redis 的高性能并非来自单一结构，而是通过<strong>多种针对场景高度定制的数据结构</strong>实现。上层五种数据类型（String / List / Hash / Set / ZSet）只是抽象接口，真正的性能边界由底层结构决定。</p><h2 id="SDS（Simple-Dynamic-String）">SDS（Simple Dynamic String）</h2><h3 id="基本原理">基本原理</h3><p>SDS 是 Redis 自定义的字符串实现，替代 C 原生 <code>char*</code>。其核心是<strong>显式维护字符串长度与剩余空间</strong>。</p><p>典型结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;    <span class="comment">// 已用长度</span></span><br><span class="line">    <span class="type">int</span> alloc;  <span class="comment">// 分配总长度</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心特点">核心特点</h3><ul><li>O(1) 获取长度（避免 <code>strlen</code>）</li><li>支持二进制数据（不依赖 <code>\0</code>作为字符串的结尾）</li><li>预分配与惰性释放，减少内存重分配</li><li>避免缓冲区溢出</li></ul><h3 id="使用到的数据类型">使用到的数据类型</h3><ul><li>String</li><li>所有 key</li><li>Hash / List / Set / ZSet 内部元素</li></ul><h3 id="时间复杂度">时间复杂度</h3><ul><li>获取长度：O(1)</li><li>追加：均摊 O(1)</li><li>修改：O(n)</li></ul><h2 id="链表（Linked-List）">链表（Linked List）</h2><h3 id="基本原理-2">基本原理</h3><p>双向链表，每个节点独立分配内存，保存前后指针与值指针。</p><h3 id="核心特点-2">核心特点</h3><ul><li>双向</li><li>无环</li><li>表头表尾指针</li><li>节点值为 <code>void*</code>，类型无关</li></ul><h3 id="使用到的数据类型-2">使用到的数据类型</h3><ul><li>List（早期实现）</li><li>发布订阅消息队列</li><li>慢查询日志</li><li>客户端列表</li></ul><h3 id="时间复杂度-2">时间复杂度</h3><ul><li>头尾插入 / 删除：O(1)</li><li>按值查找：O(n)</li></ul><h3 id="现状">现状</h3><p><strong>已被 quicklist 取代作为 List 的主要实现</strong>。</p><h2 id="压缩列表（ziplist）">压缩列表（ziplist）</h2><h3 id="基本原理-3">基本原理</h3><p>一段<strong>连续内存</strong>，通过偏移量描述节点，无指针。</p><p>每个 entry 包含：</p><ul><li>前一个 entry 的长度</li><li>当前数据编码与长度</li><li>实际数据</li></ul><h3 id="核心特点-3">核心特点</h3><ul><li>极致节省内存</li><li>顺序存储，CPU cache 友好</li><li>插入可能引发<strong>连锁更新</strong></li></ul><h3 id="使用到的数据类型-3">使用到的数据类型</h3><ul><li>List（旧）</li><li>Hash（小规模）</li><li>ZSet（小规模）</li></ul><h3 id="时间复杂度-3">时间复杂度</h3><ul><li>访问：O(n)</li><li>插入 / 删除：O(n)</li></ul><h3 id="现状-2">现状</h3><p>Redis 7 之前使用，<strong>已被 listpack 全面替代</strong>。</p><h2 id="哈希表（Dict）">哈希表（Dict）</h2><h3 id="基本原理-4">基本原理</h3><p>标准 <strong>Hash Table + 链地址法</strong>，支持<strong>渐进式 rehash</strong>。</p><p>核心结构：</p><ul><li>两张哈希表（ht[0], ht[1]）</li><li>rehash index</li></ul><h3 id="核心特点-4">核心特点</h3><ul><li>扩容期间分批迁移</li><li>避免阻塞</li><li>支持自定义 hash 函数</li></ul><h3 id="使用到的数据类型-4">使用到的数据类型</h3><ul><li>Hash（大规模）</li><li>Set</li><li>ZSet（score 映射）</li><li>全局 key 空间</li></ul><h3 id="时间复杂度-4">时间复杂度</h3><ul><li>查找 / 插入 / 删除：O(1) 平均，O(n) 最坏</li><li>rehash：均摊 O(1)</li></ul><h2 id="整数集合（intset）">整数集合（intset）</h2><h3 id="基本原理-5">基本原理</h3><p>用于存储<strong>仅包含整数的集合</strong>，底层为有序数组。</p><p>支持三种编码：</p><ul><li>int16_t</li><li>int32_t</li><li>int64_t（自动升级，不降级）</li></ul><h3 id="核心特点-5">核心特点</h3><ul><li>内存占用极小</li><li>自动升级保证正确性</li><li>有序存储，二分查找</li></ul><h3 id="使用到的数据类型-5">使用到的数据类型</h3><ul><li>Set（所有元素为整数且数量较少）</li></ul><h3 id="时间复杂度-5">时间复杂度</h3><ul><li>查找：O(log n)</li><li>插入 / 删除：O(n)</li></ul><h2 id="跳表（SkipList）">跳表（SkipList）</h2><h3 id="基本原理-6">基本原理</h3><p>多层链表结构，通过随机层级实现近似平衡。</p><h3 id="核心特点-6">核心特点</h3><ul><li>实现简单</li><li>范围查询高效</li><li>与哈希表组合使用</li></ul><h3 id="使用到的数据类型-6">使用到的数据类型</h3><ul><li>ZSet（按 score 排序）</li></ul><p>ZSet 实际结构：</p><ul><li>Hash：member → score</li><li>SkipList：按 score 排序</li></ul><h3 id="时间复杂度-6">时间复杂度</h3><ul><li>查找 / 插入 / 删除：O(log n)</li><li>范围查询：O(log n + m)</li></ul><h2 id="quicklist">quicklist</h2><h3 id="基本原理-7">基本原理</h3><p><strong>链表 + ziplist/listpack</strong> 的混合结构。</p><ul><li>外层：双向链表</li><li>内层：压缩列表（旧）或 listpack（新）</li></ul><h3 id="核心特点-7">核心特点</h3><ul><li>降低指针开销</li><li>控制单块内存大小</li><li>平衡插入性能与内存效率</li></ul><h3 id="使用到的数据类型-7">使用到的数据类型</h3><ul><li>List（Redis 3.2+）</li></ul><h3 id="时间复杂度-7">时间复杂度</h3><ul><li>头尾操作：O(1)</li><li>中间访问：O(n)</li></ul><h2 id="listpack">listpack</h2><h3 id="基本原理-8">基本原理</h3><p>ziplist 的重写版本，<strong>彻底解决连锁更新问题</strong>。</p><p>核心改进：</p><ul><li>不再存储前一个 entry 的长度</li><li>更紧凑的编码设计</li><li>更明确的边界信息</li></ul><h3 id="核心特点-8">核心特点</h3><ul><li>更安全</li><li>更易扩展</li><li>更适合大规模元素</li></ul><h3 id="使用到的数据类型-8">使用到的数据类型</h3><ul><li>List</li><li>Hash</li><li>ZSet</li></ul><h3 id="时间复杂度-8">时间复杂度</h3><ul><li>访问 / 插入 / 删除：O(n)</li><li>实际性能优于 ziplist</li></ul><h2 id="总结">总结</h2><p>Redis 的设计逻辑明确：</p><ul><li><strong>小数据量 → 连续内存 → 节省内存</strong></li><li><strong>大数据量 → 复合结构 → 保证性能</strong></li><li><strong>写放大可接受，读路径必须稳定</strong></li></ul><p>理解这些底层结构，才能在以下问题上做出正确判断：</p><ul><li>key 设计</li><li>value 结构选择</li><li>内存占用评估</li><li>性能瓶颈定位</li></ul><p>Redis 的性能不是魔法，而是工程取舍的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中Lua脚本的使用</title>
      <link href="/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>Redis中Lua脚本的使用</h1><p>参考资料：<a href="https://www.cnblogs.com/felordcn/p/13838321.html">cnblogs.com</a>、<a href="https://redis.io/docs/latest/develop/programmability/eval-intro/?utm_source=chatgpt.com">Redis</a></p><h2 id="Lua-脚本介绍">Lua 脚本介绍</h2><p>Redis 从 2.6 版本开始内置 Lua 脚本执行引擎，用于在服务器端组合多个 Redis 命令为一个原子操作，从而避免客户端多次往返网络、保证复杂逻辑的原子性执行。Lua 是一种轻量级、可嵌入的脚本语言，非常适合嵌入 Redis 这种高性能内存数据库中。</p><p>Lua 在 Redis 中执行时无需额外配置，只需通过命令将脚本发送到 Redis。脚本由 Redis Server 内的 Lua 5.1 解释器运行。Redis 脚本将命令组合在一起，避免多次网络往返，并在执行期间阻塞其他客户端命令，确保原子性。脚本执行结果可返回值给客户端。</p><h2 id="Lua-脚本基本语法">Lua 脚本基本语法</h2><p>Lua 语法简单，适合嵌入式脚本应用。基本数据类型包括：<code>nil</code>（空）、<code>boolean</code>（布尔值）、<code>number</code>（数字）、<code>string</code>（字符串）和 <code>table</code>（表）。<code>table</code> 是 Lua 的核心数据结构，它既可表现为数组也可表现为字典。</p><p>变量声明：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;example&#x27;</span>       <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> age = <span class="number">18</span>         <span class="comment">-- 局部变量</span></span><br></pre></td></tr></table></figure><p>表（类似数组、字典）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>&#125;        <span class="comment">-- 数组样</span></span><br><span class="line"><span class="keyword">local</span> dict = &#123;key=<span class="string">&#x27;value&#x27;</span>&#125;       <span class="comment">-- 字典样</span></span><br></pre></td></tr></table></figure><p>控制结构类似其他语言：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> x &lt; <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;medium&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;large&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>循环遍历表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>返回值可以使用 <code>return</code>，Lua 支持返回多个值，但在 Redis 脚本中推荐返回一个表以避免客户端解析混乱。</p><h2 id="Lua-脚本在-Redis-中的使用方式">Lua 脚本在 Redis 中的使用方式</h2><p>在 Redis 中执行 Lua 脚本核心命令是 <code>EVAL</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; &lt;key1&gt; ... &lt;keyN&gt; &lt;arg1&gt; ... &lt;argM&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;script&gt;</code>：Lua 脚本内容</li><li><code>&lt;numkeys&gt;</code>：脚本使用的 Redis 键数量</li><li>接下来是 <code>&lt;key1&gt; ... keyN</code>，脚本中通过 <code>KEYS[1]</code> 等访问</li><li>余下是参数通过 <code>ARGV[1]</code> 等访问。</li></ul><p>键与参数分离的目的是让 Redis 能够基于 <code>numkeys</code> 提前分析访问的键，有助于集群模式下正确路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span> 1 mykey</span><br></pre></td></tr></table></figure><p>Redis 还提供了脚本缓存机制，通过 <code>SCRIPT LOAD</code> 加载脚本并返回 SHA1 摘要，然后可用 <code>EVALSHA</code> 执行，避免每次发送完整脚本字符串，提高性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD <span class="string">&quot;return &#x27;hello&#x27;&quot;</span></span><br><span class="line">EVALSHA &lt;sha1&gt; 0</span><br></pre></td></tr></table></figure><h2 id="Redis-中-Lua-脚本的特性与原理">Redis 中 Lua 脚本的特性与原理</h2><p>Lua 脚本在 Redis 内部执行时具有以下关键特性：</p><ul><li><strong>原子性</strong>：整个脚本在执行期间不会被打断，所有命令作为一个原子事务运行。</li><li><strong>阻塞执行</strong>：执行期间 Redis 不处理其他客户端命令，因此脚本应保持短小以避免阻塞客户端。</li><li><strong>数据类型转换</strong>：Lua 与 Redis 之间数据互传需进行类型转换，例如 Lua 返回的小数可能被转换成整数。</li><li><strong>错误处理</strong>：<code>redis.call()</code> 在命令错误时会抛出错误，中断脚本；<code>redis.pcall()</code> 则返回错误表，可在脚本内部捕获处理。</li></ul><h2 id="Redis-中的最佳实践">Redis 中的最佳实践</h2><p><strong>脚本设计</strong><br>Lua 脚本应尽量保持短、逻辑简单。避免大型循环或长耗时计算，因为它们会阻塞 Redis 线程。</p><p><strong>参数与键分离</strong><br>使用 <code>KEYS</code> 和 <code>ARGV</code> 明确区分 Redis 键和参数。键用于 Redis 访问，参数用于业务逻辑。Redis 集群模式下所有键应在同一槽位以避免错误脚本行为。</p><p><strong>缓存机制</strong><br>尽可能通过 <code>SCRIPT LOAD</code> 和 <code>EVALSHA</code> 重用脚本，减少网络传输和重复编译开销。</p><p><strong>错误与测试</strong><br>在上线前全面测试脚本逻辑。脚本执行失败不会自动回滚之前的修改。需要在业务层处理失败后的状态一致性。</p><p><strong>避免复杂 Lua 特性</strong><br>Lua 有许多语言特性如协程、复杂函数定义等，但在 Redis 脚本中应避免使用，聚焦于简单逻辑以提高可维护性。</p><p>以下内容在 Redis + Lua 的工程语境下展开，强调<strong>为什么用、怎么用、避免什么</strong>。</p><h2 id="Redis-使用实例">Redis 使用实例</h2><h3 id="库存扣减（高并发原子性）">库存扣减（高并发原子性）</h3><p><strong>场景</strong></p><p>秒杀、抢购、优惠券库存扣减。<br>要求：<strong>不能超卖、不能多扣、必须原子执行</strong>。</p><p><strong>问题本质</strong></p><p>以下逻辑如果拆散为多条命令，会产生竞态条件：</p><ol><li>查询库存</li><li>判断是否大于 0</li><li>扣减库存</li></ol><p><strong>Lua 脚本实现</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> stock <span class="keyword">or</span> stock &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;DECR&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> stock - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>Redis 调用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">&quot;&lt;lua-script&gt;&quot;</span> 1 stock:sku:1001</span><br></pre></td></tr></table></figure><p><strong>价值</strong></p><ul><li>单线程原子执行</li><li>无需 Redis 事务（MULTI/EXEC）</li><li>避免客户端 CAS 自旋</li><li>秒杀场景标准解法</li></ul><h3 id="分布式限流（滑动窗口）">分布式限流（滑动窗口）</h3><p><strong>场景</strong></p><p>接口防刷、短信验证码、登录频控。</p><p><strong>限流规则示例</strong></p><ul><li>每个用户</li><li>10 秒内最多 5 次</li></ul><p><strong>Lua 脚本实现（ZSET）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> window = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;ZREMRANGEBYSCORE&#x27;</span>, key, <span class="number">0</span>, now - window)</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;ZCARD&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count &gt;= limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;ZADD&#x27;</span>, key, now, now)</span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, window)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li>精确滑动窗口</li><li>清理 + 判断 + 写入一次完成</li><li>避免多命令时间漂移</li></ul><p><strong>价值</strong></p><ul><li>高并发下限流结果一致</li><li>Lua 是唯一正确解法</li></ul><h3 id="防重复提交-幂等控制">防重复提交 / 幂等控制</h3><p><strong>场景</strong></p><ul><li>表单重复提交</li><li>订单重复创建</li><li>MQ 消费幂等</li></ul><p><strong>典型逻辑</strong></p><ul><li>key 不存在 → 执行业务</li><li>key 存在 → 拒绝</li></ul><p><strong>Lua 脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;EXISTS&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="string">&#x27;EX&#x27;</span>, ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>SETNX + EXPIRE 原子化</li><li>不依赖 Redis 版本是否支持 SET key value NX EX</li></ul><h2 id="Java-中调用-Redis-Lua-脚本">Java 中调用 Redis Lua 脚本</h2><h3 id="StringRedisTemplate-调用方式"><strong>StringRedisTemplate 调用方式</strong></h3><p>适用场景</p><ul><li>key / value 都是字符串</li><li>绝大多数业务场景首选</li></ul><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lua</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;local stock = tonumber(redis.call(&#x27;GET&#x27;, KEYS[1])) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if not stock or stock &lt;= 0 then return -1 end &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;DECR&#x27;, KEYS[1]) return stock - 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">script.setScriptText(lua);</span><br><span class="line">script.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        script,</span><br><span class="line">        Collections.singletonList(<span class="string">&quot;stock:sku:1001&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>关键点</p><ul><li><code>KEYS</code> → List 传入</li><li><code>ARGV</code> → execute 后的可变参数</li><li>返回值类型必须显式声明</li></ul><h3 id="RedisTemplate-调用方式">RedisTemplate 调用方式</h3><p>适用场景</p><ul><li>value 是对象、JSON、复杂结构</li><li>使用序列化器</li></ul><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">script.setScriptText(lua);</span><br><span class="line">script.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; keys = Arrays.asList(<span class="string">&quot;stock:sku:1001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">        script,</span><br><span class="line">        redisTemplate.getStringSerializer(),</span><br><span class="line">        redisTemplate.getValueSerializer(),</span><br><span class="line">        keys</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Redis 内置 Lua 脚本功能用于将一系列命令组合为一个原子操作，提高性能、减少网络往返、保证逻辑一致性。Lua 语法简单，适合轻量级编写 Redis 逻辑。通过 <code>EVAL</code>、<code>EVALSHA</code>、<code>SCRIPT LOAD</code> 等命令执行和管理脚本，结合良好设计和测试策略，可显著提升 Redis 的开发效率与运行稳定性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RedisTemplate &amp; StringRedisTemplate 使用指南</title>
      <link href="/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>RedisTemplate &amp; StringRedisTemplate 使用指南</h1><h2 id="前言">前言</h2><p>由于对于 Redis 始终停留在理论阶段——懂数据结构类型、数据结构底层实现、缓存击穿、缓存穿透、缓存雪崩，还有各种防xxx的方案，但是貌似都停留在学习上、代码阅读上，现在重新补充一下代码实现的细节上。</p><p>项目中很多地方使用了 StringRedisTemplate，其实是继承自 RedisTemplate 的。</p><p>然后就去搜 RedisTemplate 的 API、搜如何使用，挑选了7-8篇博客结合 ai 整理知识点如下：</p><h2 id="从导入依赖开始">从导入依赖开始</h2><p>为什么是从导入依赖开始呢？主要是这个过程引发了我的疑问：</p><p>看到有一篇博客使用如下pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我的项目中使用如下pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么引入的是 redisson，但是还能使用StringRedisTemplate 呢？</p><p>询问了一遍ai，两者的对比：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐依赖</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>分布式锁</strong></td><td><strong>Redisson</strong></td><td>提供标准的 <code>RLock</code> 接口，内置看门狗（Watchdog）自动续期机制，健壮性高。</td></tr><tr><td><strong>基础缓存/Session</strong></td><td><strong>Spring Data Redis</strong></td><td>使用 <code>RedisTemplate</code> 或 Spring Cache 抽象，更贴合 Spring 生态标准。</td></tr><tr><td><strong>分布式限流/信号量</strong></td><td><strong>Redisson</strong></td><td>提供现成的 <code>RRateLimiter</code> 和 <code>RSemaphore</code>，直接调用即可。</td></tr><tr><td><strong>复杂数据结构操作</strong></td><td><strong>Redisson</strong></td><td>提供 <code>RMap</code>, <code>RSet</code> 等，操作方式与 Java 集合类一致，更符合面向对象习惯。</td></tr><tr><td><strong>直接执行 Redis 命令</strong></td><td><strong>Spring Data Redis</strong></td><td><code>RedisTemplate</code> 可以直接执行如 <code>opsForValue().set(...)</code> 等命令，与原生 Redis 命令映射更直接。</td></tr></tbody></table><p>所以想要使用 RedisTemplate 对数据库进行操作，本质上是要导入 <code>spring-boot-starter-data-redis</code>的。（然后导入 Redisson 其实就导入了 Spring Data Redis）</p><h2 id="写application-yml">写application.yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">password:</span></span><br></pre></td></tr></table></figure><h2 id="RedisTemplate-常用-API">RedisTemplate 常用 API</h2><p>Spring Data Redis 提供了 <code>RedisTemplate</code> 和 <code>StringRedisTemplate</code> 两个核心模板类。<code>RedisTemplate</code> 支持泛型（默认 JDK 序列化），<code>StringRedisTemplate</code> 专用于 String 类型的 Key-Value 操作（String 序列化）。</p><p>核心操作入口：</p><ul><li><code>opsForValue()</code>：操作 String（字符串）</li><li><code>opsForHash()</code>：操作 Hash（哈希）</li><li><code>opsForList()</code>：操作 List（列表）</li><li><code>opsForSet()</code>：操作 Set（集合）</li><li><code>opsForZSet()</code>：操作 ZSet（有序集合）</li></ul><h3 id="String-类型">String 类型</h3><p>对应的 Redis 结构：String</p><p>核心类：ValueOperations&lt;K, V&gt;</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>set(key, value)</code></td><td><code>SET key value</code></td><td>设置键值对</td></tr><tr><td><code>set(key, value, timeout, unit)</code></td><td><code>SETEX key seconds value</code></td><td>设置键值对并指定过期时间</td></tr><tr><td><code>setIfAbsent(key, value)</code></td><td><code>SETNX key value</code></td><td>只有键不存在时才设置（分布式锁基础）</td></tr><tr><td><code>get(key)</code></td><td><code>GET key</code></td><td>获取值</td></tr><tr><td><code>increment(key, delta)</code></td><td><code>INCRBY key increment</code></td><td>原子递增</td></tr><tr><td><code>decrement(key, delta)</code></td><td><code>DECRBY key decrement</code></td><td>原子递减</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">public void stringDemo() &#123;</span><br><span class="line">    // 1. SET: 设置值</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;user:1001&quot;, &quot;Jason&quot;);</span><br><span class="line"></span><br><span class="line">    // 2. SETEX: 设置值并设置5分钟过期</span><br><span class="line">    redisTemplate.opsForValue().set(&quot;code:1234&quot;, &quot;8888&quot;, 5, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    // 3. SETNX: 如果不存在则设置 (返回 boolean)</span><br><span class="line">    Boolean isSet = redisTemplate.opsForValue().setIfAbsent(&quot;lock:order:1&quot;, &quot;locked&quot;);</span><br><span class="line"></span><br><span class="line">    // 4. INCR: 计数器自增</span><br><span class="line">    redisTemplate.opsForValue().increment(&quot;article:view:1&quot;, 1);</span><br><span class="line">    </span><br><span class="line">    // 5. GET: 获取</span><br><span class="line">    Object value = redisTemplate.opsForValue().get(&quot;user:1001&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash-类型">Hash 类型</h3><p>对应的 Redis 结构：Hash</p><p>核心类：HashOperations&lt;K, HK, HV&gt;</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>put(key, hashKey, value)</code></td><td><code>HSET key field value</code></td><td>设置 Hash 字段值</td></tr><tr><td><code>putAll(key, map)</code></td><td><code>HMSET key field value ...</code></td><td>批量设置 Hash 字段</td></tr><tr><td><code>get(key, hashKey)</code></td><td><code>HGET key field</code></td><td>获取指定字段值</td></tr><tr><td><code>entries(key)</code></td><td><code>HGETALL key</code></td><td>获取 Hash 表中所有字段和值</td></tr><tr><td><code>keys(key)</code></td><td><code>HKEYS key</code></td><td>获取所有字段名</td></tr><tr><td><code>delete(key, hashKey)</code></td><td><code>HDEL key field</code></td><td>删除一个或多个字段</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void hashDemo() &#123;</span><br><span class="line">    String key = &quot;cart:user:1001&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1. HSET: 添加商品到购物车</span><br><span class="line">    redisTemplate.opsForHash().put(key, &quot;sku_123&quot;, &quot;1&quot;);</span><br><span class="line">    </span><br><span class="line">    // 2. HMSET: 批量添加</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;sku_456&quot;, &quot;2&quot;);</span><br><span class="line">    map.put(&quot;sku_789&quot;, &quot;5&quot;);</span><br><span class="line">    redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">    </span><br><span class="line">    // 3. HGET: 获取特定商品数量</span><br><span class="line">    Object count = redisTemplate.opsForHash().get(key, &quot;sku_123&quot;);</span><br><span class="line">    </span><br><span class="line">    // 4. HGETALL: 获取购物车所有商品</span><br><span class="line">    Map&lt;Object, Object&gt; items = redisTemplate.opsForHash().entries(key);</span><br><span class="line">    </span><br><span class="line">    // 5. HDEL: 删除商品</span><br><span class="line">    redisTemplate.opsForHash().delete(key, &quot;sku_123&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List-类型">List 类型</h3><p>对应的 Redis 结构：List (双向链表)</p><p>核心类：ListOperations&lt;K, V&gt;</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>leftPush(key, value)</code></td><td><code>LPUSH key value</code></td><td>从左侧（头部）推入</td></tr><tr><td><code>rightPush(key, value)</code></td><td><code>RPUSH key value</code></td><td>从右侧（尾部）推入</td></tr><tr><td><code>leftPop(key)</code></td><td><code>LPOP key</code></td><td>从左侧弹出</td></tr><tr><td><code>rightPop(key)</code></td><td><code>RPOP key</code></td><td>从右侧弹出</td></tr><tr><td><code>range(key, start, end)</code></td><td><code>LRANGE key start stop</code></td><td>获取指定范围元素（0, -1 为全部）</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void listDemo() &#123;</span><br><span class="line">    String key = &quot;task:queue&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1. LPUSH: 生产者推送消息</span><br><span class="line">    redisTemplate.opsForList().leftPush(key, &quot;task_1&quot;);</span><br><span class="line">    redisTemplate.opsForList().leftPushAll(key, &quot;task_2&quot;, &quot;task_3&quot;);</span><br><span class="line">    </span><br><span class="line">    // 2. RPOP: 消费者消费消息</span><br><span class="line">    Object task = redisTemplate.opsForList().rightPop(key);</span><br><span class="line">    </span><br><span class="line">    // 3. LRANGE: 查看队列所有数据</span><br><span class="line">    List&lt;Object&gt; allTasks = redisTemplate.opsForList().range(key, 0, -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-类型">Set 类型</h3><p>对应的 Redis 结构：Set (无序去重集合)</p><p>核心类：SetOperations&lt;K, V&gt;</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>add(key, values...)</code></td><td><code>SADD key member ...</code></td><td>添加元素</td></tr><tr><td><code>members(key)</code></td><td><code>SMEMBERS key</code></td><td>获取所有成员</td></tr><tr><td><code>isMember(key, value)</code></td><td><code>SISMEMBER key member</code></td><td>判断是否是成员</td></tr><tr><td><code>size(key)</code></td><td><code>SCARD key</code></td><td>获取集合大小</td></tr><tr><td><code>remove(key, values...)</code></td><td><code>SREM key member ...</code></td><td>移除元素</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setDemo() &#123;</span><br><span class="line">    String key = &quot;users:like:article:1&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1. SADD: 点赞（去重）</span><br><span class="line">    redisTemplate.opsForSet().add(key, &quot;user_1&quot;, &quot;user_2&quot;, &quot;user_3&quot;);</span><br><span class="line">    </span><br><span class="line">    // 2. SISMEMBER: 检查是否点赞过</span><br><span class="line">    Boolean hasLiked = redisTemplate.opsForSet().isMember(key, &quot;user_1&quot;);</span><br><span class="line">    </span><br><span class="line">    // 3. SMEMBERS: 获取所有点赞用户</span><br><span class="line">    Set&lt;Object&gt; users = redisTemplate.opsForSet().members(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZSet-类型">ZSet 类型</h3><p>对应的 Redis 结构：Sorted Set (有序集合)</p><p>核心类：ZSetOperations&lt;K, V&gt;</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>add(key, value, score)</code></td><td><code>ZADD key score member</code></td><td>添加元素并指定分数</td></tr><tr><td><code>range(key, start, end)</code></td><td><code>ZRANGE key start stop</code></td><td>正序获取范围元素</td></tr><tr><td><code>reverseRange(key, start, end)</code></td><td><code>ZREVRANGE key start stop</code></td><td>倒序获取范围元素（常用于排行榜）</td></tr><tr><td><code>incrementScore(key, v, delta)</code></td><td><code>ZINCRBY key increment member</code></td><td>增加元素分数</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><p>Java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void zSetDemo() &#123;</span><br><span class="line">    String key = &quot;game:rank&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1. ZADD: 更新玩家分数</span><br><span class="line">    redisTemplate.opsForZSet().add(key, &quot;PlayerA&quot;, 100);</span><br><span class="line">    redisTemplate.opsForZSet().add(key, &quot;PlayerB&quot;, 95);</span><br><span class="line">    </span><br><span class="line">    // 2. ZINCRBY: 分数增加</span><br><span class="line">    redisTemplate.opsForZSet().incrementScore(key, &quot;PlayerA&quot;, 10); // 变为 110</span><br><span class="line">    </span><br><span class="line">    // 3. ZREVRANGE: 获取 Top 10 排行榜</span><br><span class="line">    Set&lt;Object&gt; top10 = redisTemplate.opsForZSet().reverseRange(key, 0, 9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用-Key-操作">通用 Key 操作</h3><p>这些操作直接在 <code>RedisTemplate</code> 实例上调用，不经过 <code>opsForX</code>。</p><table><thead><tr><th><strong>方法 (Java)</strong></th><th><strong>原始指令 (Redis)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>delete(key)</code></td><td><code>DEL key</code></td><td>删除 Key</td></tr><tr><td><code>hasKey(key)</code></td><td><code>EXISTS key</code></td><td>检查 Key 是否存在</td></tr><tr><td><code>expire(key, time, unit)</code></td><td><code>EXPIRE key seconds</code></td><td>设置过期时间</td></tr><tr><td><code>getExpire(key)</code></td><td><code>TTL key</code></td><td>获取剩余存活时间</td></tr><tr><td><code>keys(pattern)</code></td><td><code>KEYS pattern</code></td><td>查找匹配的 Key（生产环境慎用）</td></tr></tbody></table><p><strong>Java 代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;temp:data&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. EXPIRE: 设置过期时间</span></span><br><span class="line">    redisTemplate.expire(key, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. TTL: 获取剩余时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> redisTemplate.getExpire(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. DEL: 删除</span></span><br><span class="line">    redisTemplate.delete(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. EXISTS: 检查存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">exists</span> <span class="operator">=</span> redisTemplate.hasKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringRedisTemplate-常用-API">StringRedisTemplate 常用 API</h2><p><code>StringRedisTemplate</code> 是 <code>RedisTemplate&lt;String, String&gt;</code> 的子类，其 Key 和 Value 的序列化器默认都配置为 <code>StringRedisSerializer</code>。这意味着它存入 Redis 的数据是纯字符串，不会包含任何 Java 类信息（class info），在 Redis 客户端（如 redis-cli）中查看时完全可读。</p><p><strong>核心特点：</strong></p><ul><li><strong>Key</strong>：必须是 String。</li><li><strong>Value</strong>：必须是 String。</li><li><strong>适用场景</strong>：缓存简单的字符串、计数器、或者<strong>手动</strong>将对象转为 JSON 字符串后存储（这是最常用的方式，能避免序列化反序列化的类兼容性问题）。</li></ul><p>无需额外配置，Spring Boot 自动装配，直接注入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure><h3 id="String-类型-2">String 类型</h3><p><strong>场景</strong>：缓存 JSON 字符串、验证码、计数器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. SET: 存入普通字符串</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. SETEX: 存入验证码，60秒过期</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;sms:code:13800000000&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. INCR: 计数器 (虽然是字符串，但如果是数字格式，Redis 允许自增)</span></span><br><span class="line">    stringRedisTemplate.opsForValue().increment(<span class="string">&quot;page:view&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. GET: 取出</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;city&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash-类型-2">Hash 类型</h3><p><strong>注意</strong>：Hash 的 Field（项）和 Value（值）也都必须是 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hashDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:1001:profile&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. HSET: 所有的值都必须转为 String</span></span><br><span class="line">    stringRedisTemplate.opsForHash().put(key, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jason&quot;</span>);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(key, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>); <span class="comment">// int 要转 string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. HGET: 获取出来也是 String</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) stringRedisTemplate.opsForHash().get(key, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. HMGET: 获取多个字段</span></span><br><span class="line">    List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(key, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List-类型-2">List 类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;msg:queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LPUSH</span></span><br><span class="line">    stringRedisTemplate.opsForList().leftPush(key, <span class="string">&quot;message_1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LRANGE</span></span><br><span class="line">    List&lt;String&gt; list = stringRedisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-类型-2">Set 类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;tags:java&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SADD</span></span><br><span class="line">    stringRedisTemplate.opsForSet().add(key, <span class="string">&quot;spring&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;mybatis&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SMEMBERS</span></span><br><span class="line">    Set&lt;String&gt; members = stringRedisTemplate.opsForSet().members(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZSet-类型-2">ZSet 类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zsetDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;ranking&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ZADD</span></span><br><span class="line">    stringRedisTemplate.opsForZSet().add(key, <span class="string">&quot;user_a&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ZRANGE: 获取 String 类型的成员</span></span><br><span class="line">    Set&lt;String&gt; topUsers = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何存储对象？">如何存储对象？</h3><p>在企业开发中，<code>StringRedisTemplate</code> 最常见的用法是<strong>手动序列化</strong>。</p><p>为什么要手动序列化？</p><p>如果使用 RedisTemplate&lt;String, Object&gt; 并配置 Jackson 序列化器，Redis 中会存储额外的 @class 属性（全限定类名）。如果将来包名变了，或者不同项目共用 Redis 但包结构不同，反序列化就会报错。</p><p>使用 <code>StringRedisTemplate</code> + <code>JSON工具</code> 可以完全掌控数据格式，通用性最强。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">// 假设使用 Hutool 的 JSONUtil 或 Jackson 的 ObjectMapper</span></span><br><span class="line"><span class="comment">// import cn.hutool.json.JSONUtil;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objectDemo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Jason&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【存】：手动转为 JSON 字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(user); </span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, jsonStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【取】：取出字符串，手动转回对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">resultJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (resultJson != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">resultUser</span> <span class="operator">=</span> JSONUtil.toBean(resultJson, User.class);</span><br><span class="line">        System.out.println(resultUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐-StringRedisTemplate">推荐-StringRedisTemplate</h2><table><thead><tr><th><strong>模板类</strong></th><th><strong>泛型</strong></th><th><strong>序列化方式</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>StringRedisTemplate</strong></td><td><code>&lt;String, String&gt;</code></td><td>String 序列化</td><td><strong>首选</strong>。存取普通字符串，或<strong>手动转换 JSON 对象</strong>。数据通用性最强，无类名耦合。</td></tr><tr><td><strong>RedisTemplate</strong></td><td><code>&lt;String, Object&gt;</code></td><td>需手动配置 (JSON/JDK)</td><td>适合<strong>仅仅在 Java 内部使用</strong>，且不希望手动编写 JSON 转换代码的场景。但需注意类名兼容性。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm使用</title>
      <link href="/2025/12/10/%E5%89%8D%E7%AB%AF/nvm%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/12/10/%E5%89%8D%E7%AB%AF/nvm%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>nvm：Node 版本管理工具</h1><h2 id="nvm-是什么">nvm 是什么</h2><p>nvm（Node Version Manager）是一款用于管理 Node.js 版本的工具。它允许在同一台机器上安装多个 Node 版本，并可随时切换。避免因不同项目依赖不同 Node 版本而导致冲突。</p><p>核心功能</p><ul><li>安装多个 Node 版本</li><li>快速切换当前使用的版本</li><li>卸载不再需要的版本</li><li>隔离不同 Node 版本的全局包环境</li></ul><p>简单原理<br>nvm 使用目录隔离不同 Node 版本，并在你切换版本时动态修改系统 PATH 指向对应版本。无需重新安装系统级 Node，也不会破坏现有项目。</p><h2 id="Windows-平台的-nvm（nvm-windows）">Windows 平台的 nvm（nvm-windows）</h2><p>Windows 不支持官方 Linux nvm 工具，需要使用专门为 Windows 编写的版本：<br><strong>nvm-windows（又叫 nvm for Windows）</strong><br>这是一个独立实现，与 Linux/macOS 的原版 nvm 不同，但功能一致。</p><h2 id="Windows-安装步骤">Windows 安装步骤</h2><h3 id="卸载旧版-Node（若已安装）">卸载旧版 Node（若已安装）</h3><p>以前直接从官网安装过 Node，需要先卸载：<br>控制面板 → 程序 → 卸载 Node.js<br>并删除可能遗留的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\nodejs</span><br><span class="line">C:\Users\&lt;你的用户名&gt;\AppData\Roaming\npm</span><br></pre></td></tr></table></figure><h3 id="下载-nvm-windows">下载 nvm-windows</h3><p>下载地址（官方 GitHub Releases）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/coreybutler/nvm-windows/releases</span><br></pre></td></tr></table></figure><p>下载安装包：<br><strong>nvm-setup.exe</strong></p><h3 id="安装步骤">安装步骤</h3><p>安装过程只需注意两个路径：</p><ol><li><strong>NVM 安装目录</strong>（可以自定义）</li><li><strong>Node.js Symlink 目录</strong>（可以自定义）</li></ol><p>第二个目录是 nvm 切换版本时自动创建的链接目录，必须存在且不能被占用。</p><p>安装完成后，在终端输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm version</span><br></pre></td></tr></table></figure><p>若输出版本号，说明安装成功。</p><h2 id="nvm-的使用方法">nvm 的使用方法</h2><h3 id="查看可安装-Node-版本">查看可安装 Node 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list available</span><br></pre></td></tr></table></figure><h3 id="安装指定版本-Node">安装指定版本 Node</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 18.16.0</span><br></pre></td></tr></table></figure><p>安装多个版本也可以，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 20.19.0</span><br></pre></td></tr></table></figure><h3 id="查看本机已安装版本">查看本机已安装版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用</span></span><br><span class="line">nvm <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h3 id="切换使用的版本">切换使用的版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 18.16.0</span><br></pre></td></tr></table></figure><p>切换后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>即可看到当前生效版本。</p><h3 id="卸载某个-Node-版本">卸载某个 Node 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm uninstall 18.16.0</span><br></pre></td></tr></table></figure><h3 id="设置-npm-全局包镜像（可选）">设置 npm 全局包镜像（可选）</h3><p>切换 Node 版本后，每个版本都有自己的 npm 环境。</p><p>配置 npm registry：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h2 id="nvm-的简单工作原理">nvm 的简单工作原理</h2><ol><li><p>nvm 在 <code>C:\Program Files\nodejs</code> 建立一个“伪目录”（symlink：安装时你所指定的目录）。</p></li><li><p>当执行 <code>nvm use 18.16.0</code> 时：</p><ul><li><p>该目录指向真正的 Node 安装路径，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\&lt;user&gt;\AppData\Roaming\nvm\v18.16.0\</span><br></pre></td></tr></table></figure></li><li><p>修改 PATH，让系统优先使用该路径里的 <code>node.exe</code> 和 <code>npm.cmd</code>。</p></li></ul></li><li><p>切换版本仅改变 symlink 和 PATH，不需要重新安装系统级 Node。</p></li></ol><p>这种方式避免了系统 Node 干扰，并能在多个版本间快速切换。</p><h2 id="总结">总结</h2><p>nvm 是前端和 Node.js 后端开发的必备工具，尤其是在同时管理多个项目的情况下。nvm-windows 让在 Windows 上管理 Node 版本变得简单稳定。</p><p>主要能力</p><ul><li>安装多个版本</li><li>一条命令切换版本</li><li>不污染系统 PATH</li><li>每个版本拥有自己的 npm 环境</li></ul><p>适合所有需要使用 Node 的开发者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hutool工具包</title>
      <link href="/2025/12/03/Java/Hutool%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2025/12/03/Java/Hutool%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1>Hutool工具包</h1><blockquote><p><a href="https://www.hutool.cn/docs/#/">https://www.hutool.cn/docs/#/</a></p></blockquote><p>工具类的使用，写博客的优先级实在很低……除非实际项目规范要用到</p><p>（比如这样的规范：能用Hutool已有方法就用，禁止重复造轮子）</p><p>暂不知道怎么写这部分内容……项目中用到了具体的方法再来补充吧……</p><h2 id="BeanUtil">BeanUtil</h2><p><code>BeanUtil#toBean</code></p><p><code>BeanUtil#beanToMap</code></p><h2 id="DateUtil">DateUtil</h2><p><code>DateUtil#offsetHour</code></p><h2 id="StrUtil">StrUtil</h2><p><code>StrUtil#builder()...</code></p><h2 id="ListUtil">ListUtil</h2><p><code>ListUtil#of</code></p><h2 id="IdUtil">IdUtil</h2><p><code>IdUtil#getSnowflakeNextId</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 示例标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机通识内容</title>
      <link href="/2025/12/02/other/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86%E5%86%85%E5%AE%B9/"/>
      <url>/2025/12/02/other/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1>计算机通识</h1><h2 id="进制转换">进制转换</h2><ol><li>基本单位关系</li></ol><table><thead><tr><th><strong>关系</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>1 Byte (B) = 8 bit</strong></td><td><strong>位 (bit)</strong> 是计算机中最小的数据单位，一个二进制数位。<strong>字节 (Byte)</strong> 是计算机数据处理的基本单位。</td></tr></tbody></table><ol start="2"><li>容量单位关系（标准二进制前缀）</li></ol><p>计算机存储和内存容量通常使用基于 1024 的二进制前缀进行定义</p><table><thead><tr><th><strong>名称</strong></th><th><strong>缩写</strong></th><th><strong>二进制前缀 (基于 1024)</strong></th><th><strong>字节数 (B)</strong></th></tr></thead><tbody><tr><td><strong>Kilobyte</strong></td><td>KB</td><td>$1 \text{ KB} = 1024 \text{ B}$</td><td>$1024$</td></tr><tr><td><strong>Megabyte</strong></td><td>MB</td><td>$1 \text{ MB} = 1024 \text{ KB}$</td><td>$1024^2 \approx 1.05 \times 10^6$</td></tr><tr><td><strong>Gigabyte</strong></td><td>GB</td><td>$1 \text{ GB} = 1024 \text{ MB}$</td><td>$1024^3 \approx 1.07 \times 10^9$</td></tr><tr><td><strong>Terabyte</strong></td><td>TB</td><td>$1 \text{ TB} = 1024 \text{ GB}$</td><td>$1024^4 \approx 1.10 \times 10^{12}$</td></tr></tbody></table><ol start="3"><li>十进制前缀（国际单位制/硬盘厂商）</li></ol><p>硬盘厂商在计算容量时，通常使用基于 1000 的十进制前缀。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>缩写</strong></th><th><strong>十进制前缀 (基于 1000)</strong></th><th><strong>字节数 (B)</strong></th></tr></thead><tbody><tr><td><strong>Kilobyte</strong></td><td>KB</td><td>$1 \text{ KB} = 1000 \text{ B}$</td><td>$1000$</td></tr><tr><td><strong>Megabyte</strong></td><td>MB</td><td>$1 \text{ MB} = 1000 \text{ KB}$</td><td>$1000^2 = 1.00 \times 10^6$</td></tr><tr><td><strong>Gigabyte</strong></td><td>GB</td><td>$1 \text{ GB} = 1000 \text{ MB}$</td><td>$1000^3 = 1.00 \times 10^9$</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 数据类型</title>
      <link href="/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>Redis 数据类型</h1><p>所有的数据类型有：String、Hash、List、Set、Zset、BitMap、HyperLogLog、GEO、Stream</p><h2 id="String">String</h2><h3 id="介绍">介绍</h3><p>String 就是最基本的 Key-Value 类型数据，key 是唯一标识，Value 可以是字符串也可以是数字（整数、浮点数）。</p><p>底层是由 SDS（Simple Dynamic String）进行实现。</p><h3 id="常用指令">常用指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>SET key value</strong></td><td>设置指定 <code>key</code> 的值。如果 <code>key</code> 已经存在，则覆盖旧值。</td></tr><tr><td><strong>GET key</strong></td><td>获取指定 <code>key</code> 的值。如果 <code>key</code> 不存在，返回 <code>nil</code>。</td></tr><tr><td><strong>GETRANGE key start end</strong></td><td>获取指定 <code>key</code> 中字符串值的子字符串。</td></tr><tr><td><strong>SETEX key seconds value</strong></td><td>设置 <code>key</code> 的值，并同时设置过期时间（以秒为单位）。</td></tr><tr><td><strong>PSETEX key milliseconds value</strong></td><td>设置 <code>key</code> 的值，并同时设置过期时间（以毫秒为单位）。</td></tr><tr><td><strong>SETNX key value</strong></td><td>仅在 <code>key</code> 不存在时设置 <code>key</code> 的值。如果 <code>key</code> 已经存在，则不执行任何操作。</td></tr><tr><td><strong>MSET key value [key value …]</strong></td><td>批量设置多个 <code>key-value</code> 对。</td></tr><tr><td><strong>MGET key [key …]</strong></td><td>批量获取多个 <code>key</code> 的值。</td></tr><tr><td><strong>INCR key</strong></td><td>将存储在 <code>key</code> 上的数字值增 1。</td></tr><tr><td><strong>DECR key</strong></td><td>将存储在 <code>key</code> 上的数字值减 1。</td></tr><tr><td><strong>INCRBY key increment</strong></td><td>将存储在 <code>key</code> 上的数字值增加指定的 <code>increment</code>。</td></tr><tr><td><strong>DECRBY key decrement</strong></td><td>将存储在 <code>key</code> 上的数字值减少指定的 <code>decrement</code>。</td></tr><tr><td><strong>APPEND key value</strong></td><td>将 <code>value</code> 追加到 <code>key</code> 原来的值的末尾。</td></tr><tr><td><strong>STRLEN key</strong></td><td>获取存储在 <code>key</code> 上的字符串值的长度。</td></tr></tbody></table><h3 id="应用场景">应用场景</h3><blockquote><p>参考 <a href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">xiaolingcoding-Redis 数据结构-String 应用场景</a></p></blockquote><p>缓存对象</p><p>例如要存储一个uid为1、age=18、name=yukino的对象，可以使用<code>对象类:ID + JSON</code>存储整个对象，也可以使用<code>对象类:ID:属性 + 值</code>的方式存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式1：</span><br><span class="line">SET user:1 &#x27;&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;yukino&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 方式2：</span><br><span class="line">MSET user:1:age 18 user:1:name yukino</span><br><span class="line"># 等价于 SET user:1:age 18、SET user:1:name yukino</span><br></pre></td></tr></table></figure><p>常规计数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET blog:1001:likes 0</span><br><span class="line">(integer) OK</span><br><span class="line"></span><br><span class="line">INCR blog:1001:likes</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">INCR blog:1001:likes</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">GET blog:1001:likes</span><br><span class="line">&quot;2&quot;</span><br><span class="line"></span><br><span class="line">DECR blog:1001:likes</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>分布式锁</p><p>分析：加锁操作可以通过一句<code>SET lock_key unique_value NX PX 10000 </code>来实现，这个操作是原子性的。</p><p>解锁时，由于需要包含“当前当前客户端持有锁”+“删除这个锁”两个操作，所以要用Lua脚本来实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>java代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lua 脚本内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNLOCK_LUA_SCRIPT</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;if redis.call(\&quot;GET\&quot;, KEYS[1]) == ARGV[1] &quot;</span> +</span><br><span class="line">        <span class="string">&quot;then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return redis.call(\&quot;DEL\&quot;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的键名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;lock:resource_a&quot;</span>;</span><br><span class="line">    <span class="comment">// 客户端唯一标识 (例如，UUID)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNIQUE_VALUE</span> <span class="operator">=</span> <span class="string">&quot;client_uuid_123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>)) &#123;</span><br><span class="line">            <span class="comment">// --- 1. 尝试加锁 ---</span></span><br><span class="line">            <span class="comment">// EX 10 (10秒过期), NX (不存在才设置)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lockResult</span> <span class="operator">=</span> jedis.set(LOCK_KEY, UNIQUE_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(lockResult)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加锁成功。&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// --- 2. 业务逻辑处理 ---</span></span><br><span class="line">                System.out.println(<span class="string">&quot;执行受保护的业务逻辑...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// --- 3. 释放锁 ---</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// KEYS 列表：传递锁的键名</span></span><br><span class="line">                <span class="comment">// ARGV 列表：传递客户端唯一标识</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">releaseResult</span> <span class="operator">=</span> jedis.eval(</span><br><span class="line">                    UNLOCK_LUA_SCRIPT,</span><br><span class="line">                    Collections.singletonList(LOCK_KEY), </span><br><span class="line">                    Collections.singletonList(UNIQUE_VALUE)</span><br><span class="line">                );</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 结果：1 表示成功删除（解锁），0 表示失败（键不存在或值不匹配）</span></span><br><span class="line">                <span class="keyword">if</span> (releaseResult.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;解锁成功。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;解锁失败：锁已过期或不是当前客户端持有。返回结果: &quot;</span> + releaseResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加锁失败，资源被锁定。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享 Session 信息</p><p>如下，在分布式系统中，用户登陆后，登陆会话信息可能存储在服务器1上，但是下一次再来登陆，可能负载均衡算法轮询到服务器2提供服务，这时服务器2上就没有对应的Session信息，出现用户需要重新登陆的情况，而且一份相同的信息需要在不同服务器中存储。</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600927.png" alt="img" style="zoom: 75%;" /><p>而如果使用Redis来存储管理这些会话信息就十分方便，不会出现重复存储的问题、读取速度快、能够对会话设置过期时间。</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600929.png" alt="img" style="zoom: 80%;" /><h2 id="List">List</h2><h3 id="介绍-2">介绍</h3><p>List 是字符串列表，根据按照插入顺序存储和读取，可在头部或尾部快速添加或删除。</p><p>底层是由双向链表或压缩列表实现，高版本后由 quicklist 实现。</p><h3 id="常用指令-2">常用指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>LPUSH key element [element …]</strong></td><td>将一个或多个值插入到列表的 <strong>头部</strong>（最左边）。如果 <code>key</code> 不存在，创建一个空列表并执行操作。</td></tr><tr><td><strong>RPUSH key element [element …]</strong></td><td>将一个或多个值插入到列表的 <strong>尾部</strong>（最右边）。如果 <code>key</code> 不存在，创建一个空列表并执行操作。</td></tr><tr><td><strong>LPOP key</strong></td><td>移除并返回列表的 <strong>头部</strong>（最左边）元素。</td></tr><tr><td><strong>RPOP key</strong></td><td>移除并返回列表的 <strong>尾部</strong>（最右边）元素。</td></tr><tr><td><strong>BLPOP key [key …] timeout</strong></td><td><strong>阻塞式</strong> LPOP。移除并返回第一个非空列表的头部元素。如果没有元素，则阻塞直到有元素可用或达到 <code>timeout</code>。</td></tr><tr><td><strong>BRPOP key [key …] timeout</strong></td><td><strong>阻塞式</strong> RPOP。移除并返回第一个非空列表的尾部元素。如果没有元素，则阻塞直到有元素可用或达到 <code>timeout</code>。</td></tr><tr><td><strong>LLEN key</strong></td><td>获取列表的长度。</td></tr><tr><td><strong>LRANGE key start stop</strong></td><td>获取列表指定范围内的元素。索引从 0 开始。<code>start</code> 和 <code>stop</code> 可以是负数，表示从尾部开始计数（-1 是最后一个元素）。</td></tr><tr><td><strong>LINDEX key index</strong></td><td>通过索引获取列表中的元素。</td></tr><tr><td><strong>LSET key index element</strong></td><td>通过索引设置列表中指定位置的元素值。</td></tr><tr><td><strong>LINSERT key BEFORE 或 AFTER pivot value</strong></td><td>在列表中指定元素 <code>pivot</code> 的 <strong>前面</strong> 或 <strong>后面</strong> 插入新元素 <code>value</code>。</td></tr><tr><td><strong>LREM key count value</strong></td><td>根据 <code>count</code> 的值，移除列表中与 <code>value</code> 相等的元素。</td></tr><tr><td><strong>RPOPLPUSH source destination</strong></td><td>原子性地将 <code>source</code> 列表的尾部元素弹出，并将其推入 <code>destination</code> 列表的头部。常用于实现循环队列或消息处理。</td></tr></tbody></table><h3 id="应用场景-2">应用场景</h3><blockquote><p>参考 <a href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2">xiaolingcoding-Redis List 应用场景</a></p></blockquote><p>消息队列（不完全靠谱）</p><p>通过 <code>LPUSH mq message</code>添加消息，通过 <code>RPOP mq</code>读取消息。</p><p>消息保序：Redis 的 List 数据类型支持了消息的顺序性。</p><p>阻塞读取：但是使用 LPUSH 命令存储消息后，是没有通知的，所以需要一个 while(true) 循环或者间隔一定时间的轮询来消费消息，使用 while(true) 的话会让消费者不断执行RPOP，间隔一定时间轮询的话，做不到及时性。所以另外还有一个命令 BRPOP（Block RPOP）阻塞式右弹出，当消息队列没消息时，会阻塞RPOP命令，有消息进入后才进行RPOP。</p><p>重复消息处理：使用全局唯一ID，处理完一条消息后，在消费者程序端记录，若已经处理过则不再处理。</p><p>消息的可靠性：List会在一条消息读取后，这条消息就被删除了，如果此时消费者端宕机，重启后这条消息就是没被执行完且无法恢复执行的。为了解决这一问题，可以新增一条备用List，每当一条消息读取后，在备用List中进行存储。</p><h2 id="Hash">Hash</h2><h3 id="介绍-3">介绍</h3><p>Hash 是一个键值对（key-value）集合，其中 value 存储类似于：<code>value = [&#123;field1,value1&#125;,&#123;field2,value2&#125;,...&#123;fieldN,valueN&#125;]</code>，所以 Hash 特别适合存储对象类型数据。</p><p>底层是由压缩列表或哈希表实现</p><h3 id="常用指令-3">常用指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>HSET key field value [field value …]</strong></td><td>将哈希表 <code>key</code> 中的一个或多个 <code>field-value</code> 对设置进去。如果 <code>key</code> 不存在，将创建一个新的哈希表。</td></tr><tr><td><strong>HGET key field</strong></td><td>获取存储在哈希表 <code>key</code> 中指定 <code>field</code> 的值。</td></tr><tr><td><strong>HMSET key field value [field value …]</strong></td><td><strong>（已弃用，推荐使用 HSET）</strong> 批量设置哈希表中的多个 <code>field-value</code> 对。</td></tr><tr><td><strong>HMGET key field [field …]</strong></td><td>批量获取哈希表 <code>key</code> 中一个或多个 <code>field</code> 的值。</td></tr><tr><td><strong>HGETALL key</strong></td><td>获取哈希表 <code>key</code> 中所有的 <code>field</code> 和 <code>value</code>。</td></tr><tr><td><strong>HKEYS key</strong></td><td>获取哈希表 <code>key</code> 中所有域（field）。</td></tr><tr><td><strong>HVALS key</strong></td><td>获取哈希表 <code>key</code> 中所有值（value）。</td></tr><tr><td><strong>HDEL key field [field …]</strong></td><td>删除哈希表 <code>key</code> 中的一个或多个指定域（field）。</td></tr><tr><td><strong>HEXISTS key field</strong></td><td>查看哈希表 <code>key</code> 中指定域 <code>field</code> 是否存在。</td></tr><tr><td><strong>HLEN key</strong></td><td>获取哈希表 <code>key</code> 中域（field）的数量。</td></tr><tr><td><strong>HINCRBY key field increment</strong></td><td>为哈希表 <code>key</code> 中指定域 <code>field</code> 的整数值增加指定的 <code>increment</code>。</td></tr><tr><td><strong>HINCRBYFLOAT key field increment</strong></td><td>为哈希表 <code>key</code> 中指定域 <code>field</code> 的浮点数值增加指定的 <code>increment</code>。</td></tr><tr><td><strong>HSETNX key field value</strong></td><td>仅当哈希表 <code>key</code> 中不存在指定域 <code>field</code> 时，才设置该域的值。</td></tr><tr><td><strong>HSCAN key cursor [MATCH pattern] [COUNT count]</strong></td><td>迭代哈希表中的键值对，用于处理大规模数据，避免阻塞。</td></tr></tbody></table><h3 id="应用场景-3">应用场景</h3><blockquote><p>参考<a href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3">xiaolingcoding-Redis Hash应用场景</a></p></blockquote><p>缓存对象，例如要存储一个uid为1的对象，其age=18，name=yukino</p><p>可以如下存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET uid:1 age 18 name yukino</span><br></pre></td></tr></table></figure><p>购物车场景（userId为key、productId为field、productNum为value）（一个购物车里可以有多件商品，不同商品可以选择不同数量）</p><h2 id="Set">Set</h2><h3 id="介绍-4">介绍</h3><p>Set 是无序唯一键值对集合，支持集合的增删改查，还支持交集、并集、差集操作。</p><p>底层是由哈希表或整数集合实现。</p><h3 id="常用指令-4">常用指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>SADD key member [member …]</strong></td><td>将一个或多个 <code>member</code> 元素添加到集合 <code>key</code> 中。重复元素将被忽略。</td></tr><tr><td><strong>SMEMBERS key</strong></td><td>返回集合 <code>key</code> 中的所有成员。</td></tr><tr><td><strong>SISMEMBER key member</strong></td><td>判断 <code>member</code> 元素是否是集合 <code>key</code> 的成员。</td></tr><tr><td><strong>SCARD key</strong></td><td>获取集合 <code>key</code> 的成员数量。</td></tr><tr><td><strong>SREM key member [member …]</strong></td><td>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素。</td></tr><tr><td><strong>SPOP key [count]</strong></td><td>随机移除并返回集合中的一个或多个元素。</td></tr><tr><td><strong>SRANDMEMBER key [count]</strong></td><td>随机获取集合中的一个或多个元素，但不移除。</td></tr><tr><td><strong>SMOVE source destination member</strong></td><td>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</td></tr><tr><td><strong>SINTER key [key …]</strong></td><td>返回给定所有集合的<strong>交集</strong>（Intersection）成员。</td></tr><tr><td><strong>SUNION key [key …]</strong></td><td>返回给定所有集合的<strong>并集</strong>（Union）成员。</td></tr><tr><td><strong>SDIFF key [key …]</strong></td><td>返回第一个集合与后面所有集合的<strong>差集</strong>（Difference）成员。</td></tr><tr><td><strong>SINTERSTORE destination key [key …]</strong></td><td>将给定所有集合的交集存储到 <code>destination</code> 集合中。</td></tr><tr><td><strong>SUNIONSTORE destination key [key …]</strong></td><td>将给定所有集合的并集存储到 <code>destination</code> 集合中。</td></tr><tr><td><strong>SDIFFSTORE destination key [key …]</strong></td><td>将给定所有集合的差集存储到 <code>destination</code> 集合中。</td></tr><tr><td><strong>SSCAN key cursor [MATCH pattern] [COUNT count]</strong></td><td>迭代集合中的元素，用于处理大规模数据，避免阻塞。</td></tr></tbody></table><h3 id="应用场景-4">应用场景</h3><p>Set的特性在于去重、支持交并补，针对这一特性，可以去发现他的场景：</p><p><strong>场景1：点赞/喜欢/收藏场景</strong>——因为一个用户不能给同一个文章多次点赞，使用Set可以达到很好的去重效果，当然最大的优势是快速判断“某个用户是否给某篇文章点赞过”。</p><blockquote><p>粗略计算，100万点赞仅需50MB。但是1000万点赞就要500MB，10亿约46.56GB！</p><p>所以如果单纯为了统计“计数”，为什么不使用String类型或者HyperLogLog呢？使用Set的目的还是因为能知道每篇文章具体的“点赞用户”</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 用户1对文章1点赞</span><br><span class="line">SADD blog:1 user:1</span><br><span class="line"># 用户2对文章1点赞</span><br><span class="line">SADD blog:1 user:2</span><br><span class="line"></span><br><span class="line"># 用户1取消了对文章1的点赞</span><br><span class="line">SREM blog:1 user:1</span><br><span class="line"></span><br><span class="line"># 获取文章1所有点赞的用户</span><br><span class="line">SMEMBERS blog:1</span><br><span class="line"></span><br><span class="line"># 获取文章1点赞数量</span><br><span class="line">SCARD blog:1</span><br><span class="line"></span><br><span class="line"># 判断用户1是否给文章1点赞了（O(1)时间复杂度）</span><br><span class="line">SISMEMBER blog:1 user:1</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>SISMEMBER blog:1 user:1</code>是$O(1)$时间复杂度的，不要弄混淆了……不要和Redis本身是key-value键值对存储类型数据库概念混淆……blog:1只是用于找到这个“value”，这个“value”是Set集合类型的，集合类型查找、判断元素就是$O(1)$（因为底层是（数据量小时）压缩列表或哈希表实现）</p></blockquote><p><strong>场景2：共同关注</strong></p><p>就是利用Set支持“交并补”的操作，可以查询两个用户的共同关注，可以用于好友推荐、相关内容推荐，或者像是微信公众号展示“N个朋友关注”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 用户1关注了1、3、5、7这些公众号（id）</span><br><span class="line">SADD user:1 1 3 5 7</span><br><span class="line"></span><br><span class="line"># 用户2关注了1、2、3这些公众号（id）</span><br><span class="line">SADD user:2 1 2 3</span><br><span class="line"></span><br><span class="line"># 验证某个公众号是否是共同关注（查询两次）</span><br><span class="line">SISMEMBER user:1 5</span><br><span class="line">SISMEMBER user:2 5</span><br><span class="line"></span><br><span class="line"># 查询两个用户的共同关注</span><br><span class="line">SINTER user:1 user:2 </span><br><span class="line"></span><br><span class="line"># 给用户2推荐新的公众号（用户2没关注的、但是用户1关注的：）</span><br><span class="line">SDIFF user:1 user:2</span><br></pre></td></tr></table></figure><p><strong>场景3：抽奖活动</strong></p><p>首先每个人肯定是唯一个体，那就把所有人（如果这个基数很大，可以在MySQL查询用户时就做一次“随机抽取”，然后再从这部分已经缩减的数据范围再做抽奖【但是还是要让算法随机】）都放入集合Set。然后要分情况，如果一个人可以多次获奖，那么抽取完后不用SPOP，如果一个人只能中奖1次，就需要SPOP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 抽出1个特等奖</span><br><span class="line">SRANDMEMBER lucky 1</span><br><span class="line"></span><br><span class="line"># 抽出5个二等奖</span><br><span class="line">SRANDMEMBER lucky 5</span><br><span class="line"></span><br><span class="line"># 如果不允许重复中奖：</span><br><span class="line">SPOP lucky 1</span><br><span class="line">SPOP lucky 5</span><br></pre></td></tr></table></figure><h2 id="Zset">Zset</h2><h3 id="介绍-5">介绍</h3><p>Zset，即Sorted Set，有序集合，相比于Set数据类型多一个用于排序的属性score，这个score属性必须是数字类型（支持整数、浮点数、科学计数法）</p><p>底层使用压缩列表或者跳表实现。</p><h3 id="常用指令-5">常用指令</h3><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>ZADD key score member [score member …]</strong></td><td>向有序集合 <code>key</code> 中添加一个或多个成员及其分数 (<code>score</code>)。如果成员已存在，则更新其分数。</td></tr><tr><td><strong>ZRANGE key start stop [WITHSCORES]</strong></td><td>返回有序集合 <code>key</code> 中，索引在 <code>start</code> 和 <code>stop</code> 之间（从小到大排序）的成员。可选择返回分数。</td></tr><tr><td><strong>ZREVRANGE key start stop [WITHSCORES]</strong></td><td>返回有序集合 <code>key</code> 中，索引在 <code>start</code> 和 <code>stop</code> 之间（从大到小排序）的成员。可选择返回分数。</td></tr><tr><td><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></td><td>返回分数在 <code>min</code> 和 <code>max</code> 之间（从小到大排序）的成员。</td></tr><tr><td><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></td><td>返回分数在 <code>max</code> 和 <code>min</code> 之间（从大到小排序）的成员。</td></tr><tr><td><strong>ZRANGEBYLEX key min max [LIMIT offset count]</strong></td><td><strong>（已弃用，推荐使用 ZRANGE）</strong> 返回有序集合中，成员的字典序在 <code>min</code> 和 <code>max</code> 之间的元素。要求所有分数相同。</td></tr><tr><td><strong>ZSCORE key member</strong></td><td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的分数。</td></tr><tr><td><strong>ZINCRBY key increment member</strong></td><td>为有序集合 <code>key</code> 中 <code>member</code> 成员的分数加上指定的 <code>increment</code> 值。常用于排行榜分数更新。</td></tr><tr><td><strong>ZCARD key</strong></td><td>获取有序集合 <code>key</code> 的成员数量。</td></tr><tr><td><strong>ZCOUNT key min max</strong></td><td>统计有序集合 <code>key</code> 中分数在 <code>min</code> 和 <code>max</code> 之间的成员数量。</td></tr><tr><td><strong>ZRANK key member</strong></td><td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的排名（从小到大排序，从 0 开始）。</td></tr><tr><td><strong>ZREVRANK key member</strong></td><td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的倒序排名（从大到小排序，从 0 开始）。</td></tr><tr><td><strong>ZREM key member [member …]</strong></td><td>移除有序集合 <code>key</code> 中的一个或多个成员。</td></tr><tr><td><strong>ZREMRANGEBYRANK key start stop</strong></td><td>移除有序集合中，指定排名范围内的所有成员。</td></tr><tr><td><strong>ZREMRANGEBYSCORE key min max</strong></td><td>移除有序集合中，指定分数范围内的所有成员。</td></tr><tr><td><strong>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></td><td>计算多个有序集合的并集，并将结果存储在 <code>destination</code> 集合。</td></tr><tr><td><strong>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</strong></td><td>计算多个有序集合的交集，并将结果存储在 <code>destination</code> 集合。</td></tr><tr><td><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></td><td>迭代有序集合中的元素，用于处理大规模数据，避免阻塞。</td></tr></tbody></table><h3 id="应用场景-5">应用场景</h3><p>Zset，即Sorted Set，有序的集合元素，非常适合哪些按照某一规则排序的元素。适合排行榜、最新列表这类需要<strong>频繁更新</strong>的场景。</p><p><strong>场景1：排行榜</strong></p><p>设置某个ranking的Zset集合（此处为<code>user:avidbjm:ranking</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ps：ZADD key score member [score member ...]</span><br><span class="line"># 翻译：用户avidbjm的blog:1的score值为100（这个score可以是“点赞数”或者“综合分数值”）</span><br><span class="line">ZADD user:avidbjm:ranking 100 blog:1</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:2的点赞数为50</span><br><span class="line">ZADD user:avidbjm:ranking 50 blog:2</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:3的点赞数为200</span><br><span class="line">ZADD user:avidbjm:ranking 200 blog:3</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:4的点赞数为400</span><br><span class="line">ZADD user:avidbjm:ranking 400 blog:4</span><br></pre></td></tr></table></figure><p>对某一个具体内容进行加分or减分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 给user:avidbjm:ranking排行榜中的blog:2增加1分</span><br><span class="line">ZINCRBY user:avidbjm:ranking 1 blog:2</span><br><span class="line"></span><br><span class="line"># 给user:avidbjm:ranking排行榜中的blog:3减少2分</span><br><span class="line">ZINCRBY user:avidbjm:ranking -2 blog:3</span><br></pre></td></tr></table></figure><p>查看排行榜中某个内容的分数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ZSCORE key member</span><br><span class="line"># 查看这个排行榜的blog:3的分数值</span><br><span class="line">ZSCORE user:avidbjm:ranking blog:3</span><br></pre></td></tr></table></figure><p>查看排行榜前三的内容</p><blockquote><p>具体要看怎么定义“排名”，有的排名是score越小越靠前，有的是score越大越靠前，要根据需求来选择使用<code>ZRANGE key start stop [WITHSCORES]</code>或<code>ZREVRANGE key start stop [WITHSCORES]</code>，前者正序，后者逆序</p><blockquote><p>Zset是按照score从小到大顺序存储的</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出点赞最多的前三名（所以是ZREVRANGE）（WITHSCORES是附带输出score）</span><br><span class="line">ZREVRANGE user:avidbjm:ranking 0 2 WITHSCORES</span><br><span class="line"></span><br><span class="line"># 输出点赞最少的四名（示例不带WITHSCORES）</span><br><span class="line">ZRANGE user:avidbjm:ranking 0 3</span><br></pre></td></tr></table></figure><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600930.png" alt="image-20251202225502047" style="zoom: 90%;" /><p><strong>场景2：电话、姓名排序</strong></p><p>这个场景的话是因为可以使用<code>ZRANGEBYLEX</code>和<code>ZREVRANGEBYLEX</code>指令来获取某一个特定区间的元素</p><blockquote><p>注意：使用这两个命令时，元素的score必须相同，否则会不准确。</p><p>但是<code>ZRANGEBYLEX </code>命令已经弃用！</p></blockquote><p>电话排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZADD phones_by_lex 0 &quot;13912345678&quot; 0 &quot;13800001111&quot; 0 &quot;18698765432&quot; 0 &quot;15011112222&quot; 0 &quot;13900000001&quot; 0 &quot;18800000000&quot;</span><br><span class="line"></span><br><span class="line"># 获取所有电话号码</span><br><span class="line">ZRANGE phones_by_lex 0 -1</span><br><span class="line"># 获取所有电话号码（另一种写法）</span><br><span class="line">ZRANGEBYLEX phones_by_lex - +</span><br><span class="line"></span><br><span class="line"># 查询139到140号段的号码（左闭右开）</span><br><span class="line">ZRANGEBYLEX phones_by_lex &quot;[139&quot; &quot;(140&quot;</span><br></pre></td></tr></table></figure><p>姓名排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD names_by_lex 0 &quot;Adam&quot; 0 &quot;Bob&quot; 0 &quot;Alice&quot; 0 &quot;Bernard&quot; 0 &quot;Charlie&quot; 0 &quot;David&quot; 0 &quot;Brenda&quot;</span><br><span class="line"></span><br><span class="line"># 查询字母A开头的名字（不包含B）</span><br><span class="line">ZRANGEBYLEX names_by_lex &quot;[A&quot; &quot;(B&quot;</span><br></pre></td></tr></table></figure><h2 id="BitMap">BitMap</h2><h3 id="介绍-6">介绍</h3><p>BitMap，即位图，是一连串的二进制数组（0、1），因为可以通过位移量（offset）定位元素，所以查询某个元素状态的时间复杂度为$O(1)$。</p><blockquote><p>BitMap 通过将数据元素 ID 直接映射到字节数组的索引（$I = \lfloor N / 8 \rfloor$）和字节内位移量（$P = N \pmod 8$），实现了极高的查找效率。由于定位一个元素状态仅涉及<strong>固定的数组寻址</strong>和<strong>基础的位运算</strong>，其操作时间独立于数据总量，因此时间复杂度为<strong>常数时间 $O(1)$</strong>，这使其成为处理大规模布尔状态（如用户签到、ID 存在性）的理想数据结构。</p></blockquote><h3 id="常用指令-6">常用指令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td><code>SETBIT key offset value</code></td><td>设置 BitMap 中指定偏移量（<code>offset</code>）上的位的值（<code>value</code>，必须是 0 或 1）。如果键不存在，它将自动创建一个足够大的 BitMap。</td><td>$O(1)$</td></tr><tr><td><code>GETBIT key offset</code></td><td>获取 BitMap 中指定偏移量（<code>offset</code>）上的位的值（0 或 1）。</td><td>$O(1)$</td></tr><tr><td><code>BITCOUNT key [start end]</code></td><td>统计 BitMap 中设置为 1 的位的数量。可以指定字节范围（<code>start</code> 和 <code>end</code>，均为字节偏移量）。</td><td>$O(N)$ ( $N$ 是被检查的字节数)</td></tr><tr><td><code>BITOP operation destkey key [key ...]</code></td><td>对一个或多个 BitMap 执行位操作（<code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>NOT</code>），并将结果存储到目标键（<code>destkey</code>）中。</td><td>$O(N)$ ( $N$ 是操作的最长键的长度)</td></tr><tr><td><code>BITPOS key bit [start end]</code></td><td>查找 BitMap 中第一个值为 <code>bit</code> (0 或 1) 的位的位置（偏移量）。可以指定字节范围。</td><td>$O(N)$ ( $N$ 是被检查的字节数)</td></tr><tr><td><code>STRLEN key</code></td><td>获取存储在 BitMap 中的字符串值的长度（字节数）。间接反映了 BitMap 的大小。</td><td>$O(1)$</td></tr><tr><td><code>GET key</code></td><td>获取存储 BitMap 的底层字符串值。</td><td>$O(N)$ ( $N$ 是字符串的长度)</td></tr></tbody></table><h3 id="应用场景-6">应用场景</h3><p>BitMap非常适合<strong>二值存储</strong>的场景（true or false），可以做到用少量内存空间存储大量简单状态信息，例如签到统计、判断用户登陆状态、连续打卡用户数量。</p><p><strong>场景1：签到统计</strong></p><p>比如需要统计一个用户165天的签到情况，只需要365bit就行，那么存储百万用户一年的登陆情况——$1000000 \times 365 \div 8 \div 1024 \div 1024 \approx 43.5MB$，非常得节省内容。更别说可以设置过期时间进行删除操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 语法：SETBIT key offset value（value只能为0或1）</span><br><span class="line"></span><br><span class="line"># ps：uid:sign:1:202604的语义是“uid为1的用户、2026年04月”</span><br><span class="line"></span><br><span class="line"># 设置某个用户某天的签到状态（表示2026-04-16这天签到了）</span><br><span class="line">SETBIT uid:sign:1:202604 16 1</span><br><span class="line"></span><br><span class="line"># 判断用户是否在2026-04-16这天进行签到</span><br><span class="line">GETBIT uid:sign:1:202604 16</span><br><span class="line"></span><br><span class="line"># 统计用户在2026-4月的签到天数（统计1的个数）</span><br><span class="line">BITCOUNT uid:sign:1:202604</span><br><span class="line"></span><br><span class="line"># 计算用户在2026-4月的首次打卡日（因为BITPOS默认扫描整个位图，返回第一个为1的offset）</span><br><span class="line"># 由于offset从0开始，要+1</span><br><span class="line">BITPOS uid:sign:1:202604 1</span><br></pre></td></tr></table></figure><p><strong>场景2：判断用户登陆状态</strong></p><p>由于一个用户只有登录、登出两种状态，所以用1位就能记录。那么粗略计算1亿用户大约12MB空间就可以记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># uid为10001的用户已登录</span><br><span class="line">SETBIT login_status 10001 1</span><br><span class="line"></span><br><span class="line"># 判断uid为10001的用户是否登录</span><br><span class="line">GETBIT login_status 10001</span><br><span class="line"></span><br><span class="line"># uid为10001的用户已下线</span><br><span class="line">SETBIT login_status 10001 0</span><br></pre></td></tr></table></figure><p><strong>场景3：连续打卡用户数量</strong></p><p>假设要计算连续3天打卡用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对三天的bitmap进行与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line"></span><br><span class="line"># 统计bit位=1的个数（就是连续三天打卡的用户数量）</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure><p>前面已知，1亿用户的登陆状态也仅需约12MB，那么7天不到100MB，1个月不到500MB。</p><p>不过最好设置定时删除的时间，比如每周或每月清空一次，记录到数据库。</p><h2 id="HyperLogLog">HyperLogLog</h2><h3 id="介绍-7">介绍</h3><p>HyperLogLog，用于大数计数，提供了一种不完全精确的<strong>去重计数</strong>，但是可以保证输入元素数量很多时，能保持几乎不变的内存空间。</p><p>在 Redis 里，每个 HLL 键的内存开销大约是 <strong>12 KB</strong>，但是能存储$2^{64}$个不同元素的基数，它的标准误差 (Standard Error) 大约在 <strong>0.81%</strong> 左右。这意味着它提供的是<strong>近似值</strong>，而不是精确值。</p><h3 id="常用指令-7">常用指令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td><code>PFADD key element [element ...]</code></td><td>将一个或多个元素添加到 HyperLogLog 结构中。添加操作仅用于<strong>估计</strong>集合的基数（不重复元素的数量）。</td><td>$O(1)$</td></tr><tr><td><code>PFCOUNT key [key ...]</code></td><td>返回给定 HyperLogLog 结构的<strong>估计基数</strong>。可以接受多个键，返回这些 HyperLogLog <strong>并集</strong>的估计基数。</td><td>$O(N)$ ( $N$ 是 HyperLogLog 的数量)</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td><td>将一个或多个 HyperLogLog 合并（Merge）到目标 HyperLogLog（<code>destkey</code>）中。目标键将存储所有源键中所有元素的<strong>并集</strong>的基数估计信息。</td><td>$O(N)$ ( $N$ 是被合并的 HyperLogLog 的数量)</td></tr></tbody></table><h3 id="应用场景-7">应用场景</h3><p><strong>独立访客 (UV) 统计</strong></p><p>统计网站、页面或应用程序在特定时间段内访问的用户数量，这是 HLL 最经典的应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PFADD page:uv:20251209 user_id_1 user_id_2</span><br><span class="line"></span><br><span class="line">PFCOUNT page:uv:20251209</span><br></pre></td></tr></table></figure><p><strong>多集合并集基数</strong></p><p>统计多个相关集合（例如，多个页面的 UV）的<strong>总去重基数</strong>。</p><ul><li>page:uv:mon: 源键 1，存储周一页面的独立访客（UV）统计数据。</li><li>page:uv:tue: 源键 2，存储周二页面的独立访客（UV）统计数据。</li><li>total:uv:week: 目标键，存储合并后的 HyperLogLog 数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE total:uv:week page:uv:mon page:uv:tue</span><br><span class="line"></span><br><span class="line">PFCOUNT total:uv:week</span><br></pre></td></tr></table></figure><h2 id="GEO">GEO</h2><h3 id="介绍-8">介绍</h3><p>Redis GEO (地理空间索引) 命令用于存储、查询和计算地理坐标点（经度/纬度）的数据，底层基于 ZSet 实现。</p><h3 id="常用指令-8">常用指令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></td><td>将一个或多个地理空间信息（经度、纬度、成员名称）添加到指定的键中。</td><td>$O(\log N)$ ( $N$ 是元素数量)</td></tr><tr><td><code>GEOPOS key member [member ...]</code></td><td>从指定的键中获取一个或多个成员的<strong>经度和纬度</strong>坐标。</td><td>$O(M)$ ( $M$ 是查询的成员数量)</td></tr><tr><td><code>GEODIST key member1 member2 [unit]</code></td><td>计算两个成员之间（在存储的键中）的<strong>距离</strong>。<code>unit</code> 可选：<code>m</code> (米)、<code>km</code> (千米)、<code>ft</code> (英尺)、<code>mi</code> (英里)。</td><td>$O(1)$</td></tr><tr><td><code>GEOHASH key member [member ...]</code></td><td>返回一个或多个成员对应的 <strong>Geohash 字符串</strong>。Geohash 是将二维经纬度数据压缩成一维字符串的方法。</td><td>$O(M)$ ( $M$ 是查询的成员数量)</td></tr><tr><td><code>GEORADIUS key longitude latitude radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASCDESC]</code></td><td>以给定经纬度为中心，查找指定半径内（<code>radius unit</code>）的所有成员。</td><td>$$O(C + \log N)$$</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASCDESC]</code></td><td>以给定<strong>成员</strong>的位置为中心，查找指定半径内（<code>radius unit</code>）的所有其他成员。</td><td>$$O(C + \log N)$$</td></tr></tbody></table><blockquote><p>关于 GEORADIUS  和 GEORADIUSBYMEMBER</p><p><strong>$N$</strong>：是 GEO 键中存储的<strong>总元素数量</strong>（地理位置点的总数）。</p><p><strong>$C$</strong>：是命令实际<strong>返回的元素数量</strong>（在指定半径范围内的成员数量）。</p></blockquote><h3 id="应用场景-8">应用场景</h3><p>Redis GEO 主要用于处理地理空间位置信息，其核心优势在于能够高效地进行<strong>位置存储、距离计算</strong>和<strong>范围搜索</strong>。</p><table><thead><tr><th><strong>场景</strong></th><th><strong>描述</strong></th><th><strong>Redis 命令示例</strong></th></tr></thead><tbody><tr><td><strong>附近的人/地点搜索</strong></td><td>查找以用户当前位置为中心，在特定半径范围内的所有兴趣点（POI）或用户。这是 GEO 最常见的应用。</td><td><strong>添加位置：</strong> <code>GEOADD shops 116.3 39.9 &quot;Starbucks&quot;</code> <br/><strong>查询附近：</strong> <code>GEORADIUS shops 116.3 39.9 5 km WITHDIST</code></td></tr><tr><td><strong>O2O/LBS 服务</strong></td><td>为外卖、打车或零售服务分配最近的骑手/车辆/门店。例如，查找距离订单地址最近的 3 个外卖骑手。</td><td><strong>查询附近（按数量限制）：</strong> <code>GEORADIUS drivers 120.5 30.1 10 km COUNT 3 ASC</code></td></tr><tr><td><strong>距离计算与排序</strong></td><td>计算两个已知地点或用户之间的直线距离，用于路径规划辅助或收费计算。</td><td><strong>计算距离：</strong> <code>GEODIST places &quot;Shanghai Tower&quot; &quot;Oriental Pearl Tower&quot; km</code></td></tr><tr><td><strong>区域边界判定</strong></td><td>通过 <code>GEORADIUS</code> 或 <code>GEORADIUSBYMEMBER</code> 确定某个点是否位于特定服务区域或城市半径内。</td><td><strong>基于成员查询：</strong> <code>GEORADIUSBYMEMBER store_locations &quot;MainStore&quot; 50 km</code></td></tr><tr><td><strong>地图点位展示</strong></td><td>在前端地图上展示大量点位前，可以通过 <code>GEOPOS</code> 快速获取成员的经纬度坐标。</td><td><strong>获取坐标：</strong> <code>GEOPOS users &quot;userA&quot; &quot;userB&quot;</code></td></tr><tr><td><strong>Geohash 编码/解码</strong></td><td>快速获取或存储 Geohash 编码，用于数据传输或数据库索引（尽管 Redis GEO 自动处理了底层编码）。</td><td><strong>获取 Geohash：</strong> <code>GEOHASH places &quot;Eiffel Tower&quot;</code></td></tr></tbody></table><h2 id="Stream">Stream</h2><h3 id="介绍-9">介绍</h3><p>Redis Stream 是一个强大的持久化消息队列，支持多消费者组（Consumer Group）和历史消息回溯。</p><h3 id="常用指令-9">常用指令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td><code>XADD key ID field value [field value ...]</code></td><td>向 Stream 中添加新的消息（条目）。<code>ID</code> 通常使用 <code>*</code> 自动生成，格式为 <code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;</code>。</td><td>$O(1)$</td></tr><tr><td><code>XLEN key</code></td><td>返回 Stream 中包含的消息（条目）数量。</td><td>$O(1)$</td></tr><tr><td><code>XRANGE key start end [COUNT count]</code></td><td>获取 Stream 中指定 ID 范围内的消息列表。<code>start</code> 和 <code>end</code> 可以是 ID 或特殊字符（如 <code>-</code> 表示最小 ID，<code>+</code> 表示最大 ID）。</td><td>$O(N)$ ( $N$ 是返回的消息数量)</td></tr><tr><td><code>XREVRANGE key end start [COUNT count]</code></td><td>与 <code>XRANGE</code> 相同，但返回的消息列表是<strong>逆序</strong>的（从 <code>end</code> 到 <code>start</code>）。</td><td>$O(N)$ ( $N$ 是返回的消息数量)</td></tr><tr><td><code>XTRIM key MAXLEN [~] count</code></td><td>限制 Stream 的最大长度，移除最旧的消息。<code>~</code> 标志表示近似修剪，以提高效率。</td><td>$O(1)$ (当消息不多时)</td></tr><tr><td><code>XGROUP CREATE key groupname ID [MKSTREAM] [ENTRIESREDIS] [LIMIT limit]</code></td><td><strong>创建消费者组</strong>。<code>ID</code> 指定消费者组从哪个 ID 开始消费（通常用 <code>$</code> 表示从现在开始的新消息，或 <code>0</code> 表示从头开始）。<code>MKSTREAM</code> 可用于在 Stream 不存在时自动创建。</td><td>$O(1)$</td></tr><tr><td><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td><td><strong>从 Stream 中读取</strong>消息。可以指定读取数量、阻塞时间。可以从多个 Stream 读取，并为每个 Stream 指定起始 ID。</td><td>$O(N)$ ( $N$ 是返回的消息数量)</td></tr><tr><td><code>XREADGROUP GROUP groupname consumername [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td><td><strong>从消费者组中读取</strong>消息。读取未被当前消费者组其他消费者处理的消息。<code>ID</code> 通常为 <code>&gt;</code>，表示读取未传递给当前消费者的下一条消息。</td><td>$O(N)$ ( $N$ 是返回的消息数量)</td></tr><tr><td><code>XACK key groupname ID [ID ...]</code></td><td><strong>确认 (Acknowledge)</strong> 指定 ID 的消息已被消费者成功处理。消息将从消费者的<strong>未处理消息列表 (PEL)</strong> 中移除。</td><td>$O(1)$</td></tr><tr><td><code>XPENDING key groupname [IDLE min-idle-time] start end count [consumername]</code></td><td>获取<strong>待处理消息列表 (PEL)</strong> 的摘要信息或详细列表。PEL 包含已传递但未被确认的消息。</td><td>$O(log N)$ ( $N$ 是 PEL 中的消息数量)</td></tr><tr><td><code>XCLAIM key groupname consumername min-idle-time ID [ID ...]</code></td><td><strong>认领 (Claim)</strong> 长期处于待处理状态的消息，将其所有权转给新的消费者。用于处理失败的消费者或死信消息。</td><td>$O(M)$ ( $M$ 是被认领的消息数量)</td></tr><tr><td><code>XDEL key ID [ID ...]</code></td><td>从 Stream 中<strong>永久删除</strong>指定的条目。</td><td>$O(1)$</td></tr></tbody></table><h3 id="应用场景-9">应用场景</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>描述</strong></th><th><strong>Redis 命令示例</strong></th></tr></thead><tbody><tr><td><strong>实时日志收集/处理</strong></td><td>将应用程序产生的日志（如访问日志、错误日志）实时写入 Stream，供多个后端服务（如分析系统、监控系统）并行消费和处理。</td><td><strong>生产 (Producer)：</strong> <code>XADD log:app:* level error message &quot;DB connection failed&quot;</code> <br/><br/><strong>消费 (Consumer Group)：</strong> <code>XGROUP CREATE log:app monitor $ MKSTREAM</code> <code>XREADGROUP GROUP monitor consumer_A COUNT 10 STREAMS log:app &gt;</code></td></tr><tr><td><strong>异步任务队列</strong></td><td>用于解耦服务和削峰填谷。例如，用户下单后，将订单 ID 写入 Stream，后续的库存扣减、积分发放、邮件通知等任务由不同的消费者组异步完成。</td><td><strong>生产：</strong> <code>XADD orders:new * orderId 1001 userId 500</code> <br/><br/><strong>消费与确认：</strong> <code>XREADGROUP GROUP worker group1 COUNT 1 STREAMS orders:new &gt;</code> <code>XACK orders:new worker 1678881234000-0</code></td></tr><tr><td><strong>事件溯源 (Event Sourcing)</strong></td><td>存储系统中发生的所有状态变更事件，作为系统的单一事实来源。Stream 的不可变和可回溯特性完美契合事件溯源模型。</td><td><strong>存储事件：</strong> <code>XADD account:123 * type deposit amount 500</code> <br/><br/><strong>历史回溯：</strong> <code>XRANGE account:123 0 -1</code></td></tr><tr><td><strong>消息广播与通知</strong></td><td>用于将重要通知或配置变更广播给所有订阅者。每个订阅者可以是一个独立的消费者组，确保每个订阅者都能接收到所有消息。</td><td><strong>生产：</strong> <code>XADD configs:update * key &quot;theme&quot; value &quot;dark&quot;</code><br/><br/> <strong>多组独立消费：</strong> <code>XREADGROUP GROUP service_A consumer_A ...</code> <code>XREADGROUP GROUP service_B consumer_B ...</code></td></tr><tr><td><strong>处理失败与重试</strong></td><td>当消费者处理消息失败后，消息仍保留在 PEL (Pending Entries List) 中。Stream 提供了认领（CLAIM）机制来处理超时或失败的消息，实现故障恢复和消息重试。</td><td><strong>查看待处理：</strong> <code>XPENDING orders:new worker 0 + 10</code> <br/><br/><strong>认领消息：</strong> <code>XCLAIM orders:new worker_new 3600000 1678881234000-0</code></td></tr></tbody></table><p>Redis Stream 区别于传统消息队列和 Redis List 的主要优势在于：</p><ul><li><strong>多消费者组模型：</strong> 支持消息的负载均衡（组内消费者抢占）和消息隔离（组间独立消费）。</li><li><strong>消息可回溯：</strong> 消息是持久存储的，可以根据 ID 随时从历史位置开始读取。</li><li><strong>消息确认 (ACK)：</strong> 明确的消息确认机制和 PEL 列表确保了消息至少被成功处理一次（At-Least-Once Delivery）。</li><li><strong>高吞吐量：</strong> 底层使用 Radix Tree 和 Listpack 等数据结构，保证了高效的写入和读取性能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL分库分表</title>
      <link href="/2025/11/24/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2025/11/24/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>MySQL分库分表</h1><p>总的来说，“分库分表”是用于解决高并发下数据库的连接数不足的性能瓶颈问题、大数据量查询性能瓶颈问题。</p><p>实际上分库分表是一种解决数据库性能瓶颈的“最终手段”，非到万不得已不会使用。（在分库分表之前还有索引优化查询、增加查询缓存中间件等手段可以使用）。因为分库分表虽然能解决一部分问题，也会带来新的问题，提高了架构复杂程度，增加维护成本。</p><h2 id="分库、分表、分库分表">分库、分表、分库分表</h2><p>本质上这是有三种情况——分库不分表、分表不分库、分库又分表。</p><p>简而言之，分库是为了解决高并发下连接数不足的问题（因为单库的连接数是有限的）；分表是为了解决单表数据量过大（通常数据超过500万条，表大小超过2GB）、查询缓慢的问题。</p><blockquote><p>并发高，就分库；数据量大，就分表。</p></blockquote><p>所以具体要不要分库分表要看算不算符合上述情况。</p><h2 id="如何分库">如何分库</h2><h3 id="垂直分库">垂直分库</h3><p>即根据业务边界来分库，例如原先的电商平台将所有数据都存放到一个库中，现在可以分出——订单库、商品库、用户库等</p><h3 id="水平分库">水平分库</h3><p>将一个库分为多个相同的库，提高系统能承载的并发请求，例如订单库1、订单库2、订单库3。（尤其是双11期间大量订单）</p><h2 id="如何分表">如何分表</h2><h3 id="垂直分表">垂直分表</h3><p>将原先一张表中的许多属性分别存到不同表中，比如原先商品表里可能有很多属性，比如价格、商品名称、上架商家、库存数量等。那就可以分成两个表，一个是价格、商品名称这些基础信息存一个表，另外对于不同商家有不同的商品、对应的库存数量这些信息再存一个表。</p><h3 id="水平分表">水平分表</h3><p>水平分表是分为多个功能相同的小表。</p><h2 id="分库分表的算法">分库分表的算法</h2><h3 id="范围分片">范围分片</h3><ol><li>按时间范围分</li><li>按地域维度分</li><li>按数据大小分（比如user_id从1-1000一个表、1001-2000一个表……）</li></ol><h3 id="hash分片">hash分片</h3><blockquote><p>Sharding Key就是分表的依据。也就是用于分表的那个属性。</p></blockquote><p>简单来说就是对sharding key取模后存储到对应的表中。但是在分表的数量需要动态扩展（集群伸缩）时，简单取模哈希，存在一个问题——原先已经放入表中的数据位置，要大量的重新hash计算后移动。</p><p>改进方式：一致性哈希（简单来说一致性哈希的原理就是对$2^{31} -1$取模+虚拟节点 决定放到哪个位置，减少了集群伸缩时数据的大量移动带来的性能消耗）（关键词：环形、增加虚拟节点、顺时针距离最近）</p><h3 id="查表分片">查表分片</h3><p>就是多增一个表，要查询数据前，先查询这个表来判断所需数据在那个表。但是需要注意的是，这个新增的表数据量不能太大，否则本身也会成为性能瓶颈。（毕竟是多查了张表）</p><h2 id="分库分表架构模式">分库分表架构模式</h2><h3 id="客户端模式">客户端模式</h3><img src="https://blogs.muxueavid.top/blogs/2025/11/20251124173911070.png" alt="image-20251124153718701" style="zoom: 75%;" /><p>业务代码有侵入。</p><p>java开发中通过提供jar方式实现，例如ShardingSphere-JDBC，美团的Zebra、MTDDL，阿里的TDDL</p><h3 id="代理模式">代理模式</h3><img src="https://blogs.muxueavid.top/blogs/2025/11/20251124173911071.png" alt="image-20251124153733491" style="zoom: 85%;" /><p>业务代码无侵入，对业务方透明。</p><p>例如ShardingSphere-Proxy，阿里的MyCat，美团的Meituan Atlas，百度的Heisenberg。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从架构</title>
      <link href="/2025/11/23/MySQL/MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
      <url>/2025/11/23/MySQL/MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>MySQL主从架构</h1><p>主从架构是用于解决什么问题？</p><p>用于解决数据库性能瓶颈的。单个数据库下，能同时连接的客户端数量有限，这时候容易成为瓶颈；另外，单个MySQL服务器，如果宕机了，那么就没有应急方案，从事导致整个系统挂掉。</p><p>主从架构分为有多重类型——一主一从、一主多从（一主二从一备主）</p><p>那么就算主库此时挂了，从库也能充当主库使用。</p><p>同时，在这种架构下，能实现读写的分离，提高并发度（尤其是<strong>读多写少</strong>的场景下）。主库负责处理写请求、从库负责读请求。</p><h2 id="主从数据同步的基石——binlog、relaylog">主从数据同步的基石——binlog、relaylog</h2><p>binlog是二进制日志，用于在更新数据时写入。可以理解为里面内容就是写入MySQL的最新数据。</p><p>relaylog，叫中继日志，是从库才有的日志，正如名字一样，“中继”，也就是从主库那里复制binlog日志，或者供别的从库复制relaylog使用。relaylog就是从库用于更新数据的</p><blockquote><p>不过还要看binlog的格式，Statement格式是基于SQL实现复制（好处是日志存储空间小、弊端是NOW()等函数调用结果不一致）、Row格式是基于行信息复制（相当于复制数据、好处是数据无误坏处是存储空间大）、Mixed是混合复制（智能选择使用statement还是row）</p></blockquote><p>具体流程为——当一条写请求来后，更新了主库的binlog日志，然后主库会创建一个log dump线程，用于向从库发送bin log日志内容，从库开启同步后，会创建一个IO线程用来连接主库，请求主库的bin log，从库接收到主库发来的bin log日志后，保存在本机的relay log中。接着从库会有一个线程负责读取relay log日志内容，更新从库的数据，完成主库与从库之间数据同步。</p><h2 id="主从复制类型">主从复制类型</h2><blockquote><p>图源<a href="https://juejin.cn/post/7269953746851266620#heading-0">https://juejin.cn/post/7269953746851266620#heading-0</a></p></blockquote><p>主从复制有多种类型，本质还是同步时机的不同、同步方式的区别（指的是多源复制）。不同类型的复制都会达到数据的最终一致性，只是达到一致性的<strong>延迟</strong>有所不同。</p><p>大致的流程都一样，只是些许步骤的顺序不同。</p><img src="https://blogs.muxueavid.top/blogs/MySQL主从架构/blog-20251124150441170.webp" alt="MySQL 主从复制.png" style="zoom: 65%;" /><ol><li><p>异步复制（这是MySQL默认的复制策略）</p><img src="https://blogs.muxueavid.top/blogs/MySQL主从架构/blog-20251124150441172.webp" alt="MySQL 异步复制.png" style="zoom:95%;" /><ul><li>客户端事务提交-&gt;写binlog日志-&gt;通知log dump线程向从库发送bin log日志-&gt;返回客户端成功响应</li><li>这种方式不用等待从库更新relay log，直接返回客户端成功响应，速度最快。但是在“客户端收到成功响应”到“从库同步数据完成前”这段时间，如果客户端立马向从库发起读请求，读到的数据可能是旧数据。</li></ul></li><li><p>全同步复制</p><p><img src="https://blogs.muxueavid.top/blogs/MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/blog-20251124150441173.webp" alt="MySQL 全同步复制.png"></p><ul><li>客户端事务提交-&gt;写binlog日志-&gt;通知log dump线程向从库发送bin log日志-&gt;等待<strong>所有从库</strong>写入relay log-&gt;所有从库同步完数据-&gt;返回客户端成功响应</li><li>全同步复制需要等待所有从库同步完成才返回客户端成功响应，数据一致性最高，但是性能最差。</li></ul></li><li><p>半同步复制</p><p><img src="https://blogs.muxueavid.top/blogs/MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/blog-20251124150441174.webp" alt="MySQL 半同步复制.png"></p><ul><li>客户端事务提交-&gt;写binlog日志-&gt;通知log dump线程向从库发送bin log日志-&gt;至少有一个<strong>从库</strong>写入relay log-&gt;返回客户端成功响应</li><li>半同步复制相比于全同步复制，性能更高（因为只需要一个从库写入relay log）</li></ul></li><li><p>增强半同步复制</p><p><img src="https://blogs.muxueavid.top/blogs/MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/blog-20251124150441175.webp" alt="MySQL 增强半同步复制.png"></p><ul><li>客户端事务提交-&gt;写binlog日志-&gt;通知log dump线程向从库发送bin log日志-&gt;至少有一个<strong>从库</strong>写入relay log-&gt;主库提交存储引擎-&gt;返回客户端成功响应</li><li>增强半同步和半同步很像，但是增强半同步复制方式，会等relay log写入后，主库才会提交存储引擎（避免relay log的数据被回滚失效）</li></ul></li><li><p>多源复制</p><ul><li><p>多源复制是指一个从库的数据是从多个主库复制而来，常用语OLAP业务查询</p><blockquote><p>OLAP（Online Analytical Processing，联机分析处理）业务是一种以<strong>快速、多维、交互式分析</strong>大量历史数据为核心的数据处理模式，其主要目的是支持商业智能（BI）和决策支持系统，通过对数据进行切片、钻取、旋转等操作，帮助用户从不同角度洞察业务趋势、发现潜在规律并制定战略决策，与处理日常交易的OLTP（联机事务处理）业务形成鲜明对比。</p></blockquote></li><li><img src="https://blogs.muxueavid.top/blogs/2025/11/20251124150441176.png" alt="Drawing 8.png" style="zoom: 85%;" /></li></ul></li></ol><h2 id="主从配置实践">主从配置实践</h2><p>see 博客（如何实践配置）</p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/15%20%20MySQL%20%E5%A4%8D%E5%88%B6%EF%BC%9A%E6%9C%80%E7%AE%80%E5%8D%95%E4%B9%9F%E6%9C%80%E5%AE%B9%E6%98%93%E9%85%8D%E7%BD%AE%E5%87%BA%E9%94%99.md">https://learn.lianglianglee.com/专栏/MySQL实战宝典/15  MySQL 复制：最简单也最容易配置出错.md</a></p><h2 id="读写分离延迟问题">读写分离延迟问题</h2><p>see 博客（更好的解决读写分离延迟问题）</p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/16%20%20%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb%e8%ae%be%e8%ae%a1%ef%bc%9a%e5%a4%8d%e5%88%b6%e5%bb%b6%e8%bf%9f%ef%bc%9f%e5%85%b6%e5%ae%9e%e6%98%af%e4%bd%a0%e7%94%a8%e9%94%99%e4%ba%86.md">https://learn.lianglianglee.com/专栏/MySQL实战宝典/16  读写分离设计：复制延迟？其实是你用错了.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构</title>
      <link href="/2025/11/18/MySQL/MySQL%E6%9E%B6%E6%9E%84/"/>
      <url>/2025/11/18/MySQL/MySQL%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>MySQL架构</h1><h2 id="MySQL整体架构">MySQL整体架构</h2><p>MySQL整体架构大体分为两层——Server层和执行引擎层。</p><p>Server层负责建立连接，SQL的分析、分析和执行SQL。</p><p>执行引擎层负责存储和提取数据。</p><p><strong>从一条select语句来看各个结构作用、如何配合工作</strong>：</p><ol><li>连接器先建立连接。（比如使用<code>mysql -uroot -pxxxyyy</code>与数据库建立连接），连接器负责与客户端建立连接。</li><li>查询缓存，这里查询的是Server层中的缓存，如果之前有一模一样的SQL语句则直接返回结果（但是在Server层的缓存很鸡肋，必须要SQL语句完全一致，命中率很低，后续MySQL版本中移除了，而且在执行引擎层也有缓存，那个缓存命中率更高）</li><li>解析器解析SQL语句，也就是词法分析、语法分析。</li><li>然后是执行SQL，具体还可以细分步骤如下：<ul><li>预处理器大概判断该sql能否成功执行（比如检查要查询的表有没有）</li><li>优化器指定执行计划（有哪些索引可用、具体使用哪个索引、是否有索引覆盖、索引下推等）</li><li>执行器执行sql（也就是从执行引擎调用api查询数据）</li></ul></li></ol><h2 id="后起之秀：InnoDB存储引擎">后起之秀：InnoDB存储引擎</h2><p>相比于MyISAM，InnoDB是现在用的最多的存储引擎。</p><ul><li>它支持事务<ul><li>有redo-log保证事务的持久性，undo-log支持事务的原子性。</li><li>MyISAM没有这两个日志，所以多条语句的回滚做不到（无undo-log）</li></ul></li><li>有更小的锁粒度（行级锁）（也就有更高的并发度）<ul><li>而MyISAM只支持表锁。</li></ul></li><li>使用聚簇索引（数据和索引存储在一起）存储数据<ul><li>而MyISAM引擎的表数据和索引数据分开存储，不支持聚簇索引。</li></ul></li></ul><p>这些特性说明了InnoDB在并发场景下具有更好的读写性能。</p><h2 id="InnoDB行数据如何存储">InnoDB行数据如何存储</h2><p>首先表空间结构层次为：表-段-区-页-行。</p><p>总之知道数据行是存储在页中就行，默认每个页大小16KB，是B+树中的数据存储基本单位，也是数据从内存刷到硬盘的基本单位（页）（为了减少IO次数）。当数据量变大时，B+树中存的会从页变成区。</p><p>InnoDB行格式（算了不想写，记不起来了，估计以后也会忘，丢几篇博客在下面：）</p><p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/04-%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84">04-从一条记录说起-InnoDB记录结构</a></p><p><a href="https://xiaolincoding.com/mysql/base/row_format.htm">MySQL一行记录是怎么存储的</a></p><p><a href="https://juejin.cn/post/7160557698642083847#heading-8">InnoDB vs MyISAM</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志</title>
      <link href="/2025/11/18/MySQL/MySQL%E6%97%A5%E5%BF%97/"/>
      <url>/2025/11/18/MySQL/MySQL%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1>MySQL日志</h1><p>关键在于掌握undo-log、redo-log和bin-log的<strong>概念、作用、结构</strong>。</p><blockquote><p>自己写的博客本质还是给自己看的（更是是自己输出的过程），所以从别人博客那里复制粘贴没必要。所以日志相关的内容，我这里写的更多的是理解性的，也比较浅。更深的、系统性的见下面两篇博客：</p><p><a href="https://xiaolincoding.com/mysql/log/how_update.html">https://xiaolincoding.com/mysql/log/how_update.html</a></p><p><a href="https://juejin.cn/post/7157956679932313608">https://juejin.cn/post/7157956679932313608</a></p></blockquote><h2 id="Undo-log">Undo-log</h2><p>Undo-log，回滚日志，是用于保证事务ACID性质中<strong>原子性</strong>的日志；另外还有个作用，<strong>MVCC（多版本控制）通过Read View + Undo log日志来实现</strong>（因为回滚日志能形成记录的版本链）。</p><p>为什么说undo log保证了原子性呢？而且一条普通的更新语句也不是事务呀？其实<code>autocommit</code>参数默认开启，所以执行一条update语句也是开启事务的。其次就是如何保证原子性的——假设一个事务执行失败，由于undo log日志有旧版本的数据信息，所以事务回滚后能将数据恢复到事务执行前的样子，这就保证了事物的原子性（同时失败）。</p><p>具体来说，undo log里记录数据时会有两个隐藏列——<code>trx_id</code>，用于表示该版本数据是哪个事务修改后的，<code>roll_ptr</code>，用于指向上一个版本的数据（便于回滚或查看旧版本数据（变相支持了<strong>隔离性</strong>））。</p><h2 id="Redo-log">Redo-log</h2><p>Redo-log，重做日志，是用于保证事务ACID性质中<strong>持久性</strong>的日志。</p><p>为什么说redo log保证了持久性呢？因为InnoDB在插入一条数据时，会先将这条新数据写入到redo log中，之后后台进程再去把redo log中的脏页数据刷入硬盘。</p><p>那为什么不直接把数据写入硬盘中而是要使用redo log呢？主要是出于性能方面考虑，以及在MySQL服务宕机后有更好的恢复效果。如果是直接写入数据，那么要找到数据在硬盘中的物理地址后再写入，属于<strong>随机存储</strong>，而写入redo log就是直接在指定位置后面<strong>顺序写入</strong>，效率更高，所以写入redo log直接返回客户端“数据已成功写入”，这样的响应时间更短。（后续把真实数据写入硬盘有专门的异步线程来做）。那么在没有把redo log中的数据写入硬盘呢，MySQL服务就宕机了，也没关系，redo log已经写入了数据缓存页，那等MySQL服务恢复后就能把数据写入。（如果是redo中都没写入就宕机……那么sql就没执行成功，也返回给服务端成功的提示，所以问题不大）</p><blockquote><p>实际上InnoDB在Buffer Pool（缓冲池）中，不仅缓存了数据页、索引页，还有插入缓存页、undo页等信息。也就是有redo log的缓存（所以redo log可以选择不是每次事务提交都刷盘）——这个可以通过redo log相关参数来配置刷盘策略。</p><blockquote><p>why？每次刷盘和先放在缓存再一次刷入，前者保证数据的持久性，后者提高性能（减少IO次数），各有利弊，看实际而权衡。（默认策略是事务提交就刷盘）</p></blockquote></blockquote><p>关于redo log的结构，默认有两个日志文件，然后进行<strong>循环写</strong>。<img src="https://blogs.muxueavid.top/blogs/2025/11/20251118192326286.png" alt="img" style="zoom: 50%;" /></p><p>红色部分为空闲空间，蓝色部分为脏页数据，如果write pos指针和check point指针相遇则说明空间已满，需要刷盘。</p><h2 id="Bin-log">Bin-log</h2><p>Bin-log，二进制日志，和redo log类似，也是记录数据库表结构变化或数据变化的日志，但是Bin-log是Server层的，undo-log和redo-log是InnoDB执行引擎特有的。</p><p>bin log的作用更多是<strong>备份恢复、主从复制</strong>。而redo log是掉电等故障恢复。</p><blockquote><p>主从复制，是MySQL高可用里面的内容（现在就理解为是一种能使MySQL具有更高可用性的架构模式）。一主一从、一主多从。（读写分离……balabala）</p></blockquote><p>bin log与redo log不同的是，它是追加写，一个文件写满了就新来一个文件再写。（所以想要恢复数据库的数据还是要看bin log，而不是redo log）</p><blockquote><p>redo log更像是一种“短期内”、“小型”故障的自动恢复；但是一不小心删了整个数据库，那么redo log就无力回天了，要从本地的bin log进行数据恢复。（避免删库跑路）</p></blockquote><p>bin log日志有三种格式：Statement、Row 及 Mixed。</p><p>Statement格式：基于SQL语句的复制。</p><p>Row格式：基于行信息的复制。</p><p>Mixed格式：混合模式复制</p><h2 id="Error-log">Error-log</h2><p>error-log，错误日志，用于线上问题排查的日志。</p><h2 id="Slow-log">Slow-log</h2><p>slow-log，慢查询日志，但是默认是不开启的，而且需要自己设定一个合理的阈值（什么样才算慢查询）。</p><h2 id="General-log">General-log</h2><p>查询日志，通常在开启慢查询前前先用general log，看看压测情况下所有业务的sql执行时间怎么样，最后再对slow log设置一个稍大于平均sql执行的时间，开启慢查询日志。（线上一定要关闭general log，否则每次sql都要写入general log）</p><h2 id="Relay-log">Relay-log</h2><p>relay-log，中继日志，仅存在于主从架构的从机上。relay-log和bin-log一模一样，就是从主机复制过来的。</p><h2 id="各日志参数">各日志参数</h2><blockquote><p>见此文<a href="https://juejin.cn/post/7157956679932313608#heading-10%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%A7%A3%E9%87%8A%E3%80%82">https://juejin.cn/post/7157956679932313608#heading-10，可以看到各种日志相关的参数设置解释。</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/2025/11/17/MySQL/MySQL%E9%94%81/"/>
      <url>/2025/11/17/MySQL/MySQL%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1>MySQL锁</h1><h2 id="S锁与X锁">S锁与X锁</h2><ul><li><p>共享锁，Shared Locks，简称S锁，在事务要<strong>读取</strong>一条记录时，要先获取到记录的S锁。</p></li><li><p>独占锁，Exclusive Locks，简称X锁，在事务要<strong>修改</strong>一条记录时，要先获取到记录的X锁。</p></li></ul><p>S锁与X锁之间的兼容关系如下：</p><table><thead><tr><th>兼容性</th><th>S锁</th><th>X锁</th></tr></thead><tbody><tr><td><strong>S锁</strong></td><td>兼容</td><td>不兼容</td></tr><tr><td><strong>X锁</strong></td><td>不兼容</td><td>不兼容</td></tr></tbody></table><h2 id="多粒度锁">多粒度锁</h2><h3 id="全局锁">全局锁</h3><p>全局锁说的是数据库级别的，会对整个数据库加锁，不能再修改。（一般也不会去用）</p><h3 id="表级锁">表级锁</h3><ol><li><p>表级别S锁和X锁</p><p>若对表加了S锁，则整个表只能被读，不能被修改；若对表加了X锁，则不能被读，更不能被其他事务修改。</p></li><li><p>表级别意向锁</p><p>即IS锁和IX锁。当对记录加S锁或X锁前，会对表加上IS锁或IX锁，作用是<strong>快速判断</strong>表内有无记录加了S锁或X锁。（这样的话，在对表加S锁或X锁时，就不用去遍历表中每一条记录，看有没有行级别的S锁或X锁）</p></li><li><p>元数据锁（MDL）</p><p>元数据锁是用来一个事务中用来保护表的结构的，对表操作时会自动加上，防止当前线程对表进行CRUD时，别的线程修改了表结构。</p></li><li><p>AUTO-INC锁 或 轻量级锁</p><blockquote><p>若表中某个字段为<code>AUTO_INCREMENT</code>属性，则后续插入纪录时，可以不指定该列数据，系统自动自增，自增的原理如下（两种模式）。</p></blockquote><ul><li>一是AUTO-INC锁。AUTO-INC锁会在执行insert语句时加上，insert语句执行完后锁释放，若其他线程也想insert，则会因为获取不到AUTO-INC锁而阻塞。</li><li>二是轻量级锁。每次insert时只获取一下轻量级锁，生成本次自增的值后，立刻释放掉这个轻量级锁，不用等到整个insert语句完成。</li><li>这两种模式通过<code>innodb_autoinc_lock_mode</code>系统变量进行选择。（0：AUTO-INC锁，1：混合使用，2：轻量级锁）</li></ul></li></ol><h3 id="行级锁">行级锁</h3><ol><li><p>记录锁（Record Locks）</p><p>对单个记录加的锁，分为S锁和X锁。</p></li><li><p>间隙锁（Gap Locks）</p><p>首先明确：行级锁都是加载索引上的（InnoDB）。所以间隙锁才会有“范围”这一概念，对某个区间（<strong>左开右开区间</strong>）进行加间隙锁，防止有新记录在这个区间写入。</p><p>间隙锁的唯一作用就是为了<strong>防止幻读现象</strong>！故不区分S锁和X锁。</p></li><li><p>临键锁（Next-Key Locks）</p><p>Next-Key Locks = Record Locks + Gap Locks。是一个<strong>左开右闭区间</strong>，也区分S锁和X锁（因为记录锁区分）。</p></li><li><p>插入意向锁（Insert Intention Locks）</p><p>和间隙锁一块出现的，当某个区间加了间隙锁后，该区间的某个新数据想要插入，但无法插入，由于InnoDB是先生成锁结构再修改锁状态的，所以此时该记录会有一个等待状态的插入意向锁。（比较鸡肋的一个锁）</p><p>插入意向锁不是意向锁，他是一种特殊的间隙锁，锁的不是一个区间，而是一个点。</p></li></ol><h2 id="MySQL-InnoDB-隔离级别与锁机制">MySQL InnoDB 隔离级别与锁机制</h2><ol><li>READ UNCOMMITTED (读未提交)</li></ol><p>这是最低的隔离级别，不使用一致性读，通常用于高性能但数据准确性要求不高的场景。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>锁机制</strong></th><th><strong>目的/说明</strong></th></tr></thead><tbody><tr><td><strong>普通 <code>SELECT</code></strong></td><td><strong>不加锁</strong></td><td>直接读取数据的最新版本（包括未提交版本），不涉及 MVCC。</td></tr><tr><td><strong><code>UPDATE</code>/<code>DELETE</code></strong></td><td><strong>行级排他锁 (X Lock)</strong></td><td>必须加锁，以保证数据修改的原子性和互斥性。</td></tr></tbody></table><ol start="2"><li>READ COMMITTED (读已提交)</li></ol><p>此级别下，<code>SELECT</code> 使用 MVCC。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>锁机制</strong></th><th><strong>目的/说明</strong></th></tr></thead><tbody><tr><td><strong>普通 <code>SELECT</code></strong></td><td><strong>不加锁</strong></td><td>使用 MVCC，每次 <code>SELECT</code> 都生成新的 Read View，读取已提交版本。</td></tr><tr><td><strong><code>SELECT ... FOR UPDATE</code>/<code>FOR SHARE</code></strong></td><td><strong>行级锁</strong> (X/S Lock)</td><td>遵循标准锁规则，仅对<strong>满足条件的记录</strong>加锁。<strong>不加间隙锁。</strong></td></tr><tr><td><strong><code>UPDATE</code>/<code>DELETE</code></strong></td><td><strong>行级排他锁 (X Lock)</strong></td><td>仅对<strong>满足条件的记录</strong>加 X 锁，<strong>不加间隙锁</strong>。</td></tr></tbody></table><ol start="3"><li>REPEATABLE READ (可重复读)</li></ol><p>这是 InnoDB 的<strong>默认隔离级别</strong>。它使用 MVCC 保证读一致性，并使用 Next-Key Locks 解决幻读。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>锁机制</strong></th><th><strong>目的/说明</strong></th></tr></thead><tbody><tr><td><strong>普通 <code>SELECT</code></strong></td><td><strong>不加锁</strong></td><td>使用 MVCC，事务生命周期内使用<strong>首次生成的 Read View</strong>。</td></tr><tr><td><strong><code>SELECT ... FOR UPDATE</code>/<code>FOR SHARE</code></strong></td><td><strong>Next-Key Locks (NK 锁)</strong></td><td>这是关键！对于范围查询和非唯一索引查询，InnoDB 会加 <strong>NK 锁</strong>（间隙锁 + 记录锁）来锁定索引范围，<strong>防止幻读</strong>。</td></tr><tr><td><strong><code>UPDATE</code>/<code>DELETE</code></strong></td><td><strong>Next-Key Locks (NK 锁)</strong></td><td>对于范围查询和非唯一索引查询，加 <strong>NK 锁</strong>。对于精确主键/唯一键查询，退化为行级锁 (X Lock)。</td></tr></tbody></table><blockquote><p><strong>Next-Key Lock 机制：</strong></p><ul><li><strong>目的：</strong> 阻止其他事务在锁定的<strong>间隙</strong>中插入新记录。</li><li><strong>实现：</strong> Next-Key Lock = 间隙锁 (Gap Lock) + 记录锁 (Record Lock)。</li></ul></blockquote><ol start="4"><li>SERIALIZABLE (串行化)</li></ol><p>这是最高的隔离级别，主要依赖悲观锁。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>锁机制</strong></th><th><strong>目的/说明</strong></th></tr></thead><tbody><tr><td><strong>所有 <code>SELECT</code></strong></td><td><strong>隐式 <code>SELECT ... FOR SHARE</code></strong></td><td>所有普通读操作都被强制转换为共享锁读，对读取的行加 <strong>S 锁</strong>。</td></tr><tr><td><strong><code>UPDATE</code>/<code>DELETE</code></strong></td><td><strong>行级排他锁 (X Lock)</strong></td><td>遵循标准锁规则。</td></tr><tr><td><strong>范围查询</strong></td><td><strong>Next-Key Locks (NK 锁)</strong></td><td>和 <code>REPEATABLE READ</code> 类似，为了保证并发控制的严谨性，也会使用 NK 锁来锁定范围。</td></tr></tbody></table><h2 id="MySQL是如何加行级锁的？">MySQL是如何加行级锁的？</h2><p>分很多情况（规则性的东西，不用死记，重在理解就行）：</p><ol><li>唯一索引（主键索引）等值查询</li></ol><table><thead><tr><th><strong>场景</strong></th><th><strong>查找过程</strong></th><th><strong>施加的锁类型</strong></th><th><strong>锁模式</strong></th></tr></thead><tbody><tr><td>记录存在</td><td>定位到唯一记录</td><td><strong>行级记录锁</strong> (Record Lock)</td><td>$X$ 或 $S$</td></tr><tr><td>记录不存在</td><td>查找相邻记录，发现间隙 $(K_{i-1}, K_i)$</td><td><strong>间隙锁</strong> (Gap Lock)</td><td>$X$ 或 $S$</td></tr></tbody></table><ol start="2"><li>非唯一索引等值查询</li></ol><table><thead><tr><th><strong>场景</strong></th><th><strong>查找过程</strong></th><th><strong>施加的锁类型</strong></th><th><strong>锁模式</strong></th></tr></thead><tbody><tr><td>记录存在</td><td>找到所有满足条件的记录</td><td>1. 对所有匹配记录加 <strong>行级记录锁</strong> (Record Lock)。2. 对该<strong>记录的间隙</strong>加 <strong>Next-Key Lock</strong> (NK 锁)。</td><td>$X$ 或 $S$</td></tr><tr><td>记录不存在</td><td>查找相邻记录，发现间隙 $(K_{i-1}, K_i)$</td><td><strong>间隙锁</strong> (Gap Lock)</td><td>$X$ 或 $S$</td></tr></tbody></table><ol start="3"><li>非唯一索引范围查询</li></ol><p>（适用于 <code>WHERE id &gt; 10</code> 或 <code>WHERE id BETWEEN 5 AND 15</code> 等情况）</p><table><thead><tr><th><strong>场景</strong></th><th><strong>查找过程</strong></th><th><strong>施加的锁类型</strong></th><th><strong>锁模式</strong></th></tr></thead><tbody><tr><td>记录存在</td><td>从起始点到扫描结束点</td><td>对所有扫描到的索引记录及<strong>它们之前的间隙</strong>加 <strong>Next-Key Lock</strong> (NK 锁)。<strong>注意：</strong> 范围结束点的锁是 NK 锁，而非单纯的 Record Lock。</td><td>$X$ 或 $S$</td></tr><tr><td>记录不存在</td><td>扫描范围内的间隙</td><td>对扫描范围内的所有间隙加 <strong>Next-Key Lock</strong> (NK 锁)。</td><td>$X$ 或 $S$</td></tr></tbody></table><ol start="4"><li>没加索引的查询 (全表扫描)</li></ol><p>（适用于 <code>WHERE</code> 子句中使用的列没有索引的情况）</p><table><thead><tr><th><strong>场景</strong></th><th><strong>查找过程</strong></th><th><strong>施加的锁类型</strong></th><th><strong>锁模式</strong></th></tr></thead><tbody><tr><td>记录存在</td><td>全表扫描，找到满足条件的记录</td><td>1. 对所有<strong>扫描到的记录</strong>（无论是否满足条件）都加 <strong>Next-Key Lock</strong> (NK 锁)。2. 最终的行级锁只保留在<strong>满足条件的记录</strong>上。</td><td>$X$ 或 $S$</td></tr><tr><td>记录不存在</td><td>全表扫描</td><td>对所有<strong>扫描到的记录</strong>加 <strong>Next-Key Lock</strong> (NK 锁)。</td><td>$X$ 或 $S$</td></tr></tbody></table><h2 id="死锁问题">死锁问题</h2><blockquote><p>这一部分偏实践，跟实际开发问题相关，需要用到前面的很多知识（需要知道有哪些锁的类型、要知道什么语句会使用什么锁、线上怎么看日志等），所以不多介绍（现在就暂时简单有个印象）。以后遇到问题了再来查询资料。</p></blockquote><p>资料：</p><p><a href="https://www.toberoot.com/database/mysql/dba_mysql/tec/mysql_5.7_%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90.html">MySQL 5.7 排查死锁</a></p><p><a href="https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html">解决死锁之路</a></p><p><a href="https://xiaolincoding.com/mysql/lock/deadlock.html">小林coding</a>、<a href="https://xiaolincoding.com/mysql/lock/show_lock.html">小林coding</a></p><ul><li>[ ] 实际遇到问题记录如下：</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2025/11/17/MySQL/MySQL%E4%BA%8B%E5%8A%A1/"/>
      <url>/2025/11/17/MySQL/MySQL%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1>MySQL事务</h1><p>事务，学名transaction。直译应该叫做“交易”。交易场景如下，A向B去买了一件商品，具体过程如下：</p><ol><li>A从自己的钱包拿出100元</li><li>B的钱包获得了100元</li><li>B将商品从自己的摊位拿出</li><li>A拿到了商品</li></ol><p>交易结束。上述的4个步骤是一整个过程，要么全部成功，要么全部失败，不能再任何一个地方中断。所以有了事务的四大特征：</p><h2 id="ACID">ACID</h2><p>A：原子性（Atomicity），即一个事务内包含的所有事件要么全部执行成功，要么因为一个出错就全部失败。</p><p>C：一致性（Consistency），即要保证数据之间的互相约束要始终有效。（有点抽象）典型例子就是转账，原本两人钱总和是1000，那么无论怎么转账，和都是1000。</p><p>I：隔离性（Isolation），即事务之间相互隔离，不能相互影响。</p><p>D：持久性（Durability），事务提交后，数据就是永久保存的，不应该丢失。</p><blockquote><p>InnoDB引擎通过什么技术来保证事务的ACID呢？</p><p>持久性通过redo log日志（重做日志）来保证</p><p>原子性通过undo log日志（回滚日志）来保证</p><p>隔离性通过MVCC或锁机制来保证</p><p>一致性通过持久性、原子性、隔离性来保证。</p></blockquote><h2 id="4种常见并发问题">4种常见并发问题</h2><p>这四种现象均是并发情况下产生的问题，或多或少违背了事务应有的性质。</p><p>严重程度从大到小为：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读。（后三个是重点）</p><h3 id="脏写（Dirty-Write）">脏写（Dirty Write）</h3><blockquote><p>实际InnoDB由于行锁的存在，下面两个事务只是正常的并发写入过程而已（彼此互斥），不能说是脏写。此处只是作为例子说明脏写。（为了知识的完整性）（实际更重要的还是脏读、不可重复读、幻读这三个）</p><blockquote><p>InnoDB存储引擎下</p></blockquote></blockquote><p>脏写：一个事务修改了另一个未提交事务修改过的数据。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>启动事务A</td><td></td></tr><tr><td>2</td><td></td><td>启动事务B</td></tr><tr><td>3</td><td></td><td>update user set money = 200 where id = 1</td></tr><tr><td>4</td><td>update user set money = 100 where id = 1</td><td></td></tr><tr><td>5</td><td>提交事务A</td><td></td></tr><tr><td>6</td><td></td><td>回滚事务B</td></tr></tbody></table><p>上面事务A修改了另一个事务B中未提交的这条记录（同样id=1），后来事务B回滚了，虽然事务A已经提交，但是最后回滚完发现自己什么都没改。</p><h3 id="脏读（Dirty-Read）">脏读（Dirty Read）</h3><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>启动事务A</td><td></td></tr><tr><td>2</td><td>查询余额为100</td><td></td></tr><tr><td>3</td><td></td><td>启动事务B</td></tr><tr><td>4</td><td></td><td>查询余额为100</td></tr><tr><td>5</td><td></td><td>修改余额为200</td></tr><tr><td>6</td><td>查询得到余额val1</td><td></td></tr><tr><td>7</td><td></td><td>提交事务B</td></tr><tr><td>8</td><td>查询得到余额val2</td><td></td></tr><tr><td>9</td><td>提交事务A</td><td></td></tr><tr><td>10</td><td>查询得到余额val3</td><td></td></tr></tbody></table><p>脏读：一个事务读到了另一个未提交事务修改过的数据。</p><ul><li>val1 = 200，val2 = 200，val3 = 200。</li><li>因为是脏读。</li></ul><h3 id="不可重复读（Non-Repeatable-Read）">不可重复读（Non-Repeatable Read）</h3><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>启动事务A</td><td></td></tr><tr><td>2</td><td>查询余额为100</td><td></td></tr><tr><td>3</td><td></td><td>启动事务B</td></tr><tr><td>4</td><td></td><td>查询余额为100</td></tr><tr><td>5</td><td></td><td>修改余额为200</td></tr><tr><td>6</td><td>查询得到余额val1</td><td></td></tr><tr><td>7</td><td></td><td>提交事务B</td></tr><tr><td>8</td><td>查询得到余额val2</td><td></td></tr><tr><td>9</td><td>提交事务A</td><td></td></tr><tr><td>10</td><td>查询得到余额val3</td><td></td></tr></tbody></table><p>不可重复读：一个事务能读取到另一个已提交事务修改后的数据，从自己事务来看就是前后读取到的值不一致。</p><ul><li>val1 = 100，val2 = 200，val3 = 200。</li><li>val1读不到事务B修改后的，但是事务B修改后能读取到（所以val2 = 200）</li></ul><h3 id="幻读（Phantom）">幻读（Phantom）</h3><p>幻读：事务A先根据某些条件查询出一些记录，之后事务B又向表内插入或删除了满足事务A条件的记录，然后事务A能读取到事务B新加入（或删除）的记录。</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>BEGIN;</td><td></td></tr><tr><td>2</td><td>SELECT COUNT(*) from user WHERE money &gt; 100;（查询结果为5）</td><td></td></tr><tr><td>3</td><td></td><td>BEGIN;</td></tr><tr><td>4</td><td></td><td>INSERT INTO user VALUES(6,“yukino”,150);</td></tr><tr><td>5</td><td></td><td>COMMIT;</td></tr><tr><td>6</td><td>SELECT COUNT(*) from user WHERE money &gt; 100;（查询结果为6）</td><td></td></tr><tr><td>7</td><td>COMMIT;</td><td></td></tr></tbody></table><p>时间点6发生了幻读。</p><h2 id="4种MySQL隔离级别">4种MySQL隔离级别</h2><p>为了解决并发过程中可能产生的问题，设计<code>InnoDB</code>的佬想了四种隔离级别。</p><ul><li>读未提交（READ UNCOMMITTED）：最低的隔离级别，能读取到另一个未提交事务中的修改后的数据。</li><li>读已提交（READ COMMITTED）：一个事务能读取到另一个事务提交修改后的数据。</li><li>可重复读（REPEATABLE READ）：一个事务内读取到的数据始终一致。</li><li>串行化（SERIALIZABLE）：最高的隔离级别，一个事务完成才能进行下一个事务。</li></ul><p>不同隔离级别下可能发生的问题：</p><table><thead><tr><th>隔离级别</th><th>可能发生的问题</th></tr></thead><tbody><tr><td>读未提交</td><td>脏读、不可重复读、幻读</td></tr><tr><td>读已提交</td><td>不可重复读、幻读</td></tr><tr><td>可重复读</td><td>幻读</td></tr><tr><td>串行化</td><td>/</td></tr></tbody></table><blockquote><p>实际上，MySQL的InnoDB引擎在在可重复读的隔离级别下，已经能避免大部分的幻读问题了。</p><p>但是并不绝对：<a href="https://xiaolincoding.com/mysql/transaction/phantom.html">blog</a></p></blockquote><h2 id="MVCC">MVCC</h2><p>要解释MVCC的工作原理，要先理解两个概念——<code>版本链</code>、<code>Read View</code>。</p><h3 id="版本链">版本链</h3><blockquote><p>此处借用<a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/24-%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC">《MySQL是怎样运行的：从根上理解MySQL》</a>的两张图。</p></blockquote><p><strong>官方/准确术语：</strong> <strong>History List</strong> (历史列表) 或通过 <strong>Roll Pointer</strong> (回滚指针) <strong>链接</strong>的记录版本。</p><p>版本链的作用就是通过 Undo Log 组织数据的<strong>所有历史版本</strong>，提供多版本数据源。</p><blockquote><p>至于有什么作用？是为了实现读未提交、读已提交、可重复读不同隔离级别所需要的数据结构（借用下算法里“数据结构”的概念）。</p></blockquote><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251117194050261.png" alt="img"></p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251117194050262.png" alt="img"></p><h3 id="Read-View">Read View</h3><blockquote><p>此处借用<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">事务隔离级别是怎么实现的？ | 小林coding </a>中的图。</p></blockquote><p><strong>官方/准确术语：</strong> <strong>Consistent Read View</strong>（一致性读视图） 或 <strong>Snapshot</strong> (快照)。</p><p><code>Read View</code>作用就是决定当前事务<strong>能看到</strong>哪个数据版本（可见性判断）。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251117194050263.png" alt="img"></p><p>详细介绍见上面两篇博客（死记硬背具体如何比较的没必要……）</p><p>大概理解就是——通过当前看一下记录中隐藏列中的<code>trx_id</code>：</p><ul><li><p><code>trx_id</code>等于<code>creator_trx_id</code>？说明是当前事务版本，那么就可以看到。</p></li><li><p><code>trx_id</code>小于<code>min_trx_id</code>？说明生成该版本数据的事务的提交早于当前事务生成Read View。</p></li><li><p><code>trx_id</code>大于<code>max_trx_id</code>？说明生成该版本数据的事务的开启晚于当前事务生成Read View。</p></li><li><p><code>trx_id</code>在<code>min_trx_id</code>和<code>max_trx_id</code>之间？</p><ul><li><p>如果<code>trx_id</code>在<code>m_ids</code>中，说明生成该版本数据的事务活跃且未提交。</p></li><li><p>如果<code>trx_id</code>不在<code>m_ids</code>中，说明生成该版本数据的事务已提交。</p><blockquote><p>如果 <code>trx_id</code> 不在 <code>m_ids</code>，它只能表示该事务在 <code>Read View</code> <strong>生成的那一刻</strong>就已经<strong>提交</strong>了（或已经回滚，但回滚后的版本最终指向前一个已提交的版本）。</p></blockquote></li></ul></li></ul><p>如果一个版本不可见，就沿着版本链看看下一个是否可见。</p><blockquote><p>大致理解，但不准确……</p></blockquote><p>因此不同隔离级别，只是可见性的不同。比如读未提交，就是能看见<code>trx_id</code>在<code>m_ids</code>的版本数据。又如读已提交，必须是<code>trx_id</code>不在<code>m_ids</code>中才能看见。又如可重复读，<code>trx_id</code>必须小于<code>min_trx_id</code>才可见。</p><h3 id="MVCC在不同隔离级别下的使用情况">MVCC在不同隔离级别下的使用情况</h3><p>准确描述如下：</p><ol><li><p>读未提交 (READ UNCOMMITTED)</p><table><thead><tr><th><strong>描述</strong></th><th><strong>最大异常</strong></th><th><strong>InnoDB 实现</strong></th><th><strong>可见性机制</strong></th></tr></thead><tbody><tr><td><strong>描述：</strong> 一个事务可以读取到其他事务<strong>尚未提交</strong>（未持久化）的修改。</td><td><strong>脏读 (Dirty Read)：</strong> 允许读取到未提交的数据。</td><td>InnoDB <strong>不使用 MVCC</strong> 进行读取，直接读取数据的最新物理版本。</td><td>不使用 Read View，总是读取最新数据。</td></tr></tbody></table></li><li><p>读已提交 (READ COMMITTED)</p><table><thead><tr><th><strong>描述</strong></th><th><strong>最大异常</strong></th><th><strong>InnoDB 实现</strong></th><th><strong>可见性机制</strong></th></tr></thead><tbody><tr><td><strong>描述：</strong> 一个事务只能读取到其他事务<strong>已经提交</strong>的修改。</td><td><strong>不可重复读 (Non-repeatable Read)：</strong> 同一事务内，两次读取同一行记录，可能会得到不同的值。</td><td>InnoDB <strong>不使用 MVCC</strong> 进行读取，直接读取数据的最新物理版本。</td><td>不使用 Read View，总是读取最新数据。</td></tr></tbody></table></li><li><p>可重复读 (REPEATABLE READ)</p><table><thead><tr><th><strong>描述</strong></th><th><strong>最大异常</strong></th><th><strong>InnoDB 实现</strong></th><th><strong>可见性机制</strong></th></tr></thead><tbody><tr><td><strong>描述：</strong> 保证在同一事务内，对同一数据的多次读取结果是一致的。</td><td><strong>幻读 (Phantom Read)：</strong> 在大部分情况下，MySQL 的 <code>REPEATABLE READ</code> 级别会通过特殊的锁机制<strong>阻止幻读</strong>。</td><td><strong>事务第一次执行 <code>SELECT</code> 语句时生成 Read View</strong>，并在整个事务生命周期内<strong>重复使用</strong>该视图。</td><td>由于 Read View 始终不变，事务只能看到在<strong>视图生成前</strong>就已提交的数据版本，从而实现了<strong>可重复读</strong>。此外，通过 <strong>Next-Key Locks（临键锁）</strong> 解决了幻读问题。</td></tr></tbody></table></li><li><p>串行化 (SERIALIZABLE)</p><table><thead><tr><th><strong>描述</strong></th><th><strong>最大异常</strong></th><th><strong>InnoDB 实现</strong></th><th><strong>可见性机制</strong></th></tr></thead><tbody><tr><td><strong>描述：</strong> 最高的隔离级别。所有事务按顺序执行，彼此完全隔离，如同单线程运行。</td><td><strong>无异常。</strong> 杜绝所有并发异常（脏读、不可重复读、幻读）。</td><td><strong>所有普通 <code>SELECT</code> 语句都会隐式地转换为 <code>SELECT ... FOR SHARE</code></strong>，对读取的行加共享锁（S 锁），阻止其他事务的写入。</td><td>主要依赖<strong>悲观锁</strong>，而不是 MVCC。</td></tr></tbody></table></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java项目零失败启动指南（IDEA）</title>
      <link href="/2025/11/14/Java/Java%E9%A1%B9%E7%9B%AE%E9%9B%B6%E5%A4%B1%E8%B4%A5%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/11/14/Java/Java%E9%A1%B9%E7%9B%AE%E9%9B%B6%E5%A4%B1%E8%B4%A5%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1>Java项目零失败启动指南（IDEA）</h1><p>本文的目的，在于终结<code>ClassNotFoundException</code>报错；</p><p>在于拿到一个项目时，能够避免因为依赖问题而报错无法启动。</p><blockquote><p>以下内容均基于 IntelliJ IDEA 进行讲解</p></blockquote><h2 id="检查SDK">检查SDK</h2><p>路径：File -&gt; Project structrue -&gt; Project -&gt; SDK</p><p>修改如下</p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349511.png" alt="image-20251209204317815"></p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349512.png" alt="image-20251209204421459"></p><h2 id="检查-Language-Level">检查 Language Level</h2><p>路径：File -&gt; Project structrue -&gt; Module -&gt; Language Level</p><p>建议把每个模块都点一遍检查一下</p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349514.png" alt="image-20251209205221485"></p><h2 id="检查最终运行时配置">检查最终运行时配置</h2><p>路径：Run/Debug Configurations -&gt; Build and run</p><p>这里其实还有很多东西可以配置，比如 VM 参数。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349515.png" alt="image-20251209205301603"></p><p>还有可能会遇到一个问题，是 windows 平台特有的，会报错提示类似“VM启动参数过长”，请你“缩短长度之类的”</p><p>那就在下方勾选上 Shorten command line，并选择 JAR manifest</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349516.png" alt="image-20251209205530865" style="zoom: 85%;" /><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349517.png" alt="image-20251209205631143"></p><h2 id="检查-Maven-版本">检查 Maven 版本</h2><p>使用Maven构建项目时，也需要注意pom文件中的Maven版本：<br>路径：Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</p><p>建议不要使用 IDEA 自带的，使用自己本地的 Maven 配置和对应仓库。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349518.png" alt="image-20251209205747911"></p><h3 id="没有对应-Maven-版本呢？">没有对应 Maven 版本呢？</h3><p>去官网下载，但是也有人问我找不到官网哪里下载……我一开始寻思很难找吗？</p><p>确实有点难度，稍微废了点功夫找历史版本的下载入口，现在记录一下：</p><blockquote><p>下载Maven-3.x版本省流：<a href="https://archive.apache.org/dist/maven/maven-3/">https://archive.apache.org/dist/maven/maven-3/</a></p><p>Maven-4.x：<a href="http://archive.apache.org/dist/maven/maven-4/">http://archive.apache.org/dist/maven/maven-4/</a></p></blockquote><p>首先来到官网链接：<em><strong><a href="https://maven.apache.org/">https://maven.apache.org/</a></strong></em></p><p>右侧点击 Downloads</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349519.png" alt="image-20251209210749990" style="zoom: 75%;" /><p>搜索 archives 关键词，点击 <code>Maven 3 archives</code>进入</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349520.png" alt="image-20251209210905195" style="zoom: 85%;" /><p>之后选择需要的版本，下载打包好的二进制文件或者源码（）</p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251209211349521.png" alt="image-20251209211149740" style="zoom: 75%;" />]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2025/11/12/MySQL/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2025/11/12/MySQL/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1>MySQL索引</h1><h2 id="索引的优势与劣势">索引的优势与劣势</h2><p>简而言之，优势——能<strong>大大加快</strong>数据的查询速度。劣势——增加了额外的空间来存储索引，且执行插入、删除操作语句时增加了维护索引的成本。</p><p>所以建立了索引就一定是要用起来的，不然不如不建立，而且索引对于优化查询的效果是否大，和我们如何写索引（使用哪种索引？存储引擎？），如何写SQL语句，以及数据（数据量、数据类型、数据分布等）有很大关系。</p><p>不过总体来说使用索引的优势还是大于不使用。</p><h2 id="索引的类型分类">索引的类型分类</h2><ol><li><p>按数据结构分：</p><p>可以分为<strong>B+Tree索引、哈希索引、Full-Text索引</strong>，一般使用的都是B+Tree索引。</p></li><li><p>按物理存储分：</p><p>分为<strong>聚簇索引（也称主键索引）<strong>和</strong>非聚簇索引（或称二级索引、辅助索引）</strong>，说聚簇索引，那就是在说InnoDB存储引擎了，InnoDB存储引擎在存储数据时，会使用主键索引的方式，将索引和数据放在一起，数据是按照主键进行有序存储的。二级索引是另外一个空间中，存储了id（主键）和索引字段。</p><blockquote><p>就想象有两棵B+树，一棵的叶子节点上存储了所有字段数据，且按照id排序；另一棵的叶子节点上存储的是id和索引字段，且按照索引字段排序。</p></blockquote></li><li><p>按字段特性分：</p><p>分为<strong>主键索引、唯一索引、前缀索引、普通索引</strong>。这个见名知义了。主键索引就是以主键为索引（非空且唯一）；唯一索引就是索引字段唯一；前缀索引指的是利用varchar、char等类型的前几个字符建立的索引；普通索引就是一般的索引（字段可以为null、也可以不唯一）</p></li><li><p>按字段个数分：<strong>单列索引、联合索引</strong>。比如对（score）字段建立索引，也可以是对（score，name）两个字段建立联合索引。</p></li></ol><h2 id="如何用好索引">如何用好索引</h2><p>众锁周知，索引是把双刃剑，既带来了查询性能的提升，又带来了维护索引的开销。因此我们要结合具体的场景来分析是否要用索引，也要知道什么样的场景索引会生效、什么场景索引会失效。</p><h3 id="适合使用索引的场景">适合使用索引的场景</h3><ol><li>在<code>where</code>、<code>order by</code>中频繁使用到的字段</li><li>索引字段区分度较高</li><li>在进行多表查询时，对外键增加索引可以大大提高join操作效率</li><li>建立索引的字段不应过长、如果太长可以考虑使用前缀索引</li><li>建立联合索引时，应遵循最左匹配原则，把使用频率最高的放在最左边</li><li>尽量使用联合索引代替单列索引</li></ol><h3 id="不适合使用索引的场景">不适合使用索引的场景</h3><ol><li>字段不在<code>where</code>、<code>order by</code>中使用</li><li>字段区分度低（比如性别）</li><li>经常删改的字段不适合建立索引</li><li>索引不能参与计算，会导致索引失效，所以经常要参与计算的字段不应建立索引</li><li>索引字段无序时不建议建立索引，会导致页分裂</li></ol><h3 id="索引失效场景">索引失效场景</h3><ol><li><p>查询带有or，且其中一个条件的字段没用到索引</p></li><li><p>使用了联合索引，但是sql查询时没有最左匹配</p></li><li><p>模糊查询（like）字符以%开头</p></li><li><p>索引字段参与计算</p></li><li><p>索引字段使用函数计算</p></li><li><p>隐式类型转换导致索引失效，比如数据库中phone是varchar类型，然后where条件写了个整数类型。相当于对字段使用了<code>CAST</code>类型装换函数，所以索引失效（MySQL在比较字符和数字时，是将字符转换为数字）</p></li><li><p>不同字段值对比导致索引失效（？）</p></li><li><p>反向操作，比如写NOT IN、IS NOT NULL、!=之类的。</p></li></ol><h2 id="其他知识点">其他知识点</h2><p>可以使得知识体系更完善。（当然硬要说还可以说存储引擎——InnoDB、MyISAM）</p><h3 id="索引覆盖">索引覆盖</h3><blockquote><p>索引覆盖，就是要查询的列，在索引中已经包含，则被所使用的的索引覆盖，不需要再回表。</p></blockquote><p>假设有一个联合索引为<code>idx（a,b,c）</code>，where过滤条件符合最左匹配原则，且select查询时只查询了<code>a</code>和<code>b</code>两个字段，那么直接在二级索引表中查出数据返回，不用去得到id值、然后再进行<strong>回表</strong>，在主键索引中查找对应数据。</p><p>所以如果只要查询a、b、c三个字段信息的话，就不要写<code>select *</code>，避免不必要的回表操作。</p><h3 id="最左匹配原则">最左匹配原则</h3><blockquote><p>指的是，使用索引时，存在最左匹配的规则。</p></blockquote><p>假设有一个联合索引<code>idx(a,b,c)</code></p><ol><li>where过滤条件必须先有a、再有b、再有c。由于order by优先级比where低——所以假设where条件中是b，order by中是a，那么这个idx不生效。</li><li>当a是严格大于（&gt;）或严格小于（&lt;）时，那么后面的b、c都不生效。但是如果a是≥或≤，则b、c照样生效。</li></ol><p>注：由于优化器的存在，where中字段的顺序不影响最左匹配（即<code>where a = ? and b = ? </code>等价于 <code>where b = ? and a = ?</code>）</p><h3 id="索引下推">索引下推</h3><blockquote><p>索引下推，就是将Server层筛选数据的工作，放到了执行引擎层来做。</p></blockquote><p>这个机制是MySQL 5.6新增的优化机制，默认开启。</p><p>无索引下推时的查询：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112202116049.png" alt="无索引下推"></p><p>有索引下推时的查询：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112202116050.png" alt="MySQL有索引下推时的查询"></p><p>可以发现，有索引下推后，回表的次数就变少了。（原先需要对4条数据通过id进行回表查询、而现在只有两条数据需要回表查询）。</p><h3 id="CBO：基于成本的优化器">CBO：基于成本的优化器</h3><blockquote><p>CBO，即Cost-based-Optimizer，基于成本的优化器，会通过计算一条sql语句的使用索引的成本的来决定是否使用or使用哪条索引。</p></blockquote><blockquote><p>该部分参考自<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/11%20%20%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99%EF%BC%9A%E8%AF%B7%E7%90%86%E8%A7%A3%20CBO%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md">技术文章摘录——索引出错：请理解CBO的工作原理</a></p></blockquote><p>两个“奇怪”的案例：</p><p>案例1：明明两次查询时的SQL语句均相同，为什么一次使用了索引，一次没有使用索引？</p><p>通常是因为优化器认为使用索引的cost（成本）高于全表扫描。比如一条范围查询语句，但是满足条件的记录数很多，近乎与全表数据了，此时即使可以走索引，但是还要再全部回表，执行成本就很高。（不如直接全表扫描）</p><p>案例2：索引建立在有限状态的字段上</p><p>假设有一张订单表，我们对于其状态建立了索引，而状态可能有未完成、进行中、已完成这几类。通常订单状态大部分是已完成的，而未完成和进行中相比是少量的，这就存在<strong>数据倾斜</strong>，而优化器却认为订单状态是平均分布的，导致对于未完成和进行中的订单，优化器认为记录数很多，基于索引方式+回表查询成本太高。解决方案是，让优化器能知道数据的分布，可以利用MySQL 8.0的直方图功能，创建一个直方图，使其知道数据分布，从而更好地选择执行计划。</p><h2 id="实践">实践</h2><blockquote><p>联合索引（a，b，c），下面的查询语句会不会走索引？如果走，具体是哪些字段能走？</p></blockquote><ol><li><code>select * from t_test where a = 1 and b = 2 and c = 3;</code></li><li><code>select * from t_test where a = 1 and b &gt; 2 and c = 3;</code></li><li><code>select * from t_test where a = 1 and b &gt;=2 and c = 3;</code></li><li><code>select * from t_test where c = 1 and a = 2 and b = 3;</code></li><li><code>select * from t_test where a = 2 and c = 3;</code></li><li><code>select * from t_test where b = 2 and c = 3;</code></li><li><code>select a,b from t_test where a = 1 and b &gt; 2;</code></li></ol><p>解答：</p><ol><li>遵循最左匹配原则，abc都能走索引，查询方式是在联合索引找到主键后，回主键索引查找完整数据。</li><li>根据最左匹配原则，ab可以走，c无法走，但是c可以索引下推（MySQL 5.6优化）</li><li>abc都可以走，此处<code>b&gt;=2</code>也是可以走索引的，且不会破坏c</li><li>abc都能走，where查询条件字段的顺序不会影响，MySQL优化器会帮我们调整字段的查询顺序。</li><li>a能，c不能走索引，但是c能索引下推。</li><li>bc都不能，但是bc能走索引下推</li><li>ab都能走索引，且查询方式是索引覆盖（不用回表）</li></ol><blockquote><p><code>where a &gt; 1 and b = 2 and c &lt; 3</code>怎么建立索引？</p></blockquote><ul><li>如果是idx_ab、idx_ac、idx_abc、idx_acb，则abc都不走索引</li><li>如果是idx_ca、idx_cb、idx_cab、idx_cba，则abc都不走索引</li><li>如果是idx_ba，则b和a走索引。</li><li>如果是idx_ca，则b和c走索引。</li><li>如果是idx_bac，则b和a走索引，c不走索引但走索引下推。</li><li>如果是idx_cab，则b和c走索引，b不走索引但走索引下推。</li></ul><blockquote><p><code>where a &gt; 100 and b = 100 and c = 123 order by d</code>怎么建立联合索引？</p></blockquote><p>推荐idx_bcda或者使用idx_cbda，这样的话bcd都能走索引（不会发生filesort），而a能走索引下推。</p><p>如果把a和d的位置互换，比如idx_bcad，虽然bca能走索引，但是在order by中的d就走不了索引（会发生file sort）。</p><blockquote><p><code>select * from t where a &gt; ? and b = ? or c = ?</code>怎么优化？</p></blockquote><p>分析：如果有or，那么光是索引idx_ba还是会导致索引失效。</p><p>所以应该使用索引idx_ba和idx_c，这样索引不会失效。</p><blockquote><p>联合索引（a，b，c），<code>select * from t where a = ? and b in (?,?) and c = ?</code>会不会走索引？如果走，具体是哪些字段能走？</p></blockquote><p>如果是<code>in (?,?)</code>，并没有绝对的答案说走不走索引，如果b的值有3个（1、2、3），如果b = 1或b = 2的个数很少，那么<code>b in (1,2)</code>是会走索引的，但是如果b = 1或b = 2的个数很多（几百万条），那么<code>b not in (1,2)</code>就不会走索引（节省回表开销）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL8 窗口函数</title>
      <link href="/2025/11/11/MySQL/MySQL8-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/2025/11/11/MySQL/MySQL8-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>MySQL8-窗口函数</h1><h2 id="为什么要使用窗口函数">为什么要使用窗口函数</h2><p>MySQL 窗口函数是 8.0版本之后才推出的新特性，它相比于聚合函数，会有更好的性能（可以避免写一些子查询的sql语句，改为使用窗口函数、减少了扫描数据库的次数）。且语法简单，适合更复杂的查询。</p><h2 id="从聚合函数说起">从聚合函数说起</h2><p>假设有一个销售额表（sales），他有字段（id，name，year，sale）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建销售额表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    sale <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales (name, <span class="keyword">year</span>, sale) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2021</span>, <span class="number">5000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2021</span>, <span class="number">7000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2021</span>, <span class="number">8000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2022</span>, <span class="number">9000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2022</span>, <span class="number">6000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2022</span>, <span class="number">12000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2023</span>, <span class="number">11000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2023</span>, <span class="number">9500.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2023</span>, <span class="number">10500.00</span>);</span><br></pre></td></tr></table></figure><p>现有一个需求——查询每年的总销售额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每年的总销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, <span class="built_in">SUM</span>(sale) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure><p>可以发现，使用<code>sum()</code>函数和<code>group by</code>语句后，查询到的数据行数<strong>变少</strong>了。</p><p>查询前：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824659.png" alt="image-20251112150744731"></p><p>查询后：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824661.png" alt="image-20251112150811446"></p><p>那么使用聚合函数，查询结果会变成什么样呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span>) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824662.png" alt="image-20251112151059780"></p><p>会发现，不仅select中能查询到其余的所有字段，还会在查询结果<strong>多出一列</strong>（即<code>SUM(sale) OVER (PARTITION BY year)</code>），我们给他命名为<code>total_sale</code></p><p>直观上来看，窗口函数能在不压缩列的情况下，为每行都增加该年的销售总额。</p><h2 id="窗口函数具体语法">窗口函数具体语法</h2><p>调用窗口函数语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window_function_name ( [expression] ) </span><br><span class="line">    <span class="keyword">OVER</span> (</span><br><span class="line">        [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr_list]</span><br><span class="line">        [<span class="keyword">ORDER</span> <span class="keyword">BY</span> order_list]</span><br><span class="line">        [frame_clause]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p><strong>window_function_name</strong>：窗口函数名称，如 <code>SUM</code>, <code>AVG</code>, <code>ROW_NUMBER</code>, <code>RANK</code> 等。</p></li><li><p><strong>expression</strong>：可选，用于计算的列或表达式。</p></li><li><p><strong>PARTITION BY</strong>：按指定字段对数据进行分区，窗口函数在每个分区内独立计算。</p></li><li><p><strong>ORDER BY</strong>：定义分区内行的计算顺序。部分函数（如排名类）必须使用。</p></li><li><p><strong>frame_clause</strong>：定义计算窗口的行范围。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROWS</span> <span class="operator">|</span> <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> frame_start <span class="keyword">AND</span> frame_end</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>UNBOUNDED PRECEDING</code>：从分区第一行开始</li><li><code>N PRECEDING</code>：当前行前 N 行</li><li><code>CURRENT ROW</code>：当前行</li><li><code>N FOLLOWING</code>：当前行后 N 行</li><li><code>UNBOUNDED FOLLOWING</code>：到分区最后一行</li></ul></li></ul><p>默认帧（当使用 <code>ORDER BY</code> 且未显式指定时）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> name) <span class="keyword">AS</span> total_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><h2 id="MySQL窗口函数列表">MySQL窗口函数列表</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CUME_DIST</td><td style="text-align:left">计算一组值中值的累积分布。</td></tr><tr><td style="text-align:left">DENSE_RANK</td><td style="text-align:left">根据 ORDER BY 子句为其分区中的每一行分配一个排名。 它为具有相同值的行分配相同的排名。 如果两行或更多行具有相同的等级，则排序值序列中将没有间隙。</td></tr><tr><td style="text-align:left">FIRST_VALUE</td><td style="text-align:left">返回指定表达式相对于窗口框架中第一行的值。</td></tr><tr><td style="text-align:left">LAG</td><td style="text-align:left">返回分区中当前行之前的第N行的值。 如果不存在前一行，则返回NULL。</td></tr><tr><td style="text-align:left">LAST_VALUE</td><td style="text-align:left">返回指定表达式相对于窗口框架中最后一行的值。</td></tr><tr><td style="text-align:left">LEAD</td><td style="text-align:left">返回分区中当前行之后的第N行的值。 如果不存在后续行，则返回NULL。</td></tr><tr><td style="text-align:left">NTH_VALUE</td><td style="text-align:left">返回窗口框架第N行的参数值</td></tr><tr><td style="text-align:left">NTILE</td><td style="text-align:left">将每个窗口分区的行分配到指定数量的已排名组中。</td></tr><tr><td style="text-align:left">PERCENT_RANK</td><td style="text-align:left">计算分区或结果集中行的百分位数</td></tr><tr><td style="text-align:left">RANK</td><td style="text-align:left">与 DENSE_RANK() 函数类似，只是当两行或更多行具有相同的排名时，排序值序列中存在间隙。</td></tr><tr><td style="text-align:left">ROW_NUMBER</td><td style="text-align:left">为其分区中的每一行分配一个连续整数</td></tr></tbody></table><p><strong>排序类</strong>：<code>ROW_NUMBER</code>, <code>RANK</code>, <code>DENSE_RANK</code>, <code>NTILE</code></p><p><strong>取值类</strong>：<code>FIRST_VALUE</code>, <code>LAST_VALUE</code>, <code>NTH_VALUE</code>, <code>LAG</code>, <code>LEAD</code></p><p><strong>统计类</strong>：<code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, <code>CUME_DIST</code>, <code>PERCENT_RANK</code></p><h2 id="窗口函数实践">窗口函数实践</h2><p>适合的场景有：Top N查询、累计百分比（贡献度分析）、计算移动平均（时间序列分析）、增长率计算、多维排序与全局排名、动态帧区间分析</p><p>用以下表和数据作为展示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">INT</span>,</span><br><span class="line">    sale <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales (name, <span class="keyword">year</span>, sale) <span class="keyword">VALUES</span></span><br><span class="line"><span class="comment">-- 2021</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2021</span>, <span class="number">5000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2021</span>, <span class="number">7000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2021</span>, <span class="number">8000.00</span>),</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">2021</span>, <span class="number">6000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Ella&#x27;</span>,  <span class="number">2021</span>, <span class="number">9000.00</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2022</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2022</span>, <span class="number">9000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2022</span>, <span class="number">6000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2022</span>,<span class="number">12000.00</span>),</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">2022</span>, <span class="number">9500.00</span>),</span><br><span class="line">(<span class="string">&#x27;Ella&#x27;</span>,  <span class="number">2022</span>,<span class="number">11000.00</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2023</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">2023</span>,<span class="number">11000.00</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>,   <span class="number">2023</span>, <span class="number">9500.00</span>),</span><br><span class="line">(<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">2023</span>,<span class="number">10500.00</span>),</span><br><span class="line">(<span class="string">&#x27;David&#x27;</span>, <span class="number">2023</span>,<span class="number">12500.00</span>),</span><br><span class="line">(<span class="string">&#x27;Ella&#x27;</span>,  <span class="number">2023</span>, <span class="number">8000.00</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>Top N查询</p><p>需求：取出每年销售额前 2 名的销售员。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        name,</span><br><span class="line">        <span class="keyword">year</span>,</span><br><span class="line">        sale,</span><br><span class="line">        <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale <span class="keyword">DESC</span>) <span class="keyword">AS</span> rnk</span><br><span class="line">    <span class="keyword">FROM</span> sales</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">WHERE</span> t.rnk <span class="operator">&lt;=</span> <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>窗口排名在每个年份分区内重新计算，通过外层筛选得到每年 Top N。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824663.png" alt="image-20251112153404577"></p></li><li><p>累计百分比（贡献度分析）</p><p>需求：统计每年各销售员销售额占比及其累计百分比。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    name,</span><br><span class="line">    sale,</span><br><span class="line">    ROUND(sale <span class="operator">/</span> <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span>) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> pct,</span><br><span class="line">    ROUND(<span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale <span class="keyword">DESC</span></span><br><span class="line">          <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span>)</span><br><span class="line">          <span class="operator">/</span> <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span>) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> cum_pct</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>, sale <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><code>pct</code> 表示每人销售额占当年比例。</p><p><code>cum_pct</code> 表示累计占比，可用于找出“贡献前 80% 的销售员”。如果加上<code>where cum_pct &lt; 80</code>，就能知道。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824664.png" alt="image-20251112153559130"></p></li><li><p>计算移动平均（时间序列分析）</p><p>需求：计算每个销售员最近 2 年的移动平均销售额。</p><blockquote><p>也就是计算出销售员这两年平均的销售额，相比于只计算一年，可以剔除单年异常波动。</p><p>（同理也可以改为近3年的、近3个月的）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    ROUND(<span class="built_in">AVG</span>(sale) <span class="keyword">OVER</span> (</span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">        <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br><span class="line">    ), <span class="number">2</span>) <span class="keyword">AS</span> moving_avg</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name, <span class="keyword">year</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ROWS BETWEEN 1 PRECEDING AND CURRENT ROW</code> 表示窗口为当前行及前一行，形成滑动平均。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824665.png" alt="image-20251112154146817"></p></li><li><p>增长率计算</p><p>需求：比较每个销售员当年销售额与上一年增长率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">LAG</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>) <span class="keyword">AS</span> prev_sale,</span><br><span class="line">    ROUND((sale <span class="operator">-</span> <span class="built_in">LAG</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>))</span><br><span class="line">          <span class="operator">/</span> <span class="built_in">LAG</span>(sale) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>) <span class="operator">*</span> <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">AS</span> growth_rate</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name, <span class="keyword">year</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>LAG()</code> 获取上一年销售额，计算百分比增长率。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824667.png" alt="image-20251112154332180"></p></li><li><p>多维排序与全局排名</p><p>需求：为所有销售数据按年份、销售额综合排序，显示全局名次与分区内名次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> sale <span class="keyword">DESC</span>) <span class="keyword">AS</span> global_rank,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">year</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale <span class="keyword">DESC</span>) <span class="keyword">AS</span> year_rank</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> global_rank;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>global_rank</code> 给出全表排名。</p><p><code>year_rank</code> 给出每年分区内的排名。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824668.png" alt="image-20251112154454703"></p></li><li><p>动态帧区间分析</p><p>需求：查看每个销售员从当前年份开始到未来两年内的销售总额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    <span class="keyword">year</span>,</span><br><span class="line">    sale,</span><br><span class="line">    <span class="built_in">SUM</span>(sale) <span class="keyword">OVER</span> (</span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span></span><br><span class="line">        <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="keyword">AND</span> <span class="number">2</span> FOLLOWING</span><br><span class="line">    ) <span class="keyword">AS</span> next_3_year_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name, <span class="keyword">year</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>窗口定义为当前行 + 后两行，适合做预测期累计或滚动规划。</p><blockquote><p>下面展示的数据虽然看上去next_3_year_sales数值越来越小、实际上只是因为示例数据没有2024、2025年的数据而已……</p></blockquote><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251112154824669.png" alt="image-20251112154743284"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cron表达式</title>
      <link href="/2025/11/11/other/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/11/11/other/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>cron表达式</h1><p>cron 表达式用于定义定时任务的执行时间规则。它由若干字段组成，不同系统略有差异（如 Linux <code>crontab</code> 与 Spring 的 cron 表达式），但核心思想相同：<strong>用数字和符号描述任务的周期性时间点</strong>。</p><h2 id="一、标准格式（Linux）">一、标准格式（Linux）</h2><p>共 5 个字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>取值范围</th></tr></thead><tbody><tr><td>1</td><td>分钟 (Minutes)</td><td>0–59</td></tr><tr><td>2</td><td>小时 (Hours)</td><td>0–23</td></tr><tr><td>3</td><td>日期 (Day of Month)</td><td>1–31</td></tr><tr><td>4</td><td>月份 (Month)</td><td>1–12 或 JAN–DEC</td></tr><tr><td>5</td><td>星期 (Day of Week)</td><td>0–7（0或7代表星期天）</td></tr></tbody></table><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * *        # 每天凌晨2:30执行</span><br><span class="line">0 */6 * * *       # 每6小时执行一次</span><br><span class="line">0 9-18 * * 1-5    # 周一至周五，9点到18点每小时执行一次</span><br><span class="line">15 10 15 * *      # 每月15日10:15执行</span><br></pre></td></tr></table></figure><hr><h2 id="二、Spring-或-Quartz-格式">二、Spring 或 Quartz 格式</h2><p>共 6 或 7 个字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>取值范围</th></tr></thead><tbody><tr><td>1</td><td>秒 (Seconds)</td><td>0–59</td></tr><tr><td>2</td><td>分 (Minutes)</td><td>0–59</td></tr><tr><td>3</td><td>时 (Hours)</td><td>0–23</td></tr><tr><td>4</td><td>日 (Day of Month)</td><td>1–31</td></tr><tr><td>5</td><td>月 (Month)</td><td>1–12 或 JAN–DEC</td></tr><tr><td>6</td><td>星期 (Day of Week)</td><td>1–7 或 SUN–SAT</td></tr><tr><td>7（可选）</td><td>年 (Year)</td><td>1970–2099</td></tr></tbody></table><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 * * ?       # 每天中午12点执行</span><br><span class="line">0 15 10 ? * *      # 每天10:15执行</span><br><span class="line">0 0/5 * * * ?      # 每5分钟执行一次</span><br><span class="line">0 0 9 ? * MON-FRI  # 每周一到周五上午9点执行</span><br></pre></td></tr></table></figure><hr><h2 id="三、通配符说明">三、通配符说明</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>任意值</td></tr><tr><td><code>/</code></td><td>步长，如 <code>*/5</code> 表示每5单位执行一次</td></tr><tr><td><code>-</code></td><td>范围，如 <code>1-5</code> 表示1到5</td></tr><tr><td><code>,</code></td><td>多个值，如 <code>1,3,5</code></td></tr><tr><td><code>?</code></td><td>不指定具体值（常用于“日”和“星期”字段避免冲突）</td></tr></tbody></table><hr><h2 id="四、差异简述">四、差异简述</h2><ul><li>Linux <code>crontab</code> 没有“秒”字段；</li><li>Quartz/Spring cron 多一个“秒”字段；</li><li>Quartz 中日与星期字段不能同时指定，需用 <code>?</code> 占位。</li></ul><h2 id="五、常见业务的-cron-表达式">五、常见业务的 cron 表达式</h2><table><thead><tr><th>业务场景</th><th>表达式（Quartz/Spring 格式）</th><th>说明</th></tr></thead><tbody><tr><td>每天凌晨 2 点执行备份</td><td><code>0 0 2 * * ?</code></td><td>每天 02:00 运行</td></tr><tr><td>每隔 10 分钟采集一次数据</td><td><code>0 0/10 * * * ?</code></td><td>每 10 分钟触发一次</td></tr><tr><td>每小时执行日志清理</td><td><code>0 0 * * * ?</code></td><td>每小时整点执行</td></tr><tr><td>每天 23:30 发送日报</td><td><code>0 30 23 * * ?</code></td><td>每天晚上 11:30 执行</td></tr><tr><td>每周一凌晨 1 点重启服务</td><td><code>0 0 1 ? * MON</code></td><td>每周一 01:00 执行</td></tr><tr><td>每月 1 日 0 点归档数据</td><td><code>0 0 0 1 * ?</code></td><td>每月第一天 00:00 执行</td></tr><tr><td>工作日每天早 9 点启动任务</td><td><code>0 0 9 ? * MON-FRI</code></td><td>周一至周五 09:00 执行</td></tr><tr><td>每天每 30 秒检测一次状态</td><td><code>0/30 * * * * ?</code></td><td>每 30 秒触发</td></tr><tr><td>每天 8 点到 20 点，每小时执行一次</td><td><code>0 0 8-20 * * ?</code></td><td>8:00–20:00 每整点执行</td></tr><tr><td>每月最后一天 23:59 生成月报</td><td><code>0 59 23 L * ?</code></td><td>每月最后一天晚上 11:59 执行</td></tr></tbody></table><p>Linux <code>crontab</code>（无秒字段）等价版本，直接去掉首个 <code>0</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker中启动nacos</title>
      <link href="/2025/11/09/other/docker%E4%B8%AD%E5%90%AF%E5%8A%A8nacos/"/>
      <url>/2025/11/09/other/docker%E4%B8%AD%E5%90%AF%E5%8A%A8nacos/</url>
      
        <content type="html"><![CDATA[<h1>docker中启动nacos</h1><h2 id="操作流程">操作流程</h2><blockquote><p>linux平台的操作流程见该<a href="https://blog.csdn.net/web2u/article/details/145107436">博客</a>（而且他的mysql数据库不是容器、如果是容器得先保证nacos和mysql同一个网络下）</p></blockquote><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos/nacos-server:v2.4.1</span><br></pre></td></tr></table></figure></li><li><p>创建宿主机中的目录（windows演示）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> E:\develop_tools\Docker_data\nacos-2.4.1\nacos\logs</span><br><span class="line"><span class="built_in">mkdir</span> E:\develop_tools\Docker_data\nacos-2.4.1\nacos\conf</span><br></pre></td></tr></table></figure></li><li><p>首次启动nacos并复制文件到宿主机</p><blockquote><p>由于首次启动时对nacos的配置没写好，所以肯定是启动失败的，这次启动只是为了得到他的logs和conf，使用宿主机的目录去映射（这样就可以通过修改宿主机中的配置更改nacos的配置）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动临时容器</span></span><br><span class="line">docker run -d --name nacos-temp -p 8848:8848 nacos/nacos-server:v2.4.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制容器内文件到宿主机</span></span><br><span class="line">docker <span class="built_in">cp</span> nacos-temp:/home/nacos/logs/ E:\develop_tools\Docker_data\nacos-2.4.1\nacos\</span><br><span class="line">docker <span class="built_in">cp</span> nacos-temp:/home/nacos/conf/ E:\develop_tools\Docker_data\nacos-2.4.1\nacos\</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除临时容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f nacos-temp</span><br></pre></td></tr></table></figure></li><li><p>mysql中创建nacos所需要的数据库、表</p><ul><li><p>你的 MySQL 运行在 Docker 容器中，容器名为 <code>mysql-8.0.44</code>，需先进入容器执行 SQL。</p></li><li><p>从 Nacos 官方获取 SQL 脚本，并复制到容器中执行。</p><blockquote><p>（获取方式是通过release拿到发布的zip压缩文件，找到里面数据库的sql脚本）</p><p>这个脚本一定要根据nacos对应版本来拿，我拿到的叫<code>mysql-schema.sql</code>，所以下面指令也要把nacos-mysql.sql这个名字改一下</p><p>文件内容为（或者直接用下面内容创建一个sql脚本文件）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info                  */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;configuration description&#x27;</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;configuration usage&#x27;</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置生效的描述&#x27;</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置的类型&#x27;</span>,</span><br><span class="line">  `c_schema` text COMMENT <span class="string">&#x27;配置的模式&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr             */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta             */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag              */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation         */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;nid, 自增长标识&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity               */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info              */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;nid, 自增标识&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;operation type&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">   `encrypted_data_key` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity              */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span> COMMENT <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;enabled&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;role&#x27;</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;role&#x27;</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;resource&#x27;</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;action&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote></li><li><p>如何将 SQL 脚本复制到容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地 nacos-mysql.sql 复制到容器内的 /tmp 目录</span></span><br><span class="line">docker <span class="built_in">cp</span> nacos-mysql.sql mysql-8.0.44:/tmp/</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 MySQL 容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql-8.0.44 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内登录 MySQL（账号 root，密码 123456）</span></span><br><span class="line">mysql -u root -p123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库（假设数据库名为 `nacos_config`，可根据需要修改）</span></span><br><span class="line">CREATE DATABASE IF NOT EXISTS `nacos_config` DEFAULT CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数据库并执行 SQL 脚本</span></span><br><span class="line">USE `nacos_config`;</span><br><span class="line">SOURCE /tmp/nacos-mysql.sql;  <span class="comment"># 需先将脚本文件复制到容器内</span></span><br></pre></td></tr></table></figure></li><li><p>再次启动nacos</p><ul><li><p><strong>网络配置</strong>：确保 Nacos 容器与 MySQL 容器在同一个 Docker 网络中（默认 bridge 网络可通过容器名通信）。</p></li><li><p><strong>环境变量</strong>：</p><ul><li><code>MYSQL_SERVICE_HOST</code> 改为 MySQL 容器名 <code>mysql-8.0.44</code>。</li><li>数据库名、用户名、密码根据你的配置调整（此处假设数据库名为 <code>nacos_config</code>，用户为 <code>root</code>，密码为 <code>123456</code>）。</li></ul></li><li><p><strong>卷挂载路径</strong>：使用 Linux 风格的路径（Docker Desktop 支持），将 <code>E:\</code> 转换为 <code>/e/</code>。</p></li><li><pre><code class="language-bash">docker run -d --name nacos --network nacos-network -p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql -e MYSQL_SERVICE_HOST=mysql-8.0.44 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=nacos_config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=123456 -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot; -v /e/develop_tools/Docker_data/nacos-2.4.1/nacos/logs:/home/nacos/logs -v /e/develop_tools/Docker_data/nacos-2.4.1/nacos/conf:/home/nacos/conf --restart=always nacos/nacos-server:v2.4.1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 1. 创建自定义网络</span><br><span class="line">docker network create nacos-network</span><br><span class="line"></span><br><span class="line"># 2. 将MySQL容器连接到自定义网络</span><br><span class="line">docker network connect nacos-network mysql-8.0.44</span><br><span class="line"></span><br><span class="line"># 3. 启动Nacos时也使用这个网络</span><br><span class="line">docker run -d \</span><br><span class="line">  --name nacos \</span><br><span class="line">  --network nacos-network \</span><br><span class="line">  -p 8848:8848 \</span><br><span class="line">  -p 9848:9848 \</span><br><span class="line">  -p 9849:9849 \</span><br><span class="line">  --privileged=true \</span><br><span class="line">  -e JVM_XMS=256m \</span><br><span class="line">  -e JVM_XMX=256m \</span><br><span class="line">  -e MODE=standalone \</span><br><span class="line">  -e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">  -e MYSQL_SERVICE_HOST=mysql-8.0.44 \</span><br><span class="line">  -e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">  -e MYSQL_SERVICE_DB_NAME=nacos_config \</span><br><span class="line">  -e MYSQL_SERVICE_USER=root \</span><br><span class="line">  -e MYSQL_SERVICE_PASSWORD=123456 \</span><br><span class="line">  -e MYSQL_SERVICE_DB_PARAM=&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot; \</span><br><span class="line">  -v /e/develop_tools/Docker_data/nacos-2.4.1/nacos/logs:/home/nacos/logs \</span><br><span class="line">  -v /e/develop_tools/Docker_data/nacos-2.4.1/nacos/conf:/home/nacos/conf \</span><br><span class="line">  --restart=always \</span><br><span class="line">  nacos/nacos-server:v2.4.1</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>修改配置文件</p><ul><li>在 Windows 宿主机上修改 <code>E:\develop_tools\Docker_data\nacos-2.4.1\nacos\conf\application.properties</code>。</li><li>将数据库连接地址改为 MySQL 容器名 <code>mysql-8.0.44</code>。</li></ul><p>用文本编辑器打开文件，修改以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://mysql-8.0.44:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=30000&amp;autoReconnect=<span class="literal">true</span>&amp;useUnicode=<span class="literal">true</span>&amp;useSSL=<span class="literal">false</span>&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=123456</span><br></pre></td></tr></table></figure><p>文件修改内容（对应自己的mysql）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://localhost:3306/nacos-config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=30000&amp;autoReconnect=<span class="literal">true</span>&amp;useUnicode=<span class="literal">true</span>&amp;useSSL=<span class="literal">false</span>&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=root</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="关键注意事项：">关键注意事项：</h2><ol><li><p><strong>Docker 网络</strong>：确保 Nacos 和 MySQL 容器在同一个网络（默认 bridge 网络即可通过容器名通信）。</p></li><li><p><strong>卷挂载路径</strong>：在 Docker 命令中，Windows 路径需转换为 Linux 风格（如 <code>E:\</code> → <code>/e/</code>）。</p></li><li><p><strong>MySQL 连接</strong>：使用容器名 <code>mysql-8.0.44</code> 作为主机名，而不是 <code>localhost</code> 或 IP。</p></li><li><p><strong>数据库名</strong>：请确保与步骤 4 中创建的数据库名一致（此处示例为 <code>nacos_config</code>）。</p></li><li><p>windows宿主机访问： <code>http://localhost:8848/nacos</code> 即可进入 Nacos 控制台（默认账号/密码：<code>nacos/nacos</code>）。</p></li></ol><h2 id="报错问题：">报错问题：</h2><img src="https://blogs.muxueavid.top/blogs/2025/11/20251109190639222.png" alt="image-20251103114939619" style="zoom: 80%;" /><p>也就是有<code>Public Key Retrieval is not allowed</code>这一句报错</p><p>这个错误是由于 MySQL 连接问题导致的，具体是 <strong>“Public Key Retrieval is not allowed”</strong> 错误。这通常发生在 MySQL 8.0+ 版本中，与身份验证插件和 SSL 配置有关。</p><p>也就是nacos在启动时，必须要加上这一个参数，其中包含了<code>allowPublicKeyRetrieval=true</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e MYSQL_SERVICE_DB_PARAM=<span class="string">&quot;characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJO、PO、DTO、VO、DAO、Entity、Model的区别</title>
      <link href="/2025/11/09/other/POJO%E3%80%81PO%E3%80%81DTO%E3%80%81VO%E3%80%81DAO%E3%80%81Entity%E3%80%81Model%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/11/09/other/POJO%E3%80%81PO%E3%80%81DTO%E3%80%81VO%E3%80%81DAO%E3%80%81Entity%E3%80%81Model%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1>POJO、PO、DTO、VO、DAO、Entity、Model的区别</h1><ol><li><p>POJO</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pure old java object </span><br><span class="line">简单的Java对象或者无规则简单java对象，但是和JavaBean的不同是没有业务逻辑</span><br><span class="line">一个中间对象，可以转化为PO、DTO、VO。</span><br><span class="line">1.POJO持久化之后--&gt;PO</span><br><span class="line">2.POJO传输过程中--&gt;DTO</span><br><span class="line">3.POJO用作表示层--&gt;VO</span><br><span class="line">PO 和VO都应该属于它。</span><br></pre></td></tr></table></figure></li><li><p>PO</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">persistent object</span><br><span class="line">持久对象，可以用来对照数据库中的一条记录</span><br></pre></td></tr></table></figure></li><li><p>DTO</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也叫TO，Data Transfer Object数据传输对象</span><br><span class="line">1.用在需要跨进程或远程传输时，它不应该包含业务逻辑。</span><br><span class="line">2.比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</span><br></pre></td></tr></table></figure></li><li><p>VO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value object值对象 / view object表现层对象</span><br><span class="line">1.主要对应页面显示（web页面/swt、swing界面）的数据对象。</span><br><span class="line">2.可以和表对应，也可以不，这根据业务的需要。</span><br><span class="line">注 ：在struts中，用ActionForm做VO，需要做一个转换，因为PO是面向对象的，而ActionForm是和view对应的，要将几个PO要显示的属性合成一个ActionForm，可以使用BeanUtils的copy方法。</span><br></pre></td></tr></table></figure></li><li><p>DAO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data access object数据访问对象</span><br><span class="line">1.主要用来封装对DB的访问（CRUD操作）。</span><br><span class="line">2.通过接收Business层的数据，把POJO持久化为PO。</span><br></pre></td></tr></table></figure></li><li><p>Entity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个最容易理解，其特点是：数据表对应到实体类的映射</span><br></pre></td></tr></table></figure></li><li><p>Model</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model是MVC中一个概念，可能不和Entity一一对应，因为展示在View层中数据可能是一个Entity的精简，也可能是多个Entity的组合。一句话概括：Model是一个高度优化组合或者精简后的一个用于在View层展示数据的对象。</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wrk快速上手</title>
      <link href="/2025/11/04/other/wrk%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2025/11/04/other/wrk%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1>wrk快速上手</h1><blockquote><p>1min看完就能上手！</p></blockquote><p>一句话介绍：wrk 是一个<strong>现代化的 HTTP 基准测试工具</strong>，它能够在单核 CPU 上以较少的线程产生强大的负载。</p><p>说白了是一个简单易用的接口性能测试工具，对开发人员（非运维）来说上手成本低，几乎零学习成本。</p><p>另外wrk是在linux环境下使用的，所以windows平台测试使用的话使用docker。</p><h2 id="Linux环境使用wrk">Linux环境使用wrk</h2><p>这种教程很多，例如<a href="https://www.cnblogs.com/quanxiaoha/p/10661650.html">性能测试工具wrk教程</a>。</p><h2 id="Docker中使用wrk">Docker中使用wrk</h2><p>演示的宿主机为windows。</p><p>使用的容器仓库<a href="https://github.com/William-Yeh/docker-wrk?tab=readme-ov-file">github地址</a>。</p><p>加上<code>--rm</code>，用完即删，是因为这个容器仅仅用于临时的简单测试，不会占空间。</p><blockquote><p>执行run语句时本地若无镜像则自动会pull。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> ghcr.io/william-yeh/wrk <span class="comment"># 首次运行测试</span></span><br><span class="line"></span><br><span class="line">docker run --<span class="built_in">rm</span> ghcr.io/william-yeh/wrk -t&lt;线程数&gt; -c&lt;并发量&gt; -d&lt;时间&gt; --latency &lt;接口地址&gt; <span class="comment"># 模板1 </span></span><br><span class="line"></span><br><span class="line">docker run --<span class="built_in">rm</span> -v &lt;宿主机上.lua脚本路径&gt;:&lt;容器内映射.lua文件&gt; ghcr.io/william-yeh/wrk -t&lt;线程数&gt; -c&lt;线程数&gt; -d&lt;时间&gt; -s &lt;容器内.lua文件&gt; --latency &lt;接口地址&gt;</span><br></pre></td></tr></table></figure><p>e.g.1，表示使用8个线程、并发量200，对百度进行8s的压测。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> ghcr.io/william-yeh/wrk -t8 -c200 -d10s --latency http://www.baidu.com</span><br></pre></td></tr></table></figure><p>e.g.2，路径写法是linux风格的、windows也可改为对应风格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v $(<span class="built_in">pwd</span>)/test.lua:/data/test.lua ghcr.io/william-yeh/wrk -t8 -c200 -d10s -s /data/test.lua --latency http://www.baidu.com</span><br></pre></td></tr></table></figure><p>e.g.3，注意要测试宿主机（是Windows或macOS）的<code>127.0.0.1</code>时，要使用特殊的 DNS 名称<code>host.docker.internal</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v E:\Project\java\test-project\wrkbench\test.lua:/data/test.lua ghcr.io/william-yeh/wrk -t50 -c200 -d30s -s /data/test.lua --latency http://host.docker.internal:8085/example/hello</span><br></pre></td></tr></table></figure><p>ok你现在已经会举一反三了。</p><h2 id="结果说明">结果说明</h2><p>压测百度的结果：</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251104161928301.png" alt="image-20251104145550455" style="zoom: 80%;" /><p>结果说明：</p><p>可以看到最后每秒吞吐量约为215.20</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251104161928303.png" alt="image-20251104145834544" style="zoom:95%;" /><p>Latency：延迟。Req/Sec：每秒请求数。Stdev为标准差。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251104161928304.png" alt="image-20251104150326968"></p><p>Latency Distribution：分位延迟。可以理解为90%的请求能在390ms内，99%的请求再1.24s以内。</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251104161928305.png" alt="image-20251104150434335" style="zoom:95%;" /><p>可见错误0个，超时158个。</p><p>这里最后的Requests/sec是指所有线程的情况，所以和之前的Req/Sec数据不一样。</p><h2 id="注意事项">注意事项</h2><p>压测结果与机器性能有关！</p><p>无法模拟一个接口的极限情况（因为一台机器压测力度有限）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> wrk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker快速上手</title>
      <link href="/2025/11/02/other/Docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2025/11/02/other/Docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1>Docker快速上手</h1><blockquote><p>感谢<a href="https://www.bilibili.com/video/BV14s4y1i7Vf?spm_id_from=333.788.videopod.sections&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=2">b站视频教程</a>，以下为文字梳理版。</p></blockquote><h2 id="Docker-简介">Docker 简介</h2><p><strong>what is it？</strong></p><p>Docker是一个用于构建（build）、运行（run）、传送（share） 应用程序的平台。</p><p><strong>why we need it？</strong></p><p>简化环境配置，相同的环境不用多次配置。例如前端Vue、后端SpringBoot、数据库MySQL的一个项目，你需要安装NodeJS环境、安装各种npm依赖、安装Java运行时环境、安装各种第三方依赖（maven）、安装MySQL数据库、Vue环境配置+启动脚本、安装配置Redis、安装配置Nginx……等</p><p>而这样的操作不仅开发环境需要配置一遍、生产环境、测试环境都要配置一遍。而Docker就是将这些环境打包好后，之后都可以使用。</p><p><strong>Docker vs 虚拟机</strong></p><p>虚拟机：</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102235635408.png" alt="image-20251102165759490"  /><p>Docker：</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102235635409.png" alt="image-20251102170109835"  /><p>Docker与虚拟机不同，每个容器共用一个操作系统，因此启动速度更快、更加轻量。</p><h2 id="Docker-基本原理和概念">Docker 基本原理和概念</h2><ul><li><strong>镜像</strong>：镜像是一个可读的模板，它可以用来创建容器。</li><li><strong>容器</strong>：容器是Docker的运行实例，它提供了一个可移植的环境，可以在这个环境中运行应用程序。</li></ul><blockquote><p>镜像和容器的关系就像Java中类和实例的关系。</p></blockquote><ul><li><strong>仓库</strong>：Docker是用来存储Docker镜像的地方，最流行的仓库为Dockerhub，在这里可以分享或下载镜像。</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102235635410.png" alt="image-20251102170207061"  /><h2 id="Docker-安装配置">Docker 安装配置</h2><blockquote><p><a href="https://www.bilibili.com/video/BV14s4y1i7Vf?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=5">视频教程</a></p></blockquote><p>官网下载，windows平台注意开启wsl相关配置。</p><h2 id="容器化-和-Dockerfile">容器化 和 Dockerfile</h2><p><strong>容器化</strong>：</p><ol><li>创建一个Dockerfile</li><li>使用Dockerfile构建镜像</li><li>使用镜像创建和运行容器</li></ol><p><strong>Dockerfile</strong>：</p><p>Dockerfile是一个文本文件，里面包含了一条条的指令，用来告诉Docker如何来构建镜像，这个镜像中包含了应用程序执行的所有命令——即各种依赖、配置环境和运行应用程序所需要的所有内容（精简版的操作系统、应用程序的运行时环境、应用程序、应用程序的第三方依赖库或者包、应用程序的配置文件环境变量等等）。一般我们会在项目的根目录下创建一个叫Dockerfile的文件。</p><blockquote><p>一般想要运行一个项目，拿到Dockerfile文件-&gt;docker build -&gt; docker run [镜像] 运行即可。（重点是拿到镜像）</p></blockquote><h2 id="Docker-命令查询手册">Docker 命令查询手册</h2><blockquote><p>注意子序列为例子e.g.</p></blockquote><h3 id="服务管理">服务管理</h3><blockquote><p>具体Linux版本有关（不一定通用）</p></blockquote><ul><li>docker version 查看docker版本详细信息</li><li>docker -v 查看docker简要信息</li><li>systemctl start docker 启动docker</li><li>ststemctl stop docker 关闭docker</li><li>systemctl enable docker 设置开启启动</li><li>service docker restart 重启docker服务</li><li>service docker stop 关闭docker服务</li></ul><h3 id="镜像管理">镜像管理</h3><ul><li>docker image ls 或 docker images 查看镜像</li><li>docker search [image] 检索镜像<ul><li>docker search nginx</li></ul></li><li>docker pull [image] 拉取镜像</li><li>docker push [image] 上传镜像<ul><li>docker push muxueavid/hello-docker:latest</li></ul></li><li>docker save [image] -o FILE 或 docker save [image] &gt; FILE 保存镜像<ul><li>docker save muxueavid/hello-docker:latest &gt; hello-docker.tar</li></ul></li><li>docker load -i FILE 导入镜像<ul><li>docker load -i hello-docker.tar</li></ul></li><li>docker history [image] 查看镜像历史</li><li>docker rmi [image] 或 docker image rm [image] 删除镜像</li><li>docker image prune 删除不再使⽤的镜像</li><li>docker import [URL/FILE] 将⽂件系统导⼊为镜像</li><li>docker commit [container] [image] 从容器创建镜像</li></ul><h3 id="容器管理">容器管理</h3><ul><li>docker create [image] 创建容器（仅创建，不运⾏）</li><li>docker run [image] 创建并运⾏容器</li><li>docker start [container] 启动容器</li><li>docker stop [container] 停⽌容器</li><li>docker restart [container] 重启容器</li><li>docker ps 或 docker container ls 列出正在运⾏的容器</li><li>docker ps -a 或 docker container ls -a 列出所有容器</li><li>docker exec -it [container] bash 或 docker attach [container] 以交互模式进⼊容器</li><li>docker export [container] -o FILE 或 docker export [container] &gt; FILE 导出容器</li><li>docker import FILE 导⼊容器快照</li><li>docker logs [container] 查看容器⽇志</li><li>docker rm [container] 或 docker container rm [container] 删除容器</li><li>docker port [container] 查看容器端⼝映射</li><li>docker top [container] 显示容器内进程</li><li>docker cp [FILE] [container]:[PATH] 复制本地⽂件到容器内的指定路径</li><li>docker diff [container] 显示容器内的变化</li><li>docker stats [container] 显示容器资源使⽤情况</li></ul><h3 id="容器运行">容器运行</h3><blockquote><p>语法格式：docker run [options] image [command] [arg…]</p></blockquote><ul><li>docker run --name [name] [image] 创建 运⾏并命名容器</li><li>docker run -d [image] 创建⼀个容器并后台运⾏</li><li>docker run -p [hostPort]:[containerPort] [image] 创建⼀个容器并指定端⼝映射</li><li>docker run -P [image] 创建⼀个容器并指定端⼝映射（随机分配）</li><li>docker run -e [key=value] [image] 创建⼀个容器并指定环境变量</li><li>docker run -w [PATH] [image] 创建⼀个容器并指定⼯作⽬录</li><li>docker run -name [name] [image] 创建⼀个容器并指定容器名称</li><li>docker run [image] [command] 创建⼀个容器并在容器中执⾏命令（交互模式）</li><li>docker run -d -p [hostPort]:[containerPort] -e [key=value] -w [PATH] --name [name] [image] 创建⼀个容器，并指定容器名称、后台运⾏、端⼝映射、环境变量和⼯作⽬录<ul><li>docker run -it nginx:latest /bin/bash 使⽤镜像nginx:latest来启动⼀个容器，并在容器内执⾏交互式bash shell</li><li>docker run -it -p 3316:3306 -v /data:/data -d mysql:latest 创建⼀个mysql容器，后台模式启动，主机3316端⼝映射到容器3306端⼝，主机/data⽬录映射到容器/data⽬录</li></ul></li></ul><h3 id="网络管理">网络管理</h3><ul><li>docker network ls 列出可⽤⽹络</li><li>docker network inspect [network] 查看⽹络详细信息</li><li>docker network create [network] 创建⼀个新的⽹络</li><li>docker network rm [network] 删除⼀个⽹络</li><li>docker network connect [network] [container] 将容器连接到⽹络</li><li>docker network disconnect [network] [container] 将容器从⽹络断开</li></ul><h3 id="数据卷管理">数据卷管理</h3><ul><li>docker volume create [volume] 创建⼀个数据</li><li>docker volume ls 查看数据卷</li><li>docker volume inspect [volume] 查看数据卷详细信息</li><li>docker volume rm [volume] 删除数据卷</li><li>docker volume prune 删除所有未使⽤的数据卷</li></ul><h3 id="插件管理">插件管理</h3><ul><li>docker plugin ls 列出插件</li><li>docker plugin install [plugin] 安装插件</li><li>docker plugin enable [plugin] 启⽤插件</li><li>docker plugin disable [plugin] 禁⽤插件</li><li>docker plugin rm [plugin] 卸载插件</li></ul><h3 id="日常操作">日常操作</h3><ul><li>docker info 查看系统信息</li><li>docker version 查看版本</li><li>docker --help 查看帮助文档</li><li>docker [command] --help 查看命令帮助</li><li>docker login 登陆</li><li>docker logout 退出</li></ul><h3 id="常用Dockerfile指令">常用Dockerfile指令</h3><ul><li>FROM [base_image] 指定基础镜像，必须为Dockerfile的第一条指令</li><li>ADD 用于将文件赋值到镜像中，源可以试URL或者本地文件，也可以是一个压缩文件（自动解压）</li><li>COPY [–chown=<user>:<group>] [源路径] [⽬标路径] 用于将文件拷贝到镜像中，源只能是本地文件</li><li>WORKDIR [PATH] 用于指定工作目录，可以使用多个WORKDIR指令，如果使用相对路径，则是相对于上一条WORKDIR指令所指定的目录</li><li>ENV <key> <value>  或 ENV <key1>=<value1> <key2>=<value2>… 用于设置环境变量</li><li>CMD &lt;命令&gt; 或 CMD [“可执行文件”,“参数1”,“参数2”,…] 用于指定默认的容器主进程，每个Dockerfile中只能有一条CMD指令，如果有多条，则只有最后一条会生效</li><li>VOLUME &lt;路径&gt; 或 VOLUME [“路径1”,“路径2”,…] 用于定义匿名卷（持久化目录）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher算法</title>
      <link href="/2025/11/01/algorithm/other/Manacher%E7%AE%97%E6%B3%95/"/>
      <url>/2025/11/01/algorithm/other/Manacher%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>Manacher算法</h1><blockquote><p>该算法用于解决“最长回文子串”的问题</p><p>例题：<a href="https://leetcode.cn/problems/longest-palindromic-substring">5. 最长回文子串</a></p></blockquote><p>暴力来解题的话，一般时间复杂度是$O(n^2)$，使用中心扩展法或者二维动态规划</p><p>而Manacher算法能$以O(n)$的时间复杂度来解决这个问题。</p><blockquote><p>以下撰写内容参考自<a href="https://www.bilibili.com/video/BV1UcyYY4EnQ/">灵神b站视频讲解</a>，感谢灵神！</p></blockquote><p>为什么Manacher算法有这种魔力呢？关键在于它能**$O(1)$地判断任意子串是否回文**</p><p>比如：</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340788.png" alt="image-20251101235035918"  /><p>说明：每个字母下方数字表示<strong>以该字母为中心，所能得到的最长回文子串的长度</strong>，假设目前已经拿到了这些值，那么如何$O(1)$地向下判断剩余的字母（以他们为中心）呢？</p><p>比如如下红色框选了c b a b c ，那么这个子串的中心就是a，而a的长度是11（蓝色框），显然这个红色框是在蓝色框之内的，要是依次把红色框之外、蓝色框之内的d、a、b去掉，得到的c b a b c显然是回文的。</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340789.png" alt="image-20251101235614429"  /><p>又如下，要求右边c的最长回文子串长度，怎么利用之前已经求过的信息呢？</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340791.png" alt="image-20251102000040924"  /><p><strong>重点</strong>：想象有一面镜子，以a为中心，那么下标为8位置的c的镜像位置的c’就是下标为5的这个。下标为5的这个c’的最长回文子串长度我们是知道的，是5，而这个长度对于下标位置为8的c来说<strong>没有超出蓝色盒子的右边界</strong>，所以以下标8位置为中心的最长回文子串长度就是5，省去了暴力做法（以它为中心，然后左右指针不断扩展……现在不需要了）。这就是算法的<strong>核心思想</strong>。</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340792.png" alt="image-20251102111654126"  /><p>对于下标为8的c，要比较7和9是否相同，等价于比较3和5是否相同；要比较6和10是否相同，等价于比较2和6是否相同。但是7和9，6和10都不需要比较，因为8的镜像位置是4，而4已经告诉我们了。</p><p>但是如果出界（出了蓝色盒子右边界<strong>boxR</strong>）</p><p>这里贴出对应这一思想的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;halfLen.length;i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; boxR)&#123;</span><br><span class="line">        <span class="comment">//这个if语句就是关键代码（删去后就变成O(n^2)复杂度）</span></span><br><span class="line">        hl = Math.min(halfLen[boxM*<span class="number">2</span>-i],boxR-i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力扩展</span></span><br><span class="line">    <span class="keyword">while</span>(t[i-hl] == t[i+hl])&#123;</span><br><span class="line">        hl++;</span><br><span class="line">        boxM = i;</span><br><span class="line">        boxR = i+hl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    halfLen[i] = hl;</span><br><span class="line">    <span class="keyword">if</span>(hl &gt; halfLen[maxI])&#123;</span><br><span class="line">        maxI = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现算法，还有其他问题要解决，那就是偶数串的回文中心怎么办？总不能夹在两个字母中间。也有比较好的方法：</p><p>那就是原先的字符串s每两个中间插入一个’#‘转变为新字符串t，但是前后都要加’#'且最前和最后还要加入两个不同的字符（用于防止下标出界）</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340793.png" alt="image-20251102113020080"></p><p>最左边加’^‘最右边加’$‘是因为这两个字符与其他字符均不同，所以在进行扩展时<code>while(s[i]==s[j])</code>判断时，肯定不会使得i或者j出界。起到了哨兵的作用。而中间’#‘的插入，使得当’#'作为子串中心点时，相当于原字符串是以偶字符串在进行扩展；当以字母为中心点时，相当于原字符串是以奇字符串在进行扩展。</p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102114340794.png" alt="image-20251102113544263" style="zoom: 90%;" /><p>定义<code>halfLen[i]</code>：例如c下面的5，代表的是扩展后的字符串t，以c为中心点时，<strong>最长回文子串的长度的一半</strong>（包括c自身）</p><p>那么原字符串s和新字符串t的对应关系呢？试着举个简单例子推导一下：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102115200061.png" alt="image-20251102115008245"></p><p>所以有公式$i_t = 2*i_s + 2$。故$i_s = \frac{i_t-2}{2}$</p><p><img src="https://blogs.muxueavid.top/blogs/2025/11/20251102115903889.png" alt="image-20251102115326582"></p><p>解释：当我们要判断$s[L,R]$区间是否为回文串时，对应的就是判断$t[2L+2,2R+2]$区间是否是回文串，那么t的这个区间的中心点就是$\frac{2L+2R+4}{2}=L+r+2$，因此只需要看$halfLen[L+R+2]$的值就可以了。</p><p>剩下的需要仔细看代码怎么写的，懂了大体思路看代码会容易些：</p><blockquote><p>下面直接使用灵神代码</p><p>作者：灵茶山艾府<br>链接：<a href="https://leetcode.cn/problems/longest-palindromic-substring/solutions/2958179/mo-ban-on-manacher-suan-fa-pythonjavacgo-t6cx/">https://leetcode.cn/problems/longest-palindromic-substring/solutions/2958179/mo-ban-on-manacher-suan-fa-pythonjavacgo-t6cx/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// Manacher 模板</span></span><br><span class="line">        <span class="comment">// 将 s 改造为 t，这样就不需要讨论 len(s) 的奇偶性，因为新串 t 的每个回文子串都是奇回文串（都有回文中心）</span></span><br><span class="line">        <span class="comment">// s 和 t 的下标转换关系：</span></span><br><span class="line">        <span class="comment">// (si+1)*2 = ti</span></span><br><span class="line">        <span class="comment">// ti/2-1 = si</span></span><br><span class="line">        <span class="comment">// ti 为偶数，对应奇回文串（从 2 开始）</span></span><br><span class="line">        <span class="comment">// ti 为奇数，对应偶回文串（从 3 开始）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] t = <span class="keyword">new</span> <span class="title class_">char</span>[n * <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line">        Arrays.fill(t, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        t[<span class="number">0</span>] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            t[i * <span class="number">2</span> + <span class="number">2</span>] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个奇回文串的回文半径=(长度+1)/2，即保留回文中心，去掉一侧后的剩余字符串的长度</span></span><br><span class="line">        <span class="comment">// halfLen[i] 表示在 t 上的以 t[i] 为回文中心的最长回文子串的回文半径</span></span><br><span class="line">        <span class="comment">// 即 [i-halfLen[i]+1,i+halfLen[i]-1] 是 t 上的一个回文子串</span></span><br><span class="line">        <span class="type">int</span>[] halfLen = <span class="keyword">new</span> <span class="title class_">int</span>[t.length - <span class="number">2</span>];</span><br><span class="line">        halfLen[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maxI 记录最长回文子串在 halfLen 中的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxI</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// boxR 表示当前右边界下标最大的回文子串的右边界下标+1</span></span><br><span class="line">        <span class="comment">// boxM 为该回文子串的中心位置，二者的关系为 r=mid+halfLen[mid]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">boxM</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">boxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; halfLen.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; boxR) &#123;</span><br><span class="line">                <span class="comment">// 记 i 关于 boxM 的对称位置 i&#x27;=boxM*2-i</span></span><br><span class="line">                <span class="comment">// 若以 i&#x27; 为中心的最长回文子串范围超出了以 boxM 为中心的回文串的范围（即 i+halfLen[i&#x27;] &gt;= boxR）</span></span><br><span class="line">                <span class="comment">// 则 halfLen[i] 应先初始化为已知的回文半径 boxR-i，然后再继续暴力匹配</span></span><br><span class="line">                <span class="comment">// 否则 halfLen[i] 与 halfLen[i&#x27;] 相等</span></span><br><span class="line">                hl = Math.min(halfLen[boxM * <span class="number">2</span> - i], boxR - i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暴力扩展</span></span><br><span class="line">            <span class="keyword">while</span> (t[i - hl] == t[i + hl]) &#123;</span><br><span class="line">                hl++;</span><br><span class="line">                boxM = i;</span><br><span class="line">                boxR = i + hl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            halfLen[i] = hl;</span><br><span class="line">            <span class="keyword">if</span> (hl &gt; halfLen[maxI]) &#123;</span><br><span class="line">                maxI = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> halfLen[maxI];</span><br><span class="line">        <span class="comment">// 注意 t 上的最长回文子串的最左边和最右边都是 &#x27;#&#x27;</span></span><br><span class="line">        <span class="comment">// 所以要对应到 s，最长回文子串的下标是从 (maxI-hl)/2 到 (maxI+hl)/2-2</span></span><br><span class="line">        <span class="keyword">return</span> s.substring((maxI - hl) / <span class="number">2</span>, (maxI + hl) / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习笔记--初版大杂烩</title>
      <link href="/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<h1>JVM运行的整体流程</h1><blockquote><p>笔记：依据<a href="https://www.bilibili.com/video/BV1PJ411n7xZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d">视频教程</a>学习后，纯看配图，使用的个人语言的书写（有水印的配图进行了自己绘制）</p><p>目前版本：1.0</p></blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516201106780.jpg" style="zoom:67%;" /><p>宏观来看，JVM的不同操作系统的实现，使得Java经过一次编译后的.class字节码文件，能够在不同的平台上运行</p><p>印证了流程很广泛的一句话——“一次编译，处处运行”</p><p>其实不仅仅是Java语言，其他的语言，只要仅编译器编译后符合JVM所定义的字节码文件的格式规范，就能在Java虚拟机上运行：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516201832202.jpg" style="zoom:67%;" /><p><strong>JVM的作用</strong></p><p>Java虚拟机就是二进制字节码文件的<strong>运行时环境</strong>，负责装载字节码到其内部，解释or编译为对应操作系统平台的机器指令执行。</p><p><strong>JVM架构图</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516202357582.jpg" style="zoom: 67%;" /><p>注：此图非常重要，要非常熟悉。</p><p>上图较为简易的描述了JVM的工作流程：</p><ol><li>从一个class字节码文件开始</li><li>首先经过类加载子系统的加载</li><li>然后把加载后的信息保存进入运行时数据区</li><li>运行时数据区的内存结构划分为不同的结构——方法区用于存放类的方法信息；堆中主要用于保存对象、字符串常量等信息；程序计数器仅用于保存程序要执行的下一条指令信息；本地方法栈中保存的是一些Java的核心类库的实现（一般用C/C++实现）；虚拟机栈中是一个个栈帧，栈帧保存了当前执行方法的所需信息（比如使用到的对象的引用、基本数据类型的值、String的引用）。</li><li>执行引擎负责具体的执行过程；本地方法接口从本地方法库加载方法的实现、然后被本地方法栈调用。</li></ol><blockquote><p>ps：描述不一定准确</p></blockquote><p>更加详细的架构图如下，可供复习使用：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516205131610.jpg" style="zoom: 67%;" /><p><strong>JVM架构模型</strong></p><p>JVM是<strong>基于栈的架构模型</strong>，不妨与另一种（<strong>基于寄存器的架构模型</strong>）进行对比，来说明其特点。</p><p>栈这种结构，联系数据结构与算法所学的知识，无非“进栈”、“出栈”、“后进先出”等特点</p><p>那么基于这些特点，其每一条指令就非常小，因为无需指定指令所对应的位置（因为对栈的操作就是在栈顶）；而基于寄存器的，每一条指令就显得长一些，因为它不光要指出指令的具体操作，还要明确操作的位置。举个简单例子：</p><p>同样执行2+3，基于栈架构所用指令（JVM为例）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>基于寄存器架构（80x86汇编语言举例）举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">2</span> <span class="comment">//将ax寄存器的值设为1</span></span><br><span class="line">add ax,<span class="number">3</span> <span class="comment">//使ax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p>可见，基于栈架构的所用指令数量会更多，即使其每一条指令很简单</p><p>那么JVM为什么要采用栈的架构呢？总结如下：</p><ol><li>基于栈架构，<strong>跨平台性更好</strong>。因为不同平台CPU架构不同，所以不能用基于寄存器架构的</li><li>虽然经过汇编后，相比于寄存器架构方式指令更多、运行效率更低，但是考虑到跨平台性和可移植性，JVM选择了栈架构的设计</li></ol><h1>类加载子系统（Class Loader SubSystem）</h1><h2 id="总括：Class-Loader-SubSystem的作用">总括：Class Loader SubSystem的作用</h2><p>类加载子系统只负责将class文件中的类的信息加载到JVM中，<strong>加载的类信息存放于一块称为方法区的内存空间</strong>，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p>它起了一个<strong>创造模板</strong>的作用，详细些：class文件中存储了一些类的模板信息（比如定义了哪些字段、有哪些方法、实现了哪些接口、父类是谁等），然后类加载子系统把这些模板的信息读取进来（到JVM中）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516211557952.png" style="zoom:67%;" /><p>这些“模板信息”存放于方法区中（JDK8前叫做永久代，在堆中；JDK8后改为云空间，在系统内存中）</p><h2 id="类加载过程">类加载过程</h2><img src="https://blogs.muxueavid.top/blogs/2025/05/20250516213120744.png" style="zoom:67%;" /><h3 id="1-加载（Loading）">1 加载（Loading）</h3><blockquote><p>非自己语言</p></blockquote><p><strong>加载：</strong></p><ol><li><p>通过一个类的<strong>全限定名</strong>获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="2-链接（Linking）">2 链接（Linking）</h3><blockquote><p>非自己语言</p></blockquote><p>分为三个子阶段：验证、准备、解析</p><h4 id="2-1-验证（Verification）">2.1 验证（Verification）</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求（e.g.开头的：<strong>CAFEBABE</strong>），保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><h4 id="2-2-准备（Preparation）">2.2 准备（Preparation）</h4><ol><li>为<strong>类变量</strong>（<strong>static变量</strong>）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-解析（Resolution）">2.3 解析（Resolution）</h4><ol><li><p><strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p><strong>符号引用</strong>就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><h3 id="3-初始化（Initialization）">3 初始化（Initialization）</h3><blockquote><p>即<clinit>方法的调用——在此时发生</p></blockquote><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.yukino.User”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h2 id="类加载器分类">类加载器分类</h2><blockquote><p>非自己语言</p></blockquote><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517122036577.png" style="zoom: 80%;" /><h3 id="JDK1-8中源码继承关系图">JDK1.8中源码继承关系图</h3><p><strong>ExtClassLoader</strong>（<strong>Launcher内部类</strong>）——扩展类加载器</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517122512461.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器（也成系统类加载器）</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517122710042.png" alt=""></p><h3 id="JDK1-9及之后的">JDK1.9及之后的</h3><blockquote><p>注意继承于<strong>BuiltinClassLoader</strong>了，不再是<strong>URLClassLoader</strong></p></blockquote><p><strong>PlatformClassLoader（Launcher内部类）</strong>——平台类加载器</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517123421236.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517123544208.png" alt=""></p><h3 id="虚拟机自带的加载器">虚拟机自带的加载器</h3><blockquote><p>非自己语言</p></blockquote><h4 id="启动类加载器">启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器">扩展类加载器</h4><blockquote><p><strong>扩展类加载器（ExtClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器">系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><h3 id="用户自定义类加载器">用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？">什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li><strong>隔离加载类</strong>（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架、中间件之间是隔离的）</li><li><strong>修改类加载的方式</strong></li><li><strong>扩展加载源</strong>（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li><strong>防止源码泄漏</strong>（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？">如何自定义类加载器？</h4><ol><li>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findclass()</code>方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写<code>findclass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="关于ClassLoader">关于ClassLoader</h2><p>ClassLoader是一个抽象类，其后所有的类加载器都继承自ClassLoader（JDK8的启动类加载器除外）</p><p>（JDK9之后的BootClassLoader又间接继承与ClassLoader了）</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517185020815.png" alt=""></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>defineClass(String name,byte[] b,int off, int len)</td><td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的示例</td></tr><tr><td>resolveClass(Class&lt;?&gt; e)</td><td>连接指定的一个Java类</td></tr></tbody></table><p><strong>获取ClassLoader的途径</strong></p><table><thead><tr><th>获取当前类的ClassLoader</th><th>clazz.getClassLoader()</th></tr></thead><tbody><tr><td><strong>获取当前线程上下文的ClassLoader</strong></td><td>Thread.currentThread().getContextClassLoader()</td></tr><tr><td><strong>获取系统的ClassLoader</strong></td><td>ClassLoader.getSystemClassLoader()</td></tr><tr><td><strong>获取调用者的ClassLoader</strong></td><td>DriverManager.getCallerClassLoader()</td></tr></tbody></table><h2 id="双亲委派机制">双亲委派机制</h2><h3 id="双亲委派机制原理">双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517190508639.png" style="zoom:67%;" /><h3 id="双亲委派机制优势">双亲委派机制优势</h3><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制">沙箱安全机制</h2><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="如何判断两个class对象是否相同？">如何判断两个class对象是否相同？</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li><p><strong>类的全类名一致</strong></p></li><li><p><strong>加载这个类的ClassLoader实例对象一致</strong></p><blockquote><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p></blockquote></li></ol><h2 id="对类加载器的引用">对类加载器的引用</h2><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ol><h1>运行时数据区（Runtime Data Area）</h1><blockquote><p>通过之前的：类的加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，就会使用执行引擎对类进行使用，同时执行引擎还会使用到运行时数据区中的数据</p></blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517193445230.png" style="zoom:80%;" /><h2 id="概述">概述</h2><h3 id="运行时数据区与内存">运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><h3 id="JVM-线程">JVM 线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><p><strong>JVM 系统线程</strong></p><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括&quot;stop-the-world&quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h2 id="程序计数器（PC-Register）">程序计数器（PC Register）</h2><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517201638237.png" style="zoom:67%;" /><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><p><strong>PC寄存器的作用</strong>，一言以蔽之：</p><p>PC寄存器用来存储指向下一条指令的地址。由执行引擎读取下一条指令，并执行该指令。</p><h2 id="本地方法接口-本地方法库">本地方法接口+本地方法库</h2><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517202140204.png" style="zoom: 67%;" /><p>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong></p><p>因此，在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，初衷是融合C/C++程序。</p><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><strong>就是用于调用本地方法接口的</strong></p></blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250517202533710.png" style="zoom: 80%;" /><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><h2 id="虚拟机栈">虚拟机栈</h2><blockquote><p>栈管运行，堆管存储</p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p></blockquote><h3 id="虚拟机栈是什么？">虚拟机栈是什么？</h3><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518114956160.png" style="zoom:67%;" /><ul><li><p>虚拟机栈（VM Stack）。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p></li><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点">虚拟机栈的特点</h3><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518115530548.png" style="zoom:67%;" /><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><h3 id="虚拟机栈的异常">虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h2 id="栈的存储单位">栈的存储单位</h2><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518120415477.png" style="zoom:80%;" /><h3 id="栈中存储什么？">栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理">栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518120603099.png" style="zoom:67%;" /><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构">栈帧的内部结构</h3><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518120634048.png" style="zoom:67%;" /><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><h2 id="局部变量表">局部变量表</h2><h3 id="认识局部变量表">认识局部变量表</h3><h4 id="概念">概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h3 id="关于slot的理解">关于slot的理解</h3><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518121636958.png" style="zoom:67%;" /><blockquote><p>可见除double、long类型占2个slot外，其余类型均占1个slot</p></blockquote><h3 id="slot的重复利用">slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量<strong>过了其作用域</strong>，那么在其作用域之后申明新的局部变量变就很有可能会<strong>复用</strong>过期局部变量的槽位，从而达到节省资源的目的。</p><h3 id="静态变量与局部变量的对比">静态变量与局部变量的对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line">1、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line">2、按照在类中声明的位置分：</span><br><span class="line">  2-1、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明">补充说明</h3><ol><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h2 id="操作数栈">操作数栈</h2><h3 id="操作数栈的特点">操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><h3 id="操作数栈的作用">操作数栈的作用</h3><ol><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><h3 id="操作数栈字节码示例">操作数栈字节码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518123010951.png" style="zoom: 80%;" /><p>详细运行过程如下：</p><ol><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518123758242.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518123943672.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124040895.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124229041.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124327892.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124617207.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124744230.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518124859690.png" style="zoom:67%;" /></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518125044802.png" style="zoom:67%;" /></li></ol><h3 id="栈顶缓存技术">栈顶缓存技术</h3><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h3 id="动态链接">动态链接</h3><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p></li></ol><p><strong>符号引用</strong>，指向的为——方法名、方法参数、返回值类型等信息，而<strong>直接引用</strong>就是指向了实际要执行的方法信息（例如符号引用指向的是接口中定义的方法，然后直接引用就是指向其实现类的实现方法？）</p><p><strong>为什么要用常量池呢？</strong></p><ol><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h3 id="方法的调用">方法的调用</h3><h4 id="静态链接与动态链接">静态链接与动态链接</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="早期绑定与晚期绑定">早期绑定与晚期绑定</h4><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><h4 id="多态与绑定">多态与绑定</h4><ol><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol><h5 id="虚方法与非虚方法">虚方法与非虚方法</h5><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h5 id="关于-invokedynamic-指令">关于 invokedynamic 指令</h5><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><h5 id="动态语言和静态语言">动态语言和静态语言</h5><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java：String info = &quot;mogu blog&quot;;     (Java是静态类型语言的，会先编译就进行类型检查)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS：var name = &quot;shkstart&quot;;    var name = 10;（运行时才进行检查）   </span><br></pre></td></tr></table></figure><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h5 id="Java语言中方法重写的本质">Java语言中方法重写的本质</h5><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表">虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p></li></ol><p><strong>举例</strong></p><p>如下图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p>再比如：</p><ul><li><p>son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p></li><li><p>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p></li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250518131803931.png" style="zoom:67%;" /><h3 id="方法返回地址">方法返回地址</h3><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p><strong>正常退出</strong>：正常执行完成</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ul></li><li><p><strong>异常退出</strong>：出现未处理的异常，非正常退出</p><ul><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>，方便在发生异常的时候找到处理异常的代码</p><blockquote><p>异常处理表：</p></blockquote><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul></li></ul></li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><h3 id="一些附加信息">一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h3 id="栈相关面试题">栈相关面试题</h3><h4 id="举例栈溢出的情况？">举例栈溢出的情况？</h4><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h4 id="调整栈大小，就能保证不出现溢出么？">调整栈大小，就能保证不出现溢出么？</h4><p>不能保证不溢出，只能保证SOF出现的几率小</p><h4 id="分配的栈内存越大越好么？">分配的栈内存越大越好么？</h4><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h4 id="垃圾回收是否涉及到虚拟栈？">垃圾回收是否涉及到虚拟栈？</h4><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h4 id="方法中定义的局部变量是否线程安全？">方法中定义的局部变量是否线程安全？</h4><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>To Be Continue</h1>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>汇编语言</h1><h2 id="寄存器">寄存器</h2><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429230756497.png" style="zoom:80%;" /><blockquote><ol><li><p>对于8086、8088或80286，阴影区域是不可用的</p></li><li><p>FS和GS寄存器无专用名称</p></li></ol></blockquote><ol><li><p><strong>通用寄存器</strong></p><ul><li>数据寄存器：AX（accumulator）、BX（base）、CX（count）、DX（data）</li><li>指针寄存器：SP（stack pointer）、BP（base pointer）</li><li>变址寄存器：DI（destination index）、SI（source index）</li></ul></li><li><p><strong>控制寄存器</strong></p><ul><li>IP（instruction pointer）、FLAGS</li></ul></li><li><p><strong>段寄存器</strong></p><ul><li>CS（code segment）、DS（data segment）、ES（extra segment）、SS（stack segment）</li></ul></li><li><p><strong>标志寄存器</strong></p><ul><li>OF溢出标志，运算过程溢出置1，否则置0</li><li>SF符号标志，<strong>结果为负置1，否则置0</strong></li><li>ZF零标志，运算结果为0置1，否则置0</li><li>CF进位标志，e.g.加法运算中，有进位置1，否则置0</li><li>AF辅助进位标志，记录运算时第三位产生的进位值</li><li>PF奇偶标志。结果操作数中1个数为偶置1，否则置0</li></ul></li></ol><h2 id="标志位">标志位</h2><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody><tr><td>OF     溢出（是/否）</td><td>OV</td><td>NV</td></tr><tr><td>DF     方向（减量/增量）</td><td>DN</td><td>UP</td></tr><tr><td>IF       中断（允许/关闭）</td><td>EI</td><td>DI</td></tr><tr><td>SF      符号（负/正）</td><td>NG</td><td>PL</td></tr><tr><td>ZF      零（是/否）</td><td>ZR</td><td>NZ</td></tr><tr><td>AF      辅助进位（是/否）</td><td>AC</td><td>NA</td></tr><tr><td>PF      奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr><tr><td>CF      进位（是/否）</td><td>CY</td><td>NC</td></tr></tbody></table><h2 id="80x86寻址方式">80x86寻址方式</h2><h3 id="与数据有关的寻址方式">与数据有关的寻址方式</h3><ol><li><p><strong>立即寻址方式（immediate addressing）</strong></p><ul><li><code>MOVAL,5</code></li><li><code>MOVAX,3064H</code></li><li><code>MOVEAX,12345678H</code></li></ul></li><li><p><strong>寄存器寻址方式（register addressing）</strong></p><ul><li><code>MOVAX,BX</code></li><li><code>MOVECX,EDX</code></li></ul></li><li><p><strong>直接寻址方式（direct addressing）</strong></p><ul><li><code>MOVAX,[2000H]</code></li><li><code>MOV AX,VALUE</code>等价<code>MOV AX,[VALUE]</code></li><li><code>MOVAX,ES:VALUE</code>（段跨越前缀，默认为DS）</li></ul></li><li><p><strong>寄存器间接寻址方式（register indirect addressing）</strong></p><ul><li><code>MOVAX,[BX]</code></li><li><code>MOVAX,ES:[BX]</code>（段跨越前缀，默认为DS）</li></ul><blockquote><p>使用BP、SP时，默认段位SS。其他寄存器的默认段位DS寄存器。</p></blockquote></li><li><p><strong>寄存器相对寻址方式（register relative addressing）（或称直接变址寻址方式）</strong></p><ul><li><code>MOVAX,COUNT[SI]</code>等价于<code>MOV AX,[COUNT+SI]</code></li><li><code>MOVDL,ES:STRING[SI]</code></li></ul></li><li><p><strong>基址变址寻址方式（based indexed addressing）</strong></p><ul><li><code>MOVAX,[BX][DI]</code>等价于<code>MOVAX,[BX+DI]</code></li><li><code>MOVAX,ES:[BX][DI]</code></li></ul></li><li><p><strong>相对基址变址寻址方式（relative based indexed addressing）</strong></p><ul><li><code>MOVAX,MASK[BX][SI]</code></li></ul></li><li><p>比例变址寻址方式（scaled indexed addressing）</p></li><li><p>机制比例变址寻址方式（based scaled indexed addressing）</p></li><li><p>相对基址比例变址寻址方式（relative based scaled index addressing）</p></li></ol><h3 id="与转移地址有关的寻址方式">与转移地址有关的寻址方式</h3><ol><li>段内直接寻址（intrasegment direct addressing）</li><li>段内间接寻址（intrasegment indirect addressing）</li><li>段间直接寻址（intersegment direct addressing）</li><li>段间间接寻址（intersegment indirect addressing）</li></ol><h2 id="指令">指令</h2><h3 id="数据传送指令">数据传送指令</h3><h4 id="通用数据传送指令">通用数据传送指令</h4><ol><li><p><strong>MOV</strong></p><ul><li><code>MOVDST,SRC</code>将SRC内容传送至DST</li></ul><blockquote><p>双操作数指令<strong>不允许两个操作数都使用存储器</strong>，必须有一个是寄存器</p><p>DST不允许是立即数、不允许是CS寄存区（代码段）</p></blockquote></li><li><p>MOVSX</p><ul><li><code>MOVSXDST,SRC</code>，带符号拓展传送指令</li></ul></li><li><p>MOVSX</p><ul><li><code>MOVZXDST,SRC</code>，带符号拓展传送指令</li></ul></li><li><p><strong>PUSH</strong></p><ul><li><code>PUSHSRC</code>：先移动指针，后压入数据（所以压完数据后，指针是指向着该数据的）</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429230831387.png" style="zoom:80%;" /></li><li><p><strong>POP</strong></p><ul><li><code>POPDST</code>：先弹出数据，后移动指针</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429230927655.png" style="zoom:80%;" /></li><li><p>PUSHA/PUSHAD，所有寄存器进栈指令</p></li><li><p>POPA/POPAD，所有寄存器出栈指令</p></li><li><p><strong>XCHG</strong></p><ul><li><code>XCHGOPR1,OPR2</code>，由于是双操作数指令，必须有一个在寄存器中</li></ul></li></ol><h4 id="累加器专用传送指令">累加器专用传送指令</h4><ol><li>IN</li><li>OUT</li><li>XLAT</li></ol><h4 id="地址传送指令">地址传送指令</h4><ol><li><strong>LEA</strong><ul><li><code>LEAREG,SRC</code>，指令把原操作数的有效地址送到指定的寄存器中（用于获得地址的）</li></ul></li><li>LDS、LES、LFS、LGS、LSS</li></ol><h4 id="标志寄存器传送指令">标志寄存器传送指令</h4><ol><li>LAHF、SAHF、PUSHF/PUSHFD、POPF/POPFD</li></ol><h4 id="类型转换指令">类型转换指令</h4><ol><li>CBW，字节转换为字</li><li>CWD/CWDE，字转换为双字</li><li>CDQ，双字转换为4字</li><li>BSWAP，字节转换为字指令</li></ol><h3 id="算术指令">算术指令</h3><h4 id="加法指令">加法指令</h4><blockquote><p>ADD、INC常用</p><p>除INC外，其余指令影响标志位</p></blockquote><ol><li>ADD<ul><li><code>ADDDST,SRC</code></li></ul></li><li>ADC<ul><li><code>ADCDST,SRC</code>，带进位加法</li></ul></li><li>INC<ul><li><code>INCOPR</code>，加一</li></ul></li><li>XADD<ul><li><code>XADDDST,SRC</code></li><li>执行操作：<code>TEMP←(SRC)+(DST)</code>，<code>(SRC)←(DST)</code>，<code>(DST)←TEMP</code></li></ul></li></ol><p>加法指令（除INC指令）会影响标志位，CF位可表示<strong>无符号数</strong>的溢出，OF位可表示带符号数的溢出</p><p>故，若是无符号数的加法运算下，CF=1，则运算错误；若是带符号数的加法运算，OF=1，运算错误。</p><p><strong>INC不会影响CF标志位</strong></p><h4 id="减法指令">减法指令</h4><blockquote><p><strong>SUB、DEC、CMP</strong>常用</p><p>除DEC外，其余指令均影响CF标志位</p></blockquote><ol><li><strong>SUB</strong><ul><li><code>SUBDST,SRC</code>，执行<code>(DST)←(DST-SRC)</code>操作</li></ul></li><li>SBB<ul><li><code>SBBDST,SRC</code>，带借位减法指令，执行<code>(DST)←(DST)-(SRC)-CF</code>操作</li></ul></li><li><strong>DEC</strong><ul><li><code>DECOPR</code>，减一指令，执行<code>(OPR)←(OPR)-1</code>操作</li></ul></li><li>NEG<ul><li><code>NEGOPR</code>，求补指令，执行<code>(OPR)←-(OPR)</code>操作（或表示为<code>(OPR)←0FFFH-(OPR)+1</code>）</li></ul></li><li><strong>CMP</strong><ul><li><code>CMPDST,SRC</code>，执行<code>(DST-SRC)</code>操作，不保存结果，但影响标志位CF，后常接跳转指令</li></ul></li></ol><p>CF位表示无符号数的溢出，OF代表带符号位数的溢出。</p><p>故，减法中：无符号数减法，<code>被减数-减数 &lt; 0</code>，CF设置为1（“不够减”），否则为0；带符号数减法，若被减数与减数符号相同，减后结果符号与被减数（或减数）相反，则OF设置为1，其余情况为0。</p><h4 id="乘法指令">乘法指令</h4><ol><li>MUL<ul><li><code>MULSRC</code>，无符号乘法，执行操作如下：<ul><li>字节操作数：<code>(AX)←(AL)*(SRC)</code></li><li>字操作数：<code>(DX,AX)←(AX)*(SRC)</code></li><li>双字操作数：<code>(EDX,EAX)←(EAX)*(SRC)</code></li></ul></li><li>执行操作视SRC类型而定</li></ul></li><li>IMUL<ul><li><code>IMULSRC</code>，带符号乘法，执行操作与MUL指令一致</li></ul></li></ol><p>以使用MUL指令、SRC是AL为例，若结果(AX)的高8位为0，则CF位和OF位均为0，否则CF、OF位均设置为1</p><p>乘法指令中，CF、OF标志位可用于检查<strong>字节相乘的结果是字节还是字</strong>、<strong>字相乘的结果是字还是双字</strong>、……</p><h4 id="除法指令">除法指令</h4><ol><li>DIV<ul><li><code>DIVSRC</code>，无符号数除法，执行操作如下：<ul><li>字节操作：<code>(AL)←(AX)/(SRC)的商</code>，<code>(AH)←(AX)/(SRC)的余数</code></li><li>字操作：<code>(AX)←(DX,AX)/(SRC)的商</code>，<code>(DX)←(DX,AX)/(SRC)的余数</code></li><li>双字操作：<code>(EAX)←(EDX,EAX)/(SRC)的商</code>，<code>(EDX)←(EDX,EAX)/(SRC)的余数</code></li></ul></li></ul></li><li>IDIV<ul><li><code>IDIVSRC</code>，带符号数除法，执行操作同上</li></ul></li></ol><h3 id="逻辑指令">逻辑指令</h3><h4 id="逻辑运算指令">逻辑运算指令</h4><blockquote><p>NOT的操作数不能是立即数，其余指令DST必须是寄存器</p></blockquote><ol><li>AND<ul><li><code>ANDDST,SRC</code>，逻辑与，执行<code>(DST)←(DST)⋀(SRC)</code>操作</li></ul></li><li>OR<ul><li><code>ORDST,SRC</code>，逻辑或，执行<code>(DST)←(DST)⋁(SRC)</code>操作</li></ul></li><li>NOT<ul><li><code>NOTOPR</code>，逻辑非，执行<code>(DST)←(OPR)的非</code>操作</li></ul></li><li>XOR<ul><li><code>ORDST,SRC</code>，异或，执行<code>(DST)←(DST)与(SRC)的异或</code>操作</li></ul></li><li>TEST<ul><li><code>TESTOPR1,OPR2</code>，测试，执行<code>(DST)⋀(SRC)</code>操作</li></ul></li></ol><h4 id="位测试并修改指令（略）">位测试并修改指令（略）</h4><ol><li>BT</li><li>BTS</li><li>BTR</li><li>BTC</li></ol><h4 id="位扫描指令（略）">位扫描指令（略）</h4><ol><li>BSF</li><li>BSR</li></ol><h4 id="移位指令">移位指令</h4><ol><li><p>移位指令</p><ul><li><p>SHL</p></li><li><p>SAL</p></li><li><p>SHR</p></li><li><p>SAR</p></li></ul></li><li><p>循环移位指令</p><ul><li><p>ROL</p></li><li><p>ROR</p></li><li><p>RCL</p></li><li><p>RCR</p></li></ul></li><li><p>双精度移位指令</p><ul><li><p>SHLD</p></li><li><p>SHRD</p></li></ul></li></ol><h3 id="串处理指令（略）">串处理指令（略）</h3><ol><li>MOVS</li><li>CMPS</li><li>SCAS</li><li>LODS</li><li>STOS</li><li>INS</li><li>OUTS</li></ol><p>与上述配合使用前缀有</p><ol><li>REP</li><li>REPE/REPZ</li><li>REPNE/REPNZ</li></ol><h3 id="控制转移指令">控制转移指令</h3><h4 id="无条件转移指令">无条件转移指令</h4><p>JMP跳转指令</p><ol><li><code>JMPSHORT OPR</code></li><li><code>JMPNEAR PTR OPR</code></li></ol><h4 id="条件转移指令">条件转移指令</h4><h4 id="条件设置指令（略）">条件设置指令（略）</h4><h4 id="循环指令">循环指令</h4><h4 id="子程序">子程序</h4><h2 id="汇编语言程序（练习）">汇编语言程序（练习）</h2><h3 id="把BX寄存器内的二进制数以十六机制的形式在屏幕上打印">把BX寄存器内的二进制数以十六机制的形式在屏幕上打印</h3><ol><li><p>在<code>print_loop</code>中：</p><ul><li><p><code>rol     bx, 4</code>会将BX循环左移4位，比如原先为<code>0010,1010,1111,0011B</code>则变为<code>1010,1111,0011,0010B</code>，也就是原先的最高的4位到了BX的末尾的4位上</p></li><li><p>下一步——使用<code>mov     al, bl</code>指令将bl内容移动至al（bl是bx的后八位）</p></li><li><p>由于一个十六进制数需要4位进行表示，所以此时al中的高4位是不需要的，使用<code>and     al, 0Fh</code>指令对高四位进行消除</p></li><li><p>处理得到<code>0000????</code>这样一个低四位有效的al后，要判断al是属于0-9还是A-F</p></li><li><p>al的数值有效范围是0-15，若是0-9，直接打印（后续加上’0’即可）</p></li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250507154346239.png" style="zoom:50%;" /></li><li><p>若是10-15，先加上7（这样的话，后续也加上’0’，就能对应上ASCII的’A’-‘F’）</p></li></ul></li><li><p>关于<strong>在屏幕上打印</strong>（固定语句）</p><ul><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250507154327650.png" alt=""></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">prognam segment           ; 定义一个名为 prognam 的段（Segment）</span><br><span class="line">main    proc far          ; 声明一个远程（far）过程 main</span><br><span class="line">    assume cs:prognam     ; 告诉汇编器：此时 CS 寄存器指向 prognam 段</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; ---- 初始化 DS ----</span><br><span class="line">    push    ds            ; 保存原 DS</span><br><span class="line">    mov     ax, cs        ; AX ← CS（当前段选择子）</span><br><span class="line">    mov     ds, ax        ; DS ← AX，使 DS 与 CS 同段</span><br><span class="line"></span><br><span class="line">    ; ---- 将 BX 设为要显示的 16 位二进制数 ----</span><br><span class="line">    mov     bx, 0010101011110011B  </span><br><span class="line">                          ; BX ← 二进制 0010?1010?1111?0011?（0x2AF3）</span><br><span class="line"></span><br><span class="line">    mov     cx, 4         ; CX ← 4，表示要输出 4 个半字节（nibble）</span><br><span class="line"></span><br><span class="line">print_loop:</span><br><span class="line">    rol     bx, 4         ; BX 循环左移 4 位，下一个半字节移到 BL 低 4 位</span><br><span class="line">    mov     al, bl        ; AL ← BX 的低字节</span><br><span class="line">    and     al, 0Fh       ; AL ← AL AND 0x0F，只保留最低 4 位</span><br><span class="line"></span><br><span class="line">    cmp     al, 9         ; 判断当前值是否 ≤ 9</span><br><span class="line">    jbe     is_digit      ; 如果是数字（0–9），跳到数字处理</span><br><span class="line">    add     al, 7         ; 否则（10–15），先加 7 使其对应到 A–F</span><br><span class="line"></span><br><span class="line">is_digit:</span><br><span class="line">    add     al, &#x27;0&#x27;       ; AL += &#x27;0&#x27;，转换为 ASCII 字符</span><br><span class="line"></span><br><span class="line">    mov     dl, al        ; DL ← 要打印的 ASCII 字符</span><br><span class="line">    mov     ah, 02h       ; DOS 中断 21h 功能号 2：打印 DL 中的字符</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">    dec     cx            ; CX--，处理完一个半字节</span><br><span class="line">    jnz     print_loop    ; 如果 CX ≠ 0，则继续循环</span><br><span class="line"></span><br><span class="line">    ; ---- 恢复 DS 并退出 ----</span><br><span class="line">    pop     ds            ; 恢复原 DS</span><br><span class="line">    mov     ah, 4Ch       ; DOS 中断 21h 功能号 4Ch：程序退出</span><br><span class="line">    mov     al, 00        ; 返回码 0</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">main    endp             ; 过程结束</span><br><span class="line">prognam ends              ; 段结束</span><br><span class="line">    end     start        ; 程序入口（指向 start 标签）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从键盘接受十六进制数并存入BX">从键盘接受十六进制数并存入BX</h3><ol><li>关于<strong>从屏幕输入</strong><ul><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250507155431128.png" style="zoom: 67%;" /></li></ul></li><li>关于输入的数字的判断——判断是属于’0’-‘9’还是’A’-‘F’（后续还可以拓展为’a’-‘f’）<ul><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250507155841900.png" style="zoom:50%;" /></li><li>首先我们从屏幕输入的都是ASCII，比如输入的是’0’，实际上al中的十进制值是48，故减去48以使其范围落到数值0-9（若不是后续判断）</li><li><img src="https://blogs.muxueavid.top/blogs/2025/05/20250508095417146.png" style="zoom:80%;" /></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">prognam segment           ; 定义代码段</span><br><span class="line">main    proc far          ; 定义远程过程 main</span><br><span class="line">    assume cs:prognam     ; 告诉汇编器：CS 段寄存器关联 prognam</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; ---- 初始化 DS 段 ----</span><br><span class="line">    push    ds            ; 保存 DS</span><br><span class="line">    mov     ax, cs        ; 将 CS 的值赋给 AX</span><br><span class="line">    mov     ds, ax        ; 设置 DS ← CS</span><br><span class="line"></span><br><span class="line">    ; ---- BX 初始化为 0 ----</span><br><span class="line">    mov     bx, 0         ; 用于存储输入的十六进制数</span><br><span class="line"></span><br><span class="line">newchar:</span><br><span class="line">    mov     ah, 1         ; DOS 功能号 1：带回显读取字符</span><br><span class="line">    int     21h           ; 调用 DOS 中断，输入字符保存在 AL 中</span><br><span class="line"></span><br><span class="line">    sub     al, 30h       ; AL -= &#x27;0&#x27;，尝试转为数字 0–9</span><br><span class="line">    jl      exit          ; 如果小于 0，非法输入 → 退出</span><br><span class="line">    cmp     al, 10</span><br><span class="line">    jl      add_to        ; 如果 AL &lt; 10，说明是 0–9 → 继续处理</span><br><span class="line"></span><br><span class="line">    sub     al, 7         ; AL -= (&#x27;A&#x27; - 10) = 0x41 - 0x0A = 0x37</span><br><span class="line">                          ; 所以等价于：AL ← AL - 27h</span><br><span class="line"></span><br><span class="line">    cmp     al, 0Ah       ; 检查是否是合法十六进制字母（A–F）</span><br><span class="line">    jl      exit          ; 小于 A → 非法 → 退出</span><br><span class="line">    cmp     al, 10h</span><br><span class="line">    jge     exit          ; 大于 F → 非法 → 退出</span><br><span class="line"></span><br><span class="line">add_to:</span><br><span class="line">    mov     cl, 4         ; 每次移位 4 位，为新位腾出空间</span><br><span class="line">    shl     bx, cl        ; BX ← BX &lt;&lt; 4，相当于“进位”</span><br><span class="line">    xor     ah, ah        ; 清除 AH，确保 AX = AL（16 位加法安全）</span><br><span class="line">    add     bx, ax        ; BX += AL，即追加新的十六进制位</span><br><span class="line"></span><br><span class="line">    jmp     newchar       ; 继续读取下一个字符</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    pop     ds            ; 恢复原 DS（可选，但良好习惯）</span><br><span class="line">    mov     ah, 4Ch       ; DOS 功能号 4Ch：正常退出程序</span><br><span class="line">    mov     al, 00        ; 返回代码 0</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">main    endp              ; 过程结束</span><br><span class="line">prognam ends              ; 段结束</span><br><span class="line">        end start         ; 程序入口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="往有序数组中插入数据">往有序数组中插入数据</h3><ol><li>已知是一个有限数组，要求插入一个数据，思路是从后向前找</li><li>逐个比较，每次比较时，若待插入数小于当前数，则将当前位置的数后移</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    x dw ?</span><br><span class="line">    array_head dw 3,5,15,23,37,49,52,65,78,99</span><br><span class="line">    array_end dw 105</span><br><span class="line">    n dw 32</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line"></span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,n</span><br><span class="line">    mov array_head-2,0ffffh  ;0ffffh的0是因为十六进制开头添加</span><br><span class="line">    mov si,0</span><br><span class="line">    </span><br><span class="line">compare:</span><br><span class="line">    cmp array_end[si],ax</span><br><span class="line">    jle insert</span><br><span class="line">    mov bx,array_end[si]</span><br><span class="line">    mov array_end[si+2],bx</span><br><span class="line">    sub si,2</span><br><span class="line">    jmp short compare</span><br><span class="line">insert:</span><br><span class="line">    mov array_end[si+2],ax</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    a dw 100,30,78,99,15,-1,66,45,189,255</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov cx,10  ;设置循环次数</span><br><span class="line">    dec cx     ; 10个数，需9次即可</span><br><span class="line">    </span><br><span class="line">loop1:</span><br><span class="line">    mov di,cx</span><br><span class="line">    mov bx,0</span><br><span class="line">loop2:</span><br><span class="line">    mov ax,a[bx]</span><br><span class="line">    cmp ax,a[bx+2]</span><br><span class="line">    jge continue</span><br><span class="line">    xchg ax,a[bx+2]</span><br><span class="line">    mov a[bx],ax</span><br><span class="line">continue:</span><br><span class="line">    add bx,2</span><br><span class="line">    loop loop2</span><br><span class="line">    </span><br><span class="line">    mov cx,di</span><br><span class="line">    </span><br><span class="line">    loop loop1</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="例5-5">例5.5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    x dw 1,2,3,4,5,6,7,8,9,-3</span><br><span class="line">    y dw 9,8,-7,-6,-5,4,-3,-2,1,13</span><br><span class="line">    z dw 0,0,0,0,0,0,0,0,0,0</span><br><span class="line">    logic_rule dw 00dch;逻辑尺，为</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,10</span><br><span class="line">    mov dx,logic_rule</span><br><span class="line">next:</span><br><span class="line">    mov ax,x[bx]</span><br><span class="line">    shr dx,1</span><br><span class="line">    jc subtract</span><br><span class="line">    add ax,y[bx]</span><br><span class="line">    jmp short result</span><br><span class="line">subtract:</span><br><span class="line">    sub ax,y[bx]</span><br><span class="line">result:</span><br><span class="line">    mov z[bx],ax</span><br><span class="line">    add bx,2</span><br><span class="line">    loop next</span><br><span class="line">    ret                </span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="折半查找（二分）">折半查找（二分）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    array dw 12,11,22,33,44,55,66,77,88,99,111,222,333  ; array[0] 存个数，后面是有序数组</span><br><span class="line">    number dw 55                                        ; 要查找的目标数</span><br><span class="line">    low_inx dw ?                                        ; 保存 low index</span><br><span class="line">    high_inx dw ?                                       ; 保存 high index</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">main proc far</span><br><span class="line">    assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax, ax</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    lea di, array         ; DI ← 数组首地址</span><br><span class="line">    mov cx, [di]          ; CX ← 元素个数（不含 array[0]）</span><br><span class="line">    mov ax, number        ; AX ← 要查找的目标数</span><br><span class="line"></span><br><span class="line">    mov low_inx, 1        ; low index ← 1（跳过 array[0]）</span><br><span class="line">    mov high_inx, cx      ; high index ← 元素个数</span><br><span class="line"></span><br><span class="line">binary_search:</span><br><span class="line">    mov cx, low_inx</span><br><span class="line">    cmp cx, high_inx</span><br><span class="line">    ja not_found          ; if low &gt; high，说明找不到</span><br><span class="line"></span><br><span class="line">    mov cx, low_inx</span><br><span class="line">    add cx, high_inx</span><br><span class="line">    shr cx, 1             ; CX ← mid index</span><br><span class="line"></span><br><span class="line">    mov si, cx</span><br><span class="line">    mov bx, si</span><br><span class="line">    shl bx, 1             ; bx ← si * 2（字节偏移）</span><br><span class="line">    add bx, di            ; bx ← 元素地址</span><br><span class="line"></span><br><span class="line">    mov dx, [bx]          ; DX ← 当前比较值</span><br><span class="line">    cmp ax, dx</span><br><span class="line">    je found              ; 如果相等，跳转</span><br><span class="line"></span><br><span class="line">    jb less_than          ; 如果 ax &lt; array[si]，搜索左半边</span><br><span class="line"></span><br><span class="line">    ; 否则搜索右半边</span><br><span class="line">    inc si</span><br><span class="line">    mov low_inx, si</span><br><span class="line">    jmp binary_search</span><br><span class="line"></span><br><span class="line">less_than:</span><br><span class="line">    dec si</span><br><span class="line">    mov high_inx, si</span><br><span class="line">    jmp binary_search</span><br><span class="line"></span><br><span class="line">not_found:</span><br><span class="line">    stc                   ; 未找到，CF = 1</span><br><span class="line">    jmp finish</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    clc                   ; 找到了，CF = 0</span><br><span class="line">    shl si, 1             ; 转换为字节偏移</span><br><span class="line">                          ; si 即偏移地址（从 array 起）</span><br><span class="line">finish:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">    end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>已做实验</h1><p>1.1：在数据段DATA中有两个字数据X和Y， 假设X=1122H，Y=3344H， 编程求两个字的和,结果存放到Z单元中。</p><p>1.2：从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。</p><p>2.1：计算1+2+3+…+10，将结果显示在屏幕上。对1-10求和、将结果打印（这个比较关键、利用除法进行输出）（div指令的商在AX、余数在DX）（所以每次得到一个DX就进行PUSH、并同时用CX记录位数）（最后POP DX即可输出——记得转成ascii）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH, 1    ; AH存入子功能号1</span><br><span class="line">INT 21H       ; 调用21H中断，等待用户键盘输入一个字符，并存入AL</span><br></pre></td></tr></table></figure><p>2.2：利用01H号功能调用输入10个一位数字，将其由数字字符转换为相应整数，并依次保存到字节变量BUF。编程求出这10个数中的最大数和最小数，分别存入字节变量MAX和MIN，并分别将其在屏幕上显示出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AH, 2     ; AH存入子功能号2</span><br><span class="line">MOV DL, ‘A’    ; DL存入要显示的字符‘A’</span><br><span class="line">INT 21H        ; 调用21H中断，屏幕上显示DL中的字符</span><br></pre></td></tr></table></figure><p>2.3：输入一个不大于65535的十进制非负整数，判断其是否为素数，如果是素数，输出字符串“It’s a prime.”，否则输出字符串“It’s not a prime.”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据段：</span><br><span class="line">定义变量，并初始化为字符串：</span><br><span class="line">STR  DB  “hello world”, ‘$’</span><br><span class="line">代码段：</span><br><span class="line">MOV AH, 9             ; AH存入子功能号9</span><br><span class="line">MOV DX, OFFSET STR   ; DX中存入字符串的首地址</span><br><span class="line">INT 21H                ; 调用21H中断，屏幕上显示DX指向的字符串“hello world”</span><br></pre></td></tr></table></figure><p>3.1：从键盘上输入多个长度小于30的字符串，直到输入空行为止，将其中最长的一行字符串显示输出。</p><p>要求：（1）定义子过程GETS，实现从键盘输入字符串到参数数组中，读取包括空格在内的所有字符，直到遇到换行符为止，在字符数组中以‘\0’字符作为字符串末尾标记，该过程的返回值为输入的字符串的长度，返回值用寄存器AX传递。</p><p>（2）定义子过程PUTS，实现输出参数数组中的字符串，该过程的返回值为输出的字符个数，返回值用寄存器AX传递。</p><p>（3）定义主过程MAIN，调用两个子过程实现程序功能。</p><p>（4）输入一个字符通过调用21H号DOS中断的1号功能，输出一个字符通过该中断的2号功能调用。</p><p>3.2：编写十进制数到十六进制的转换程序。用户从键盘输入一个十进制无符号整数，然后把该数以十六进制形式（包括后缀字符H）在屏幕上显示出来。</p><p>要求：（1）定义两个子过程INPUT和OUTPUT。过程INPUT实现键盘输入一个十进制无符号整数，存入寄存器BX。过程OUTPUT实现以十六进制形式（包括后缀字符H）在屏幕上输出寄存器BX的值。</p><p>（2）定义主过程MAIN调用两个子过程实现程序功能。</p><h1>other</h1><p>自写：输入一连串数字保存、再输出（每个位上+1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">; multi-segment executable file template.</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    num db 20 dup(0)</span><br><span class="line">    len dw 0</span><br><span class="line">ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">; set segment registers:</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">   call INPUT</span><br><span class="line">    </span><br><span class="line">    call OUTPUT</span><br><span class="line">    </span><br><span class="line">    mov ax, 4c00h ; exit to operating system.</span><br><span class="line">    int 21h    </span><br><span class="line">ends</span><br><span class="line">               </span><br><span class="line">INPUT proc</span><br><span class="line">    push ax</span><br><span class="line">    push si</span><br><span class="line">    </span><br><span class="line">    mov si,0 ;用于计数（偏移量）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">input_loop:</span><br><span class="line">    mov ah,1</span><br><span class="line">    int 21h</span><br><span class="line">    cmp al,0Dh  ;若为回车，则退出输入</span><br><span class="line">    je end_loop    </span><br><span class="line">    sub al,&#x27;0&#x27;  ;这里已经保证输入的数据是0-9</span><br><span class="line">    mov num[si],al</span><br><span class="line">    inc si</span><br><span class="line">    jmp input_loop</span><br><span class="line">    </span><br><span class="line">end_loop:</span><br><span class="line">    mov len,si  ;将长度信息保存到len</span><br><span class="line">              </span><br><span class="line">    pop si      </span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line">INPUT endp</span><br><span class="line"></span><br><span class="line">OUTPUT proc</span><br><span class="line">    mov cx,len</span><br><span class="line">    mov si,0</span><br><span class="line">output_loop:</span><br><span class="line">    mov ah,2</span><br><span class="line">    mov dl,num[si]  ;将num转为字符     （为了区别显示，加了1）</span><br><span class="line">    add dl,&#x27;1&#x27;</span><br><span class="line">    int 21h  ;输出dl中的值</span><br><span class="line">    inc si</span><br><span class="line">    loop output_loop</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line">OUTPUT endp</span><br><span class="line"></span><br><span class="line">end start ; set entry point and stop the assembler.</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS逆向</title>
      <link href="/2025/04/23/Python/JS%E9%80%86%E5%90%91/"/>
      <url>/2025/04/23/Python/JS%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1>JS逆向</h1><h2 id="浏览器调试工具介绍">浏览器调试工具介绍</h2><ol><li><strong>元素</strong>界面，用于展示当前网页信息（但是注意这个不是静态资源）</li></ol><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231322792.png" alt=""></p><ol start="2"><li><strong>控制台</strong>界面，用于调试打印信息的（类比cmd）</li></ol><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231416377.png" alt=""></p><ol start="3"><li><strong>源代码/来源</strong>界面，存放了js代码、图片、css、html等静态资源文件</li></ol><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231437460.png" alt=""></p><ol start="4"><li><strong>网络</strong>界面，用于网络请求的监听（非抓包，抓包是可以对其中内容作修改的）<ul><li>Fetch/XHR：动态数据</li><li>文档：静态数据</li></ul></li></ol><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231527621.png" alt=""></p><h2 id="tips">tips</h2><ol><li>在网页中找到对应的接口，注意区分动态与静态接口<ul><li>动态接口返回的是结构化数据（通过后端返回的），静态接口返回的是非结构化数据（HTML、CSS、JS）</li></ul></li><li>查看返回的数据大小，来排除一些返回数据过小的接口（如果你想要的数据是很大的数据的话）</li></ol><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231556422.png" alt=""></p><ol start="3"><li><p>快速生成爬虫代码，<a href="https://curlconverter.com/">工具网站</a></p><ul><li><p>复制接口的crul代码（bash格式）</p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429231725983.png" style="zoom:67%;" /></li><li><p>复制到网站后，直接生成代码：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429232219382.png" alt=""></p></li></ul></li><li><p>如果发现浏览器返回数据是这种带有大括号的，直接在接受后，使用.json()进行转换</p><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429232255492.png" alt=""></p><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429232338834.png" alt=""></p></li><li><p>网络-&gt;选中接口-&gt;启动器</p><p><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429232439491.png" alt=""></p></li><li><p>确定JS是否存在混淆或加密（eval）</p></li><li><p>若无，则定位加密位置或者解密</p><ol><li></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JS逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之Scrapy框架使用</title>
      <link href="/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>爬虫之Scrapy框架使用</h1><h2 id="安装">安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><h2 id="quick-start">quick_start</h2><ol><li>使用<code>scrapy startproject 项目名称</code>创建scrapy项目</li><li>项目组成</li><li>创建爬虫文件<ul><li><code>cd 目录名称/目录名称/spiders</code>跳转到spiders文件夹</li><li><code>scrapy genspider 爬虫名字 网页的域名</code>，网页域名不用加协议</li></ul></li><li>运行爬虫文件（在spiders目录下执行）<code>scrapy crawl 爬虫名称</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫基础</title>
      <link href="/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Python爬虫基础</h1><p>爬虫，就是通过一个程序，根据url进行爬取网页，获取有用信息。</p><p>爬虫的核心在于：</p><ol><li>根据需求，确定要爬取的url</li><li>模拟浏览器进行访问，获取到返回的HTML源码</li><li>对该HTML进行解析，获取需要的数据</li></ol><p>爬虫的难点在于——<strong>如何应对反爬手段</strong>。</p><p>本文聚焦与两方面内容：</p><ol><li>一些基本爬虫工具库的使用（urllib、xpath、jsonpath、bs4、request）</li><li>进行爬虫过程中遇到的一些问题以及解决方案</li></ol><h2 id="urllib">urllib</h2><p><a href="https://docs.python.org/zh-cn/3.13/library/urllib.html">官方文档</a>：其中<code>urllib.request</code>库用于打开和读取URL、<code>urllib.parse</code>用于解析URL，此两库常用。</p><p><a href="https://www.runoob.com/python3/python-urllib.html">urllib 菜鸟教程</a>：简单使用、查常用的API</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="XPath">XPath</h2><p><a href="https://lxml.de/tutorial.html">官方文档</a></p><p><a href="https://www.cnblogs.com/shizidushu/p/18398770">lxml.etree库-博客园</a>：API</p><p><a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 菜鸟教程</a>：重点关注XPath语法</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="jsonpath">jsonpath</h2><p><a href="https://goessner.net/articles/JsonPath/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="bs4">bs4</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="requests">requests</h2><p><a href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="Selenium">Selenium</h2><p><a href="http://www.selenium.org.cn/">官方？</a></p><p><a href="https://www.runoob.com/selenium/selenium-tutorial.html">菜鸟教程</a>：里面的方法名已经过时（在高版本被移除），通过传入一个<code>By.[ID等可选]</code>参数来解决</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="问题以及解决方案">问题以及解决方案</h2><h3 id="1-根据url已获取到HTML，但没解析出内容？">1. 根据url已获取到HTML，但没解析出内容？</h3><p>具体场景为：使用urllib.request定制Request对象、模拟浏览器发送请求后，成功获取到HTML源码</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180159657.png" alt="image-20250419142009694" style="zoom:67%;" /><p>而在进行xpath解析时，却出了问题，先在网页HTML源码中寻找资源路径、且通过xpath插件验证过可行</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180235550.png" alt="image-20250419142702805" style="zoom:67%;" /><p>调试发现：无法通过该xpath表达式获取到对应内容</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180304051.png" alt="image-20250419143158604" style="zoom:67%;" /><p>原因并不是处在xpath解析式上，而是返回的content中的HTML源码与网页的HTML源码不是同一个！</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180323036.png" alt=""></p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180338752.png" alt="bfaefc76209c3851838238742d645bd1"></p><p>调试发现，获取的HTML版本是通过网络请求直接返回的那个</p><p>不一样的原因在于：<strong>浏览器执行了js代码，修改了类名</strong>，而爬取的网页是原始静态html，没修改类名。</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180351318.png" alt="image-20250419143547537"></p><h3 id="2-图片懒加载——你所见的不一定是真实的">2. 图片懒加载——你所见的不一定是真实的</h3><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180404511.png" alt="blog-20250501180404511" style="zoom:80%;" /><p>那么问题又来了，当有两个属性都是图片的链接地址，我该选择哪一个？有个小技巧是重新刷新网页——因为你有可能已经向下滑动，使得图片已被加载，刷新后，不要向下拖动，直接观察靠后的图片的链接地址，可以发现问题：图片在还没有被加载时，src属性并没有对应上图片链接（是默认图），所以在此例子中，original-data才是我们想要的</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180454474.png" alt="e8d52429156edcb9934aab91e91f722e" style="zoom:80%;" /><h3 id="3-selenium测试时元素定位失败？">3.selenium测试时元素定位失败？</h3><blockquote><p>原因：本地测试时，某个元素可能确实在那个位置上，标签信息也没写错。但是在selenium打开的浏览器中，同样的元素，对应的标签名可能有细微的差异，所以需要在selenium打开浏览器后，开F12进行定位</p></blockquote><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180508240.png" alt=""></p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180531396.png" alt=""></p><p>遇到问题：使用本地浏览器测试得到的、正确的xpath语句，在代码的selenium环境下却无法查询到元素！</p><p>然后，在selenium环境下的“浏览器”中F12进行元素定位：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180545437.png" alt=""></p><p>修改代码中的xpath解析式，成功定位到该元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马踏棋盘问题</title>
      <link href="/2025/03/31/algorithm/other/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/algorithm/other/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>马踏棋盘/骑士周游问题</h1><blockquote><p>DFS算法的应用</p></blockquote><h2 id="思路分析">思路分析</h2><p><strong>骑士周游问题的解决步骤和思路：</strong></p><ol><li><p><strong>创建棋盘</strong></p><p>初始化一个棋盘 <code>chessBoard</code>，它是一个二维数组，最终会显示出棋盘被访问的顺序（从1开始计数），也作为标记某个点是否被访问过使用（0则表示未访问过）。</p></li><li><p><strong>设置当前位置已访问</strong></p><p>将骑士的当前位置标记为已访问，并根据当前位置计算骑士能够跳到的合法位置。将这些位置存放在一个集合（如 <code>ArrayList</code>）中，最多包含8个合法的跳跃位置。每走一步，将步数 <code>step</code> 加 1（<code>step</code>从1开始）。</p></li><li><p><strong>遍历可能的跳跃位置</strong></p></li></ol><p>遍历 <code>ArrayList</code> 中存放的所有跳跃位置，检查哪个位置可以合法地走通。如果找到可以继续走的合法位置，则继续往下走；如果走不通，进行回溯，尝试其他可能的路径。</p><ol start="4"><li><p><strong>判断是否完成任务</strong></p><p>在每一步后，通过比较当前步数 <code>step</code> 和应走的总步数（例如，棋盘上总共有 64 格）来判断骑士是否完成了任务。如果步数未达到目标，表示任务尚未完成，需要将当前走的这步回溯（标记为未访问 + 从棋盘上移除step）</p></li></ol><h2 id="引入贪心算法的优化">引入贪心算法的优化</h2><p><strong>原始算法回顾：</strong></p><p>在原始的回溯算法中，每当骑士移动到一个新位置时，它会尝试从当前的位置出发，向所有可能的方向移动，直至找到一个合法的位置。如果某个位置无法继续走下去，算法就会回溯，尝试其他路径。这个过程有可能产生很多冗余的回溯操作，特别是当某些路径已经没有出路时，算法依然需要探索。</p><p><strong>优化的贪心策略：</strong></p><p>在优化后的版本中，我们对每一步的可能跳跃位置进行了排序，排序的依据是<strong>下一步的合法移动的数量</strong>。具体做法是，对于每一个当前位置，首先计算出它的所有可能的跳跃位置，接着计算每一个跳跃位置的下一步可能走的格子的数量（即它的“后继”点的数量），然后将这些点按“后继点数量”进行非递减排序，优先选择那些后继点数量少的点进行探索。</p><p><strong>为什么这个优化是有效的？</strong></p><ol><li><p><strong>减少回溯的次数：</strong></p><p>通过优先选择“后继点数目少”的点，我们可以有效减少不必要的回溯。原因如下：</p><ul><li>如果我们首先选择一个“后继点数目少”的点，那么骑士的下一步选择就会变得相对明确，不会出现太多的回溯，因为如果某个位置后继点数多，则它很可能导致更多的可能路径，造成更多的回溯操作。</li><li>反之，如果先选择了“后继点数目多”的点，可能导致骑士走入一个“死胡同”，这时算法会进行回溯，重新尝试其他的路径。通过贪心策略，减少了这类不必要的回溯。</li></ul></li><li><p><strong>更高效的路径探索：</strong></p><p>通过排序后的优先选择，我们相当于是在“预测”哪些路径最有可能找到解，并优先探索这些路径。这使得每次选择跳跃点时，骑士能较早地走到棋盘的“易走”区域，避免在困难区域做无谓的探索，从而提高算法的效率。</p></li><li><p><strong>防止局部最优：</strong></p><p>贪心算法的一大优势是局部最优的选择能够帮助我们尽量避免走入死胡同。通过选择“后继点数目少”的位置，实际上是让骑士先走到那些可能性更少的地方，这样如果后续真的出现死局（即所有可能的后继都被访问过），程序可以尽早发现并进行回溯，而不是等到最后一步才回溯。</p></li><li><p><strong>贪心策略的实际效果：</strong></p><ul><li>在没有优化的情况下，骑士可能在某些点周围存在很多可选的下一步位置（例如：有多个合法的跳跃位置），但这些位置的后继可能很复杂，导致更多的回溯。而引入贪心算法后，程序会先探索那些“跳跃空间”最小的路径，尽量避免复杂的回溯。</li><li><strong>非递减排序</strong>的策略本质上是在优先选择“后继点最少”的点，这是一种启发式的选择方法。通过这种方法，算法通常能够更快地找到解决方案，或者发现路径的死胡同，减少了回溯的开销。</li></ul></li></ol><blockquote><p>优化前：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183456517.png" alt="image-20241114173601773" style="zoom:80%;" /></p><p>优化后：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183506715.png" alt="image-20241114173523463" style="zoom: 80%;" /></p></blockquote><h2 id="代码实现">代码实现</h2><p><code>HorseStepChess</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.horseStepOnAChessBoard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HorseStepChess</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> R; <span class="comment">// 棋盘行数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> C; <span class="comment">// 棋盘列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] chessBoard; <span class="comment">// 使用棋盘作为标记数组（也同时记录行动路线）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> isFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义马的8个可能的移动方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] X_MOVE = &#123;-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] Y_MOVE = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        R = C = <span class="number">8</span>;</span><br><span class="line">        chessBoard = <span class="keyword">new</span> <span class="title class_">int</span>[R][C];</span><br><span class="line">        KnightTour(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessBoard.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessBoard[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessBoard[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 骑士周游方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r    当前行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c    当前列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 第 step 步（从1开始）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">KnightTour</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">        chessBoard[r][c] = step; <span class="comment">// 标记当前位置为第几步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前位置可走的下一步位置</span></span><br><span class="line">        ArrayList&lt;Point&gt; nextPoints = getNext(<span class="keyword">new</span> <span class="title class_">Point</span>(c, r));</span><br><span class="line">        <span class="keyword">while</span> (!nextPoints.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> nextPoints.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断该点是否未被访问过（chessBoard[][]为0就是未访问过）</span></span><br><span class="line">            <span class="keyword">if</span> (chessBoard[p.y][p.x] == <span class="number">0</span>) &#123; <span class="comment">// 注意 Point.x 是列，Point.y 是行</span></span><br><span class="line">                KnightTour(p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="comment">// 如果未完成任务且走不通，则重置当前格子</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; R * C &amp;&amp; !isFinished) &#123;</span><br><span class="line">            chessBoard[r][c] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>; <span class="comment">// 任务完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前位置下一步可能走的所有点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title function_">getNext</span><span class="params">(Point current)</span> &#123;</span><br><span class="line">        ArrayList&lt;Point&gt; points = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> current.x + X_MOVE[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> current.y + Y_MOVE[i];</span><br><span class="line">            <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; C &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; R) &#123;</span><br><span class="line">                points.add(<span class="keyword">new</span> <span class="title class_">Point</span>(newX, newY));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化后代码">优化后代码</h2><ol><li>在<code>KnightTour</code>方法里，获取了当前点的下一步可走的所有点后，进行排序：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前位置可走的下一步位置</span></span><br><span class="line">ArrayList&lt;Point&gt; nextPoints = getNext(<span class="keyword">new</span> <span class="title class_">Point</span>(c, r));</span><br><span class="line"><span class="comment">//排序--优化部分，当按 下一个位置的下一次可能位置数 非递减排序时，可以减少回溯次数。</span></span><br><span class="line">sortPoints(nextPoints);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>sortPoints</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了优化骑士周游回溯的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortPoints</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> &#123;</span><br><span class="line">        ps.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Point&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Point o1, Point o2)</span> &#123;</span><br><span class="line">                <span class="comment">//获取o1的下一步所有可能位置 的个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> getNext(o1).size();</span><br><span class="line">                <span class="comment">//获取02的下一步所有可能位置 的个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> getNext(o2).size();</span><br><span class="line">                <span class="keyword">return</span> size1 - size2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>main</code>方法中，可以以下方式对比优化前后的效率（测优化前就在<code>KnightTour</code>方法注释掉sortPoints）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        R = C = <span class="number">8</span>;</span><br><span class="line">        chessBoard = <span class="keyword">new</span> <span class="title class_">int</span>[R][C];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录算法开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        KnightTour(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 记录算法结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 输出运行时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;算法运行时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessBoard.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessBoard[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessBoard[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd算法</title>
      <link href="/2025/03/31/algorithm/other/Floyd%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/algorithm/other/Floyd%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>Floyd算法</h1><p><strong>Floyd算法介绍</strong></p><ol><li>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li><li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li><li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径</li><li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li></ol><p><strong>弗洛伊德算法思路</strong>：</p><ol><li>假设图中有顶点 $ v_i $、$ v_j$ 和 $ v_k $，其中 $ L_{ik} $表示从顶点 $v_i $到顶点 $ v_k $ 的最短路径，$ L_{kj} $ 表示从顶点 $ v_k $ 到顶点 $ v_j $ 的最短路径。那么，顶点 $ v_i $ 到顶点 $ v_j $ 的最短路径 $ L_{ij} $ 可以通过以下方式计算：</li></ol><p>$$<br>L_{ij} = \min(L_{ij}, L_{ik} + L_{kj})<br>$$</p><p>也就是说，从 $ v_i $ 到 $ v_j $ 的最短路径，可能是直接从 $ v_i $ 到 $ v_j $ 的路径（即 $ L_{ij} $），或者是通过一个中间顶点 $ v_k $ 经过 $ v_k $ 的路径，即先从 $ v_i $ 到 $ v_k $，再从 $ v_k $ 到 $ v_j $。</p><ol start="2"><li><p>在实际算法中，针对每一对顶点 $ (v_i, v_j) $，我们都会依次考虑所有可能的中间顶点 $ v_k $（即图中的每个顶点），计算并更新从 $ v_i $ 到 $ v_j $ 的最短路径。具体来说，对于每一个中间顶点 $ v_k $，我们更新所有顶点对 $ (v_i, v_j) $ 的最短路径：</p><p>$$<br>L_{ij} = \min(L_{ij}, L_{ik} + L_{kj})<br>$$</p></li><li><p>最终，当所有的顶点都作为中间点被考虑过之后，我们就能够得到每一对顶点之间的最短路径。</p></li></ol><p><strong>图解</strong>：</p><p>求每A-G点到其余各点的最短路径/距离？<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183845217.png" alt="image-20241114144607382" style="zoom:80%;" /></p><ol><li><p>在算法进行过程中，重点维护两张表：<strong>距离表</strong>、<strong>前驱表</strong>，初始化如下：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183857459.png" alt="image-20241114145839072" style="zoom:80%;" /></li><li><p>仅以第一次为例，将A作为中间节点，对两张表进行更新：其中，只更新了B-A-G[23]（经过中间顶点A），<strong>故更新B-G为23</strong>，标黄的B-F[7]比B-A-F[24]小，所以<strong>不更新B-F</strong>。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183908186.png" alt="image-20241114150317574" style="zoom:67%;" /></li><li><p>真–人工手动跑一遍结果（代码验证无误）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183918817.png" alt="image-20241114154612640" style="zoom:80%;" /></li></ol><h2 id="代码实现">代码实现</h2><p><code>FloydAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.floyd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">11</span>, N, N, N, <span class="number">13</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">0</span>, <span class="number">10</span>, N, N, <span class="number">7</span>, N&#125;,</span><br><span class="line">                &#123;N, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, N&#125;,</span><br><span class="line">                &#123;N, N, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, N, N&#125;,</span><br><span class="line">                &#123;N, N, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">6</span>, N, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, N, N, N, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex.length,vertex,matrix);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输出某两点的最短路径:&quot;</span>);</span><br><span class="line">        graph.path(<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//输出A到D的最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dis;<span class="comment">//最短路矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] pre;<span class="comment">//前驱矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.dis = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="built_in">this</span>.pre = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.vertex[i] = vertex[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dis[i][j] = matrix[i][j];</span><br><span class="line">                pre[i][j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;距离表为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(dis[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;前驱表为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(pre[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;k&lt;dis.length;k++)&#123;<span class="comment">//遍历中间节点</span></span><br><span class="line">            <span class="comment">//从i到j  与  从i到k再到j的比较。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;dis.length;j++)&#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="keyword">if</span>(len &lt; dis[i][j])&#123;</span><br><span class="line">                        dis[i][j] = len;</span><br><span class="line">                        pre[i][j] = pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">path</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">            System.out.print(vertex[v1] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre[v1][v2] == v1) &#123;</span><br><span class="line">            System.out.print(vertex[v1] + <span class="string">&quot; &quot;</span> + vertex[v2] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path(v1, pre[v1][v2]); <span class="comment">// 递归输出路径</span></span><br><span class="line">            System.out.print(vertex[v2] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/2025/03/31/algorithm/other/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/algorithm/other/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>迪杰斯特拉算法</h1><p><strong>算法介绍</strong><br><strong>Dijkstra 算法</strong> 是经典的 <strong>最短路径算法</strong>，用于计算从一个源顶点到图中其他所有顶点的最短路径。它的核心思想是从起始顶点开始，逐步“扩展”到其他顶点，每次选择距离起始顶点最近的未处理顶点，从而逐步找到最短路径。Dijkstra 算法本质上是基于 <strong>贪心算法</strong> 的思想，优先选择当前最短的路径。</p><p><strong>算法过程</strong></p><ol><li><strong>初始化</strong><br>假设我们以顶点 $v$ 作为起始点，图中的顶点集合为 $V = { v_1, v_2, \cdots, v_n }$。<br>初始化一个距离集合 $Dis = { d_1, d_2, \cdots, d_n}$，其中 $d_i$ 表示从起点 $v$ 到顶点 $v_i$ 的当前最短距离。<ul><li>对于起点 $v$，距离为 0，即 $d_v = 0$；</li><li>对于其他顶点，初始距离设置为无穷大（表示还未找到路径）。<br>初始时，所有顶点都没有被访问过，所有的距离值都存储在集合 $Dis$ 中。</li></ul></li><li><strong>选择当前最短的顶点</strong><br>从距离集合 $Dis$ 中选择当前距离最小的顶点 $v_i$，并将其从 $Dis$ 集合中移除。<br>此时，$v$ 到 $v_i$ 的路径就是最短路径。</li><li><strong>更新邻接顶点的距离</strong><br>以 $v_i$ 为中心，更新从 $v$ 到其他尚未访问顶点的距离。<br>对于每个未访问的邻接顶点 $v_j$，我们需要比较：<ul><li>从 $v$ 直接到 $v_j$ 的距离（即$dis[v_j]$）；</li><li>从 $v$ 经由 $v_i$ 到 $v_j$ 的距离（即 $dis[v_i] + \text{weight}[v_i][v_j]$）。<br>如果通过 $v_i$ 的路径更短，就更新 $Dis$ 中对应的距离，并且更新 $v_j$ 的前驱节点为 $v_i$，表示通过 $v_i$ 到达 $v_j$。</li></ul></li><li><strong>重复步骤 2 和 3</strong><br>重复执行步骤 2 和步骤 3，直到所有顶点都被访问过，或者找到了目标顶点的最短路径。</li><li><strong>终止条件</strong><br>当所有顶点都被处理过时，或者当最短路径已经找到（即目标顶点的距离已经确定），算法结束。</li></ol><p><strong>思路总结</strong>：</p><p>Dijkstra 算法通过**逐步“扩展”**最短路径来寻找从源顶点到其他顶点的最短路径。它的核心思想是：<strong>每次选择当前已知的最短路径</strong>，<strong>更新其邻接顶点的路径</strong>，并通过不断重复这一过程，最终得到从起点到所有其他顶点的最短路径。</p><p><strong>题目</strong>：</p><p>求G点到其余各点的最短路径（后一版代码可以更进一步求出具体路径是什么）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183818774.png" alt="image-20241113211412388" style="zoom:80%;" /><h2 id="代码实现-简洁版">代码实现(简洁版)</h2><p><code>DijkstraAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 顶点数组，表示图中的7个顶点</span></span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无限大表示没有连接的边</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 邻接矩阵表示图，0表示自己到自己，其他值表示两点之间的权重</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">            <span class="comment">// A   B   C   D   E   F   G</span></span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">10</span>, <span class="number">20</span>, N,  N,  N,  N&#125;, <span class="comment">// A</span></span><br><span class="line">            &#123;<span class="number">10</span>, <span class="number">0</span>,  N, <span class="number">30</span>, <span class="number">50</span>,  N,  N&#125;, <span class="comment">// B</span></span><br><span class="line">            &#123;<span class="number">20</span>, N, <span class="number">0</span>,  N, <span class="number">10</span>,  N,  N&#125;, <span class="comment">// C</span></span><br><span class="line">            &#123;N, <span class="number">30</span>, N, <span class="number">0</span>,  N,  N, <span class="number">60</span>&#125;,  <span class="comment">// D</span></span><br><span class="line">            &#123;N, <span class="number">50</span>, <span class="number">10</span>, N, <span class="number">0</span>,  <span class="number">20</span>, N&#125;,  <span class="comment">// E</span></span><br><span class="line">            &#123;N, N, N, N, <span class="number">20</span>, <span class="number">0</span>,  <span class="number">30</span>&#125;,  <span class="comment">// F</span></span><br><span class="line">            &#123;N, N, N, <span class="number">60</span>, N, <span class="number">30</span>, <span class="number">0</span>&#125;    <span class="comment">// G</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选择源顶点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 从 A（索引 0）开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Dijkstra 算法计算最短路径</span></span><br><span class="line">        dijkstra(matrix, start, vertex.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dijkstra 算法实现</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 邻接矩阵表示的图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexCount 顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> start, <span class="type">int</span> vertexCount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[vertexCount]; <span class="comment">// dist[i]存储从start到i的最短路径</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexCount]; <span class="comment">// visited[i]表示i节点是否已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：所有距离为无穷大，起始节点的距离为0</span></span><br><span class="line">        Arrays.fill(dist, <span class="number">65535</span>); </span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 选择未访问的节点中距离起点最小的节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minDist</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    minDist = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果所有节点都已访问，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (u == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记当前节点已访问</span></span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新与当前节点相邻节点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; vertexCount; v++) &#123;</span><br><span class="line">                <span class="comment">// 如果从u到v有路径且v节点未访问过</span></span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != <span class="number">65535</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newDist</span> <span class="operator">=</span> dist[u] + graph[u][v];</span><br><span class="line">                    <span class="keyword">if</span> (newDist &lt; dist[v]) &#123;</span><br><span class="line">                        dist[v] = newDist; <span class="comment">// 更新最短路径</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印从起始节点到其他节点的最短路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从 &quot;</span> + (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + start) + <span class="string">&quot; 出发的最短路径：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] == <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i) + <span class="string">&quot; 不可达&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i) + <span class="string">&quot; 的最短路径长度为: &quot;</span> + dist[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码实现-封装">代码实现(封装)</h2><p><code>DijkstraAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, N, N, N, N&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">0</span>, N, <span class="number">30</span>, <span class="number">50</span>, N, N&#125;,</span><br><span class="line">                &#123;<span class="number">20</span>, N, <span class="number">0</span>, N, <span class="number">10</span>, N, N&#125;,</span><br><span class="line">                &#123;N, <span class="number">30</span>, N, <span class="number">0</span>, N, N, <span class="number">60</span>&#125;,</span><br><span class="line">                &#123;N, <span class="number">50</span>, <span class="number">10</span>, N, <span class="number">0</span>, <span class="number">20</span>, N&#125;,</span><br><span class="line">                &#123;N, N, N, N, <span class="number">20</span>, <span class="number">0</span>, <span class="number">30</span>&#125;,</span><br><span class="line">                &#123;N, N, N, <span class="number">60</span>, N, <span class="number">30</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex, matrix);</span><br><span class="line"><span class="comment">//        graph.showGraph();</span></span><br><span class="line">        graph.dijkstra(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        graph.showResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="comment">//里面有三个表：1. 记录已访问过节点的表；2. 前驱节点的下标；3. 已访问的节点到其余节点的距离</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] m : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dijkstra算法实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 开始顶点（起点）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">VisitedVertex</span>(vertex.length, index);</span><br><span class="line">        update(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">            index = vis.updateArr(); <span class="comment">//选择新的访问顶点</span></span><br><span class="line">            update(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新加入index节点后 的 vis（每一个顶点对应前一个顶点的下标、访问过的顶点到其余顶点的距离）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="comment">//len = 出发顶点到index的距离 + index到j的距离</span></span><br><span class="line">            len = vis.getDis(index) + matrix[index][j];</span><br><span class="line">            <span class="keyword">if</span> (!vis.isVisited(j) &amp;&amp; len &lt; vis.getDis(j)) &#123;</span><br><span class="line">                vis.updatePre(j, index);<span class="comment">//更新j的前驱为j</span></span><br><span class="line">                vis.updateDis(j, len);<span class="comment">//更新出发节点到j的距离为len</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示结果：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showResult</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有顶点是否都已访问过?visted[]为:&quot;</span>+Arrays.toString(vis.visited));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vis.dis.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis.dis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;起点&quot;</span> + vertex[start] + <span class="string">&quot;到其余顶点的最短距离为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            System.out.println(vertex[start] + <span class="string">&quot;-&gt;&quot;</span> + vertex[i] + <span class="string">&quot;(&quot;</span> + vis.dis[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;每个顶点的前驱顶点为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex[i] != vertex[vis.preVisited[i]]) &#123;</span><br><span class="line">                System.out.println(vertex[i] + <span class="string">&quot;的pre是&quot;</span> + vertex[vis.preVisited[i]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(vertex[i] + <span class="string">&quot;是起始点&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitedVertex</span> &#123;</span><br><span class="line">    <span class="comment">//记录各个顶点是否被访问过（1访问过，0未访问）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">//每一个点对应的前一个顶点的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preVisited;</span><br><span class="line">    <span class="comment">//记录已访问过的节点到其余节点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexNums 顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index      出发节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisitedVertex</span><span class="params">(<span class="type">int</span> vertexNums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        <span class="built_in">this</span>.preVisited = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        <span class="built_in">this</span>.dis = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        dis[index] = <span class="number">0</span>;</span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preVisited.length; i++) &#123;</span><br><span class="line">            preVisited[i] = i;<span class="comment">//初始化每个顶点的前驱为自己（也就是没有前驱）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVisited</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visited[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDis</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新前驱pre顶点的前驱为index</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePre</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        preVisited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDis</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续选择并返回 下一个 访问结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateArr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; minLen) &#123;</span><br><span class="line">                minLen = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="number">1</span>;<span class="comment">//更新这个节点被访问过</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal算法</title>
      <link href="/2025/03/31/algorithm/other/Kruskal%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/algorithm/other/Kruskal%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>Kruskal算法</h1><blockquote><p>和Prim算法一样，也是求最小生成树的，先补<a href="##%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>部分知识，对于Kruskal算法的“判断该节点属于哪一类”可以有更深刻的理解。</p></blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184258850.png" alt="image-20241113100012659" style="zoom:80%;" /><p>如上图，给城市的公交站修路，使得所有点连通，同时总路径最小。</p><p><strong>思路</strong></p><ol><li>克鲁斯卡尔算法，是用来求加权连通图的最小生成树的算法。</li><li><strong>基本思想</strong>：按照权值<strong>从小到大</strong>的顺序选择n-1条边，并保证这n-1条边<strong>不构成回路</strong>。</li><li><strong>做法</strong>：<ul><li>将边按权值从小到大排序</li><li>不断将按边的权值从小到大加入森林，同时保证森林中不产生回路，直到选择了n-1条边。</li></ul></li></ol><p><strong>图解</strong></p><ol><li><p>首先有n个顶点，则需选择n-1条边</p></li><li><p>第一步选择<code>E-F[2]</code>边</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184310455.png" alt="image-20241113132132187" style="zoom: 67%;" /></li><li><p>第二步，选择<code>C-D[3]</code>边</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184320565.png" alt="image-20241113132202345" style="zoom: 67%;" /></li><li><p>第三步，选择<code>D-E[4]</code>边</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184330035.png" alt="image-20241113132232489" style="zoom: 67%;" /></li><li><p>第四步，拟选择<code>C-E[5]</code>但是发现构成回路，不能选；拟选择<code>C-F[6]</code>但是发现构成回路，不能选；故选择<code>B-F[7]</code>。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184341650.png" alt="image-20241113132535294" style="zoom: 67%;" /></li><li><p>第五步，选择<code>E-G[8]</code></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184351076.png" alt="image-20241113132631408" style="zoom: 67%;" /></li><li><p>第六步，拟选择<code>F-G[9]</code>构成回路，不能选；拟选择<code>B-C[10]</code>，构成回路，不能选；故选择<code>A-B[11]</code></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184400832.png" alt="image-20241113132754135" style="zoom: 67%;" /></li><li><p>已选择$n-1$，即6条边，最小生成树已生成。最后结果为：<code>E-F[2]</code>、<code>C-D[3]</code>、<code>D-E[4]</code>、<code>B-F[7]</code>、<code>E-G[8]</code>、<code>A-B[11]</code></p></li></ol><p>上述过程中，有两个问题需要解决：</p><ol><li><p>将边按权值从小到大排序，这个易解决</p></li><li><p>每次新加入边时，需判断是否会构成回路，这个要利用<strong>并查集</strong>：</p><ul><li>以下面状态举例：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184411676.png" alt="image-20241113132232489" style="zoom: 67%;" /></li><li>此时：<ul><li><code>C</code>的终点节点为<code>F</code></li><li><code>D</code>的终点节点为<code>F</code></li><li><code>E</code>的终点节点为<code>F</code></li><li><code>F</code>的终点节点为<code>F</code></li></ul></li><li>如果新加入的边，其两个节点的终点节点相同，比如<code>C-E[5]</code>，<code>C</code>和<code>E</code>的终点节点都为<code>F</code>，用并查集里面的术语来讲，<code>C</code>与<code>E</code>就是同一树上的节点，此时若连接<code>C</code>与<code>E</code>，则会构成回路。</li></ul><blockquote><p>不懂什么意思就看看<a href="##%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>这种数据结构。</p></blockquote></li></ol><h2 id="代码实现">代码实现</h2><p><code>KruskalDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kruskal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//此处构造是，自身顶点是0，是跟后续“并查集”的算法有关</span></span><br><span class="line">        <span class="comment">// 即，while(i != 0) &#123; i = ends[i]; &#125;，去找到&quot;根节点&quot;，判断某两条边是否是&quot;同一个集合&quot;，防止回路生成</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">11</span>, INF, INF, INF, <span class="number">13</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">                <span class="type">Kruskal</span> <span class="variable">kruskal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kruskal</span>(vertexs, matrix);</span><br><span class="line"><span class="comment">//                kruskal.print();</span></span><br><span class="line">                kruskal.createMinTree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kruskal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> edgeNum;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertexs;<span class="comment">//顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    Edge[] edges;<span class="comment">//所有边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">char</span>[] vertexs, <span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vlen</span> <span class="operator">=</span> vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexs = <span class="keyword">new</span> <span class="title class_">char</span>[vlen];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制拷贝，对外不影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="built_in">this</span>.matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">                <span class="built_in">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计边的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != INF)&#123;</span><br><span class="line">                    <span class="built_in">this</span>.edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edges = getEdges();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Edge[] getEdges()&#123;</span><br><span class="line">        Edge[] edges1 = <span class="keyword">new</span> <span class="title class_">Edge</span>[<span class="built_in">this</span>.edgeNum];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//给边赋值（由于是无向图，只需遍历上三角（不包括自身））</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != INF)&#123;</span><br><span class="line">                    edges1[k++] = <span class="keyword">new</span> <span class="title class_">Edge</span>(vertexs[i],vertexs[j],matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges1);</span><br><span class="line">        <span class="keyword">return</span> edges1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pirnt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(matrix[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印边，&quot;</span>+<span class="string">&quot;总共&quot;</span>+edges.length+<span class="string">&quot;条边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">            System.out.println(edges[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对应站点的下标  &#x27;A&#x27; -&gt; 0，找不到则-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i] == ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下标为i的顶点对应的“终点”节点 对应的下标</span></span><br><span class="line"><span class="comment">     * 用于后续判断，新加入的边是否会造成回路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 记录每个顶点的终点的数组，初始化时，每个顶点的终点都是自身</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 传入的顶点对应下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取下标为i的顶点对应的“终点”对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != ends[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> ends[i] = getEnd(ends,ends[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成最小生成树算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMinTree</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存 当前已有边的顶点的集合中 每个顶点的终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ends.length;i++)&#123;<span class="comment">//用并查集的思路，给所有节点的 根节点 设置为其自身，也就是各自为一棵树</span></span><br><span class="line">            ends[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Edge[] result = <span class="keyword">new</span> <span class="title class_">Edge</span>[vertexs.length-<span class="number">1</span>];<span class="comment">//保存最后结果（最后只需顶点数 - 1 条边即可）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//edges是在构造时，已经按照边的权值从小到大拍好的Edge数组</span></span><br><span class="line">        <span class="comment">//对边edges进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edgeNum;i++)&#123;</span><br><span class="line"><span class="comment">//            //优化</span></span><br><span class="line"><span class="comment">//            if(index == vertexs.length)&#123;</span></span><br><span class="line"><span class="comment">//                break;//此时已经能将所有顶点练成最小生成树，后面的边没必要遍历了</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前边的两个顶点的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(edges[i].start);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前边两个顶点各自的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getEnd(ends,p1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getEnd(ends,p2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若没有构成回路</span></span><br><span class="line">            <span class="keyword">if</span>(m != n)&#123;</span><br><span class="line"><span class="comment">//                ends[m] = getEnd(ends,n);//将边m的终点设置为n的终点（做了一个压缩路径！）</span></span><br><span class="line">                ends[m] = n;<span class="comment">//设置m的终点</span></span><br><span class="line">                result[index++] = edges[i];<span class="comment">//有一条边加入结果中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出最小生成树：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            System.out.println(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt;&#123;</span><br><span class="line">    <span class="type">char</span> start;<span class="comment">//起点</span></span><br><span class="line">    <span class="type">char</span> end;<span class="comment">//终点</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Edge&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;start=&quot;</span> + start +</span><br><span class="line">                <span class="string">&quot;, end=&quot;</span> + end +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prim算法</title>
      <link href="/2025/03/31/algorithm/other/Prim%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/algorithm/other/Prim%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>普利姆(Prim)算法</h1><p><strong>实际问题——修路问题</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184507327.png" alt="image-20241112171709616" style="zoom:80%;" /><p>有ABCDEFG七个村庄，修路使得村庄连通，同时要求修路公里数最小，问修路方案。</p><h2 id="最小生成树">最小生成树</h2><p>修路问题本质就是就是最小生成树问题， 先介绍一下<strong>最小生成树(Minimum Cost Spanning Tree)，简称MST</strong>。</p><ol><li><p>给定一个带权的无向连通图,如何选取一棵生成树,使树上<strong>所有边上权的总和为最小</strong>,这叫最小生成树</p></li><li><p>N个顶点，一定有N-1条边</p></li><li><p>包含全部顶点</p></li><li><p>N-1条边都在图中</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184521355.png" alt="image-20241112172040546" style="zoom:80%;" /></li><li><p><strong>求最小生成树</strong>的算法主要是<strong>普里姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p></li></ol><h2 id="普利姆算法介绍">普利姆算法介绍</h2><ol><li><p><strong>普利姆(Prim)算法</strong>求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong></p></li><li><p><strong>算法步骤</strong>：</p><ol><li>设$G=(V,E)$是连通网，$T=(U,D)$是最小生成树，$V,U$是顶点集合，$E,D$是边的集合</li><li>若从顶点$u$开始构造最小生成树，则从集合V中取出顶点$u$放入集合$U$中，标记顶点$v$的$visited[u]=1$</li><li>若集合$U$中顶点$u_i$与集合$V-U$中的顶点$v_j$之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点$v_j$加入集合$U$中，将边$(ui,vj)$加入集合$D$中，标记$visited[vj]=1$</li><li>重复步骤2，直到$U$与$V$相等，即所有顶点都被标记为访问过，此时$D$中有$n-1$条边</li></ol></li><li><p>虽然步骤用了离散数学的术语显得抽象，但是图解很清晰：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184534200.png" alt="image-20241112202738570" style="zoom:80%;" /><p>∴最终修路：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184544097.png" alt="image-20241112203225175" style="zoom:80%;" /></p></li><li><p>为什么这种“<strong>每次  在已访问过的节点的基础上  选取最短的路径加入</strong>”能得到最短总路径呢？仔细想想，是因为修路问题的题目条件是——<strong>每个节点都必须连通</strong>，因此比如一开始选取了G，他就必须要和其他的某个村庄有联系，那么不妨就选取最短的那个，每次都这样找，总的修路路径就是最短的。</p></li></ol><h2 id="代码实现">代码实现</h2><p><code>PrimAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vertexNum</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">char</span>[] villages = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//        int[][] weight = new int[vertexNum][vertexNum];</span></span><br><span class="line">        <span class="type">int</span>[][] weight = &#123;</span><br><span class="line">                &#123;INF, <span class="number">7</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF&#125;,</span><br><span class="line">                &#123;INF, <span class="number">9</span>, INF, INF, <span class="number">7</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">8</span>, <span class="number">7</span>, INF, <span class="number">7</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;INF, INF, INF, <span class="number">6</span>, <span class="number">7</span>, INF, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">4</span>, INF&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        for(int i = 0; i &lt; vertexNum; i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 0; j &lt; vertexNum; j++)&#123;</span></span><br><span class="line"><span class="comment">//                weight[i][j] = Integer.MAX_VALUE;//表示此路不通</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//输入各村庄之间的路径：</span></span><br><span class="line">        <span class="comment">//0-6 表示A-G，之后输入对应</span></span><br><span class="line"><span class="comment">//        int v1,v2,len=0;</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;输入地图数据:&quot;);//0 1 7 0 2 7 0 6 6 2 4 8 1 6 3 1 3 9 4 6 4 4 5 7 3 5 6 5 6 4 -1</span></span><br><span class="line"><span class="comment">//        while(true)&#123;</span></span><br><span class="line"><span class="comment">//            v1=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            if(v1 == -1) break;</span></span><br><span class="line"><span class="comment">//            v2=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            len=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            weight[v1][v2] = len;</span></span><br><span class="line"><span class="comment">//            weight[v2][v1] = len;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertexNum, villages, weight);</span><br><span class="line"><span class="comment">//        graph.showGraph();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MinTree</span> <span class="variable">minTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinTree</span>();</span><br><span class="line">        minTree.prim(graph, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小生成树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普利姆算法来创建最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     开始构建的顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.vertexNum];</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用v1，v2记录两个顶点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//因为有graph.vertexNum个顶点，所以prim算法结束应该有graph.vertexNum-1条边被记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; graph.vertexNum - <span class="number">1</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其实每一次就是在已访问过的节点的基础上，判断最短的路径并加入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;         <span class="comment">//访问过的节点    i</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;     <span class="comment">//未访问过的节点   j</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i] &amp;&amp; !visited[j] &amp;&amp; graph.weight[i][j] &lt; minLen) &#123;</span><br><span class="line">                        minLen = graph.weight[i][j];</span><br><span class="line">                        v1 = i;</span><br><span class="line">                        v2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;修路：&quot;</span> + graph.villages[v1] + <span class="string">&quot;&lt;--&quot;</span> + graph.weight[v1][v2] + <span class="string">&quot;--&gt;&quot;</span> + graph.villages[v2]);</span><br><span class="line">            visited[v1] = <span class="literal">true</span>;</span><br><span class="line">            visited[v2] = <span class="literal">true</span>;</span><br><span class="line">            minLen = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            //其实每一次就是在已访问过的节点的基础上，判断最短的路径并加入</span></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;graph.vertexNum;i++)&#123;         //访问过的节点    i</span></span><br><span class="line"><span class="comment">//                if(!visited[i])&#123;//找到访问过的节点i</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                for(int j=0;j&lt;graph.vertexNum;j++)&#123;     //未访问过的节点   j</span></span><br><span class="line"><span class="comment">//                    if(visited[j])&#123;//找到未访问过的节点j</span></span><br><span class="line"><span class="comment">//                        continue;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    if(graph.weight[i][j] &lt; minLen)&#123;</span></span><br><span class="line"><span class="comment">//                        minLen = graph.weight[i][j];</span></span><br><span class="line"><span class="comment">//                        v1 = i;</span></span><br><span class="line"><span class="comment">//                        v2 = j;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertexNum;<span class="comment">//节点个数</span></span><br><span class="line">    <span class="type">char</span>[] villages;</span><br><span class="line">    <span class="type">int</span>[][] weight;<span class="comment">//带权图</span></span><br><span class="line"></span><br><span class="line">    Graph(<span class="type">int</span> vertexNum, <span class="type">char</span>[] villages, <span class="type">int</span>[][] weight) &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertexNum = vertexNum;</span><br><span class="line">        <span class="built_in">this</span>.villages = villages;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    System.out.println(villages[i] + <span class="string">&quot;&lt;--&quot;</span> + weight[i][j] + <span class="string">&quot;--&gt;&quot;</span> + villages[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Prim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合覆盖问题</title>
      <link href="/2025/03/31/algorithm/other/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/algorithm/other/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>贪心-集合覆盖(简单例子)</h1><p>例子很简单，主要是了解这种思想–<strong>贪心算法</strong>[^11]</p><p><strong>题目</strong>：</p><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”, “上海”, “天津”</td></tr><tr><td>K2</td><td>“广州”, “北京”, “深圳”</td></tr><tr><td>K3</td><td>“成都”, “上海”, “杭州”</td></tr><tr><td>K4</td><td>“上海”, “天津”</td></tr><tr><td>K5</td><td>“杭州”, “大连”</td></tr></tbody></table><p><strong>步骤</strong>：</p><ol><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没有关系）</li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1步直到覆盖了全部的地区</li></ol><p><strong>代码</strong>：</p><p><code>GreedyAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.greedy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建广播电台，放入到Map</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到map</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allAreas 存放所有地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        allAreas.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList 存放所有地区</span></span><br><span class="line">        ArrayList&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历过程中的电台覆盖的地区和当前还没有覆盖的地区</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            maxKey = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                tempSet.retainAll(allAreas);<span class="comment">//retainAll是取出tempSet和allAreas中公共的，重新赋值给tempSet</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (maxKey == <span class="literal">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="literal">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;选择的电台为&quot;</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/03/31/algorithm/other/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/algorithm/other/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>KMP算法</h1><h2 id="暴力匹配法-bad">暴力匹配法(bad)</h2><p>假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p><ol><li>如果当前字符匹配成功（即<code>str1[i] == str2[j]</code>），则<code>i++，j++</code>，继续匹配下一个字符</li><li>如果失配（即<code>str1[i]! = str2[j]</code>），令<code>i = i - (j - 1)，j = 0</code>。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。</li></ol><h2 id="暴力匹配代码实现">暴力匹配代码实现</h2><p><code>ViolenceMatch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolenceMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;yukinoYukinoShiTAyukinoYukinoshitaYukino&quot;</span>;<span class="comment">//23</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;YukinoshitaYukino&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> violenceMatch(s1,s2);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配算法实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向s1的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向s2的索引</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有匹配成功</span></span><br><span class="line">                i = i-(j-<span class="number">1</span>);</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="KMP算法">KMP算法</h2><p><strong>KMP算法介绍</strong></p><ol><li>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li><li><strong>Knuth-Morris-Pratt 字符串查找算法</strong>，简称为 “<strong>KMP算法</strong>”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法</li><li>KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li><li><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">参考blog</a></li></ol><p><strong>示例-字符串匹配问题</strong></p><ol><li>有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=“ABCDABD”</li><li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li><li>要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法</li></ol><h3 id="详细思路">详细思路</h3><blockquote><p>最详细的见此：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">blog</a></p></blockquote><p>以<code>str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;</code>以及<code>str2 = &quot;ABCDABD&quot;</code>进行举例，判断str1中是否含有str2。</p><ol><li><p>首先，用str1的第一个字符与str2的第一个字符比较，发现不匹配，则关键词后移一位</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183957359.png" alt="image-20241112093421135" style="zoom:80%;" /></li><li><p>再往后比较，不匹配则一直重复步骤1</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184008287.png" alt="image-20241112093602904" style="zoom:80%;" /></li><li><p>重复步骤1，直到找到str1中和str2的第一个字符匹配（如下：）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184022570.png" alt="image-20241112093800648" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184031989.png" alt="image-20241112093851050" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184041469.png" alt="image-20241112093929032" style="zoom:80%;" /></li><li><p>之后方别移动<code>i</code>和<code>j</code>，比较两个str1与str2的重合度，发现当子串到最后的<code>'D'</code>时与源字符串的<code>' '</code>不匹配</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184051782.png" alt="image-20241112094320306" style="zoom:80%;" /></li><li><p>之后就是与暴力匹配有所区别的地方，不能简单地再让子串第一个字母A与源字符串的’B’、‘C’、‘D’进行比较，这些步骤都是浪费的，因为第4步其实已经比较过&quot;BCD&quot;了，我们知道了子串的第一个字符’A’不可能与’B’、‘C’、'D’匹配上。更准确说，当str1的空格与str2的’D’不匹配时，我们已经遍历过str1中的&quot;ABCDAB&quot;，所以正确地做法是将子串直接移动到下一个’A’的位置，这样子做才能提升搜索效率，而不要再让B与A比较</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184102724.png" alt="image-20241112130246079" style="zoom:80%;" /></li><li><p>怎么样能把这些重复步骤省略呢？我们可以对子串<code>str2</code>计算<strong>部分匹配表</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184113625.png" alt="image-20241112151917543" style="zoom:80%;" /><ul><li>如何得到部分匹配表？</li><li>先介绍<strong>前缀</strong>与<strong>后缀</strong>，例如字符&quot;yukino&quot;，<strong>前缀</strong>就是&quot;y&quot;、“yu”、“yuk”、“yuki”、“yukin”；<strong>后缀</strong>就是&quot;o&quot;、“no”、“ino”、“kino”、“ukino”</li><li><strong>部分匹配值</strong>：一个字符串前缀和后缀共有元素的最大长度，回到&quot;ABCDADB&quot;这个例子：<ul><li>&quot;A&quot;前缀和后缀都为空，所以部分匹配值为0</li><li>“AB&quot;的前缀是&quot;A”，后缀是&quot;B&quot;，所以部分匹配值为0</li><li>“ABC&quot;的前缀是&quot;A”、“AB”，后缀是&quot;B&quot;、“BC”，所以部分匹配值为0</li><li>“ABCD&quot;的前缀是&quot;A”、“AB”、“ABC”，后缀是&quot;D&quot;、“CD”、“BCD”，所以部分匹配值为0</li><li>“ABCDA&quot;的前缀是&quot;<strong>A</strong>”、“AB”、“ABC”、“ABCD”，后缀是&quot;<strong>A</strong>&quot;、“DA”、“CDA”、“BCDA”，所以部分匹配值为1</li><li>“ABCDAB&quot;的前缀是&quot;A”、“<strong>AB</strong>”、“ABC”、“ABCD”、“ABCDA”，后缀是&quot;B&quot;、“<strong>AB</strong>”、“DAB”、“CDAB”、“BCDAB”，所以部分匹配值为2</li><li>同理，&quot;ABCDABD&quot;的部分匹配值为0</li></ul></li><li>这样就能从理论层面，知道如何得到部分匹配值表。（关键是看代码怎么实现——利用<code>next</code>数组）</li></ul></li><li><p>那么这个表怎么用呢？回到刚才str1中的空格与str2中的D不匹配的时刻，此时前六个字符&quot;ABCDAB&quot;是匹配的，最后一个字符&quot;B&quot;对应的&quot;部分匹配值&quot;为2，因此按照如下公式移动步数：<br>$$<br>移动位数=已匹配的字符数-部分匹配值<br>$$<br>因此此时移动的步数为：$6-2=4$步，如下所示：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184124459.png" alt="image-20241112131045712" style="zoom:80%;" /></li><li><p>下一次发现，空格与字符C又不匹配，同样根据公式计算，需移动$2(已匹配字符数)-0(第一个字符’B’所对应的部分匹配值)=2$步：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184134958.png" alt="image-20241112131333017" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184147716.png" alt="image-20241112131418061" style="zoom:80%;" /></li><li><p>后续步骤同理，不再说明，下图匹配成功。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501184158779.png" alt="image-20241112131807060" style="zoom:80%;" /></li><li><p>至此也理解了这个移动的公式的妙处，但是如何用代码实现？（利用<code>next</code>数组）</p></li></ol><p><strong>代码思路总结</strong>：</p><ol><li>获得子串的部分匹配值表<code>next</code></li><li>使用部分匹配值表完成kmp搜索</li></ol><h3 id="代码实现">代码实现</h3><p><code>KMP</code></p><p>ps：核心的就是两个方法——<code>kmpNext</code>求出子串的部分匹配表，<code>kmpSearch</code>kmp搜索。其中最最核心的，分别是这两个方法中的<code>while</code>语句，是如何处理<code>j</code>的更新的！两个方法中的<code>i</code>和<code>j</code>含义各有不同。至于为什么<code>j = next[j-1]</code>，则见博客底层原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = kmpNext(str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;部分匹配值表：&quot;</span>+Arrays.toString(next));</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配的第一个下标为：&quot;</span>+kmpSearch(str1,str2,next));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kmp搜索算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个匹配的位置，否则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i)!=str2.charAt(j)的情况，去调整j的大小</span></span><br><span class="line">            <span class="comment">//KMP算法核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子串的部分匹配表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String str) &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果字符串长度为1，部分匹配值一定是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当str.charAt(i) != str.charAt(j)时，需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有 str.charAt(i) == str.charAt(j) 成立时才退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心……</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当str.charAt(i) == str.charAt(j)时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2025/03/31/algorithm/other/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/algorithm/other/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>背包问题</h1><p>在解决 <strong>0-1 背包问题</strong>时，我们的目标是选择若干物品放入背包，使得背包内物品的总价值最大，同时遵循背包容量的限制。具体来说，给定一组物品，每个物品都有一个 <strong>重量</strong> 和 <strong>价值</strong>，并且背包的容量也是有限的。我们需要从这些物品中选择一些，放入容量有限的背包中，要求背包内物品的 <strong>总重量不超过背包的容量</strong>，而 <strong>总价值最大</strong>。</p><p><strong>0-1 背包的动态规划解法</strong>：</p><ol><li>设有 $n$个物品，每个物品 $i $的 <strong>价值</strong> 为 $ v[i]$，<strong>重量</strong> 为 $w[i]$，背包的最大容量为 $C$。</li><li>定义一个二维数组 $ dp[i][j] $，表示考虑前 $ i $ 个物品，背包容量为 $j $ 时，能够获得的最大价值。即$ dp[i][j] $ 是当前背包容量 $j $ 和物品选择方案下的最大价值。</li></ol><p><strong>递推公式</strong>：</p><ul><li><p><strong>初始化</strong>：</p><ul><li>$dp[0][j] = 0  $（表示没有物品时，背包的最大价值为 0）</li><li>$dp[i][0] = 0 $（表示背包容量为 0 时，无论选择哪些物品，总价值也为 0）</li></ul></li><li><p><strong>状态转移</strong>：<br>对于每个物品 $ i $和每个容量 $j$：</p><ul><li><p><strong>如果当前物品的重量</strong> $w[i] &gt; j$（即当前背包容量不足以容纳这个物品），那么不能放入该物品，此时的最优解就是不放物品 $i$，即：<br>$dp[i][j] = dp[i-1][j]$</p></li><li><p><strong>如果当前物品的重量</strong> $w[i] \leq j$（即背包容量足够容纳当前物品），有两种选择：</p><ol><li>不选择物品 $i $，此时的最优解为 $dp[i-1][j] $（即与不放入该物品时的情况一样）。</li><li>选择物品 $ i $，此时的最优解为物品 $ i $ 的价值加上剩余容量 $j - w[i] $ 能容纳的最大价值，即 $dp[i-1][j - w[i]] + v[i] $。</li></ol><p>这时我们需要取两者中的最大值：<br>$$<br>dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])<br>$$</p></li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>$ dp[i][j] $ 表示在考虑前 $ i $ 个物品、容量为 $ j $ 的背包时，能够获得的最大价值。</li><li>对于每个物品 $ i $，如果它的重量 $ w[i] $ 超过当前背包容量 $ j $，就不能选它；否则，我们就要在 <strong>选择它</strong> 或 <strong>不选择它</strong> 之间做出最优决策，选择价值更大的方案。</li></ul><p><strong>完整算法</strong>：</p><ol><li>初始化 $ dp[0][j] = 0 $ 和 $ dp[i][0] = 0 $。</li><li>对每个物品 $ i $ 和每个背包容量 $ j $ 更新 $ dp[i][j] $。</li><li>最终答案就是 $ dp[n][C] $，表示在所有 $ n $ 个物品和容量为 $ C $ 的背包情况下，能够获得的最大价值。</li></ol><p><strong>图解</strong></p><ol><li><p><code>weights</code>物品重量、<code>values</code>物品价值、<code>dp</code>用于求解的数组（初始化如下）（黄色部分是未来求解区）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183319480.png" alt="image-20241114134226051" style="zoom:80%;" /></li><li><p>当考虑第一件物品时：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183330273.png" alt="image-20241114134455411" style="zoom:80%;" /></li><li><p>考虑第二件物品时：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183344517.png" alt="image-20241114134526878" style="zoom:80%;" /></li><li><p>考虑第三件物品：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183355229.png" alt="image-20241114135349739" style="zoom:80%;" /></li></ol><h2 id="代码实现">代码实现</h2><p><code>KnapsackProblem</code></p><blockquote><p><strong>空间优化</strong>：可以通过只使用一维数组来优化空间复杂度。因为每一行的状态仅依赖于前一行的状态。（拓展）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.dynamicProgramming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 物品的重量</span></span><br><span class="line">        <span class="type">int</span>[] weights = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 物品的价值</span></span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 物品数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numItems</span> <span class="operator">=</span> weights.length;</span><br><span class="line">        <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示考虑前 i 个物品，背包容量为 j 时能够获得的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[numItems + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了记录被放入背包的商品，定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] path = <span class="keyword">new</span> <span class="title class_">int</span>[numItems + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划求解最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= numItems; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &gt; j) &#123; <span class="comment">// 当前背包容量不足以放入物品 i</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果放入当前物品 i 会得到更大的价值，更新 dp[i][j] 和 path</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt; dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>];</span><br><span class="line">                        path[i][j] = <span class="number">1</span>; <span class="comment">// 记录当前物品 i 被放入背包</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 dp 数组，查看每个容量下的最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(row));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最大能够装入的价值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大能装的价值为：&quot;</span> + dp[numItems][capacity]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出放入背包的物品</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> numItems;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> capacity;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入背包\n&quot;</span>, i);</span><br><span class="line">                j -= weights[i - <span class="number">1</span>]; <span class="comment">// 剩余背包容量</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 遍历前一个物品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2025/03/31/algorithm/other/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/algorithm/other/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>汉诺塔问题</h1><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><strong>思路</strong>：</p><p>如果是有一个盘， A-&gt;C</p><p>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘——<strong>一是最下边的盘</strong>，<strong>二是上面的其余所有盘</strong></p><ol><li>先把 最上面的盘 A-&gt;B，中间需借助C盘，即<code>hanoiTower(num-1,a,c,b)</code></li><li>再把最下边的盘 A-&gt;C，<code>System.out.println(&quot;第&quot;+num+&quot;个盘从 &quot;+&quot;A-&gt;C&quot;)</code></li><li>最后把B塔的所有盘 从 B-&gt;C，中间需借助A盘，即<code>hanoiTower(num-1,b,a,c)</code></li></ol><h2 id="代码实现">代码实现</h2><p><code>HanoiTower</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.hanoitower;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiTower</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用分治算法解决汉诺塔问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果num &gt;= 2，我们总是可以看两个盘：1最下面的盘 和 上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把 上面的盘从A移动到B，移动过程会使用到C</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">            <span class="comment">//2. 再把 最下面的盘从A移动到C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+num+<span class="string">&quot;个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">            <span class="comment">//3. 把 B中所有盘移动到C，移动过程使用到A</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/2025/03/31/algorithm/other/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2025/03/31/algorithm/other/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1>广度优先搜索（BFS）</h1><p>图的广度优先搜索(Broad First Search) 。类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p><p><strong>广度优先遍历算法步骤</strong></p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol><li>若结点w尚未被访问，则访问结点w并标记为已访问。</li><li>结点w入队列</li><li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol></li></ol><p><strong>广度优先搜索抽象图解</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183430473.png" alt="image-20241114115852877" style="zoom: 80%;" /><h2 id="代码实现">代码实现</h2><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//记录某个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有节点（确保所有点都被访问）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                bfs(vis,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] vis, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> u;<span class="comment">//表示队列的头节点对应下标</span></span><br><span class="line">        <span class="type">int</span> w;<span class="comment">//邻接节点w</span></span><br><span class="line">        <span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问结点，输出结点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将这个结点加入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列的头节点下标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接节点的下标</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">if</span> (!vis[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">                    vis[w] = <span class="literal">true</span>;</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱，找w后面的下一个邻接节点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （？存疑）根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 上一个节点的行号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 上一个节点的列号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点在vertexList的下标j，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个邻接节点的下标，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/2025/03/31/algorithm/other/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2025/03/31/algorithm/other/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1>深度优先搜索（DFS）</h1><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)<strong>深度优先遍历</strong> (2)<strong>广度优先遍历</strong></p><p><strong>图的深度优先搜索</strong>（<strong>Depth First Search</strong>）</p><ol><li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li><li>显然，深度优先搜索是一个递归的过程</li></ol><p><strong>算法步骤</strong></p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><p><strong>深度优先遍历抽象图解</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183733242.png" alt="image-20241114115759159" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><p>以此为例：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183745163.png" alt="image-20241111093246143" style="zoom:80%;" /><p>从A开始遍历，遍历所有节点</p><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//记录某个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        graph.dfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs重载，遍历所有节点，进行dfs（确保了所有点能被访问到）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            dfs(vis, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从某一个节点开始，进行深度优先搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] visited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//说明有下一个邻接节点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;<span class="comment">//再加上没有被访问过</span></span><br><span class="line">                dfs(visited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过，得找下一个</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （？存疑）根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 上一个节点的行号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 上一个节点的列号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点在vertexList的下标j，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个邻接节点的下标，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契查找</title>
      <link href="/2025/03/31/algorithm/search/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/algorithm/search/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>斐波那契查找算法（黄金分割法）</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong>：</p><ol><li><strong>黄金分割</strong>点是指将一条线段分成两段，使其中一部分与全长的比例等于另一部分与这部分之比，近似值$0.618$。</li><li><strong>斐波那契数列</strong>${1,1,2,3,5,8,13,21,34,55}$，发现斐波那契数列两个相邻数的比例无限接近于黄金分割0.618。<ul><li>ps：$fibo[n]=fibo[n-1]+fibo[n-2],n&gt;2;fibo[1]=fibo[2]=1$</li></ul></li></ol><p><strong>原理</strong>：</p><p><strong>斐波那契查找</strong>和<strong>二分查找</strong>、<strong>插值查找</strong>很像，仅仅改变了中间结点<code>mid</code>，即$mid = low+F(k-1)-1$</p><p>对于$F(k-1)-1$的理解：(结合图进行理解！)</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183252432.png" alt="image-20241102174615812" style="zoom:80%;" /><ol><li><p>由斐波那契数列$F[k]=F[k-1]+F[k-2]$的性质，可以得到$(F[k]-1) = (F[k-1]-1)+(F[k-2]-1)+1$，这里把<strong>每一个括号</strong>看成一个整体，对应上图的三个部分！可见等式右边的<code>+1</code>就是<code>mid</code>。即：<code>mid = low + F(k-1)-1</code></p></li><li><p>类似的，每一个子段也可以照此方式进行分割</p></li><li><p>但顺序表长度n不一定刚好等于$F[k]-1$，所以需要将原来的顺序表长度n增加至$F[k]-1$。这里的k值只要能使得$F[k]-1$大于等于n即可，由<code>while(n&gt;fib(k)-1) k++</code>得到k值。顺序表长度增加后，新增的位置<code>n+1到fib[k]-1</code>都赋值为n位置的值即可。</p></li></ol><blockquote><p>第三点相对不好理解，结合代码来看吧。</p></blockquote><h2 id="代码实现">代码实现</h2><blockquote><p>代码实现一定要多看多理解，不是那种光看理论就能立刻想出来对应代码的算法</p></blockquote><p><code>FibonacciSearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">520</span>, <span class="number">1000</span>, <span class="number">1234</span>,&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span>+fibSearch(arr,<span class="number">89</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归方式得到一个fibonacci数列数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib() &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契查找算法</span></span><br><span class="line"><span class="comment">     * 使用非递归方式编写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要查找的关键码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，没有则返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] f = fib();</span><br><span class="line">        <span class="comment">//获取到k值</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k]的值可能大于arr的长度，因此使用Arrays类，构造一个新的数组，指向arr[]</span></span><br><span class="line">        <span class="comment">//不足的部分用0补足</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">        <span class="comment">//新填充的部分用原数组的最后一个元素补齐</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">// 说明应该继续向左边查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//k--的说明：</span></span><br><span class="line">                <span class="comment">//全部元素 = 前面元素 + 后面元素</span></span><br><span class="line">                <span class="comment">//f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为前面有f[k-1]个元素</span></span><br><span class="line">                <span class="comment">//所以k--，相当于下次是对前面的、大小为f[k-1]的数组操作</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp[mid]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//k -=2的说明：</span></span><br><span class="line">                <span class="comment">//全部元素 = 前面元素 + 后面元素</span></span><br><span class="line">                <span class="comment">//f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为后面有f[k-2]个元素</span></span><br><span class="line">                <span class="comment">//所以k-=2，相当于下次是对后面的、大小为f[k-2]的数组操作</span></span><br><span class="line">                k -=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//但需要确定返回的是哪个</span></span><br><span class="line">                <span class="keyword">if</span>(mid&lt;=high)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 斐波那契查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值查找</title>
      <link href="/2025/03/31/algorithm/search/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/algorithm/search/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>插值查找</h1><h2 id="思路分析">思路分析</h2><p><strong>原理介绍</strong>：</p><ol><li>插值查找类似于二分查找，不同的是插值查找每次从<strong>自适应mid</strong>处开始查找。</li><li>将折半查找中的求mid的公式进行了改进如下：</li></ol><p>$$<br>mid = \frac{low+high}{2}=low+\frac{1}{2}(high-low) \quad =&gt; \quad mid=low+\frac{key-a[low]}{a[high]-a[low]}(high-low)<br>$$</p><ul><li>说明：low相当于left，high相当于right，key就是要找的值targetVal</li></ul><ol start="3"><li>插值查找求mid代码为：<code>int midIndex = low + (high - low)*(key - a[low])/(a[high] - a[low])</code></li><li>相当于之前的$\frac{1}{2}$变成了与要查找的值有关的系数。改进了二分查找的：<code>int mid = left + (right - left)</code></li></ol><p><strong>图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183142214.png" alt="image-20241102171312731" style="zoom:80%;" /><blockquote><p>最精髓的地方在于自适应的mid</p></blockquote><p><strong>注意事项</strong>：</p><ol><li>对于数据量较大，<strong>关键字分布较均匀</strong>的查找表来说，采用<strong>插值查找</strong>，<strong>速度较快</strong>。</li><li>关键字分布不均的情况下，该方法不一定比二分查找要好。</li></ol><h2 id="代码实现">代码实现</h2><p><code>InsertValueSearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> insertValueSearch(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,target);</span><br><span class="line">        System.out.println(<span class="string">&quot;查找的目标值&quot;</span>+target+<span class="string">&quot;的下标为：&quot;</span>+index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertValueSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//说明：target &lt; arr[0] || target &gt; arr[arr.length - 1]必须需要！</span></span><br><span class="line">        <span class="comment">//否则得到的mid值可能越界！(会导致某条语句出错……)</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || target &lt; arr[<span class="number">0</span>] || target &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求mid的公式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (target - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">            res = insertValueSearch(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">            res = insertValueSearch(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 插值查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2025/03/31/algorithm/search/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/algorithm/search/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>二分查找(经典)</h1><h2 id="思路分析">思路分析</h2><ol><li>首先确定该数组中间元素的下标<code>mid = (l+r)/2</code></li><li>然后让要查找的目标值与中间值比对<ul><li>如果<code>targetVal &gt; arr[mid]</code>，则说明要查找的值在右边，需要<strong>递归</strong>向右查询</li><li>如果<code>targetVal &lt; arr[mid]</code>，则说明要查找的值在左边，需要<strong>递归</strong>向左查询</li><li>如果<code>targetVal == arr[mid]</code>，已找到目标值</li></ul></li><li>什么时候需要退出递归？<ul><li>找到就结束递归</li><li>遍历完整个数组都没找到，即<code>left&gt;right</code>时</li></ul></li></ol><p><strong>图解演示找不到的情况</strong>:</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183204927.png" alt="image-20241101205538157" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183215893.png" alt="image-20241101205646047" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183225564.png" alt="image-20241101205747596" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><h3 id="递归实现1">递归实现1</h3><blockquote><p>查找返回一个符合条件的值</p></blockquote><p><code>BinarySearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用二分的前提：数组有序(ASC or DESC)</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">53</span>, <span class="number">84</span>, <span class="number">190</span>, <span class="number">201</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (targetIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;目标值%d的下标为：%d\n&quot;</span>, target, targetIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到该值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">            targetIndex = binarySearch(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; arr[mid]) &#123;</span><br><span class="line">            targetIndex = binarySearch(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetIndex = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> targetIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归实现2">递归实现2</h3><blockquote><p>上述算法实现仅能返回一个符合条件的目标值的下标，下面进行修改</p></blockquote><p>修改思路为：</p><p>当二分查找内部进入<code>else</code>语句时，说明已经找了了某个值，后续就是return语句。</p><p>所以我们可以在else中：先将mid加入到list中，再向左、右邻近元素查询，若还有目标值就加入，方法返回类型也改为List。</p><p>下面是核心部分修改：</p><p><code>方法binarySearch2()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//说明左边已经没有target了</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt;= arr.length || arr[temp] != target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非递归实现">非递归实现</h3><p><code>BinarySearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.binarySearchNoRecur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchNoRecur</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找下标为：&quot;</span>+binarySearch(arr,<span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>堆排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong></p><ol><li>堆排序是利用堆这种数据结构设计的一种算法，堆排序是一种选择排序，最坏、最好、平均时间复杂度为$0(n\log n)$，是不稳定排序。</li><li>堆是具有以下性质的<strong>完全二叉树</strong>：每个节点的值都大于等于其左右子节点的值，成为<strong>大顶堆</strong>；每个节点的值都小于等于其左右子节点的值，成为<strong>小顶堆</strong>。</li><li>大顶堆<strong>图解</strong>，以及其映射到数组的形式（前有讲<a href="###%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a>）。</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180722901.png" alt="image-20241104200655911" style="zoom:80%;" /><ol start="4"><li>一般升序用大顶堆，降序用小顶堆。</li></ol><blockquote><p>代码实现上：化为大顶堆形式后，通过将root<strong>沉底</strong>的方式，将最大元素放到数组末尾</p></blockquote><p><strong>基本思想</strong></p><p>若要完成升序排序，采用大顶堆：</p><ol><li>将待排序序列构成一个<strong>大顶堆</strong>（数组形式）。</li><li>此时，序列最大值就是堆顶的根节点。</li><li>将其与末尾元素进行<strong>交换</strong>，此时末尾就成为最大元素。</li><li>然后将剩余$n-1$个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</li></ol><blockquote><p>可见在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列。</p><blockquote><p>上述过程，初见，抽象。图解：</p></blockquote></blockquote><h3 id="思路分析（清晰版）">思路分析（清晰版）</h3><p><strong>构造大根堆图解</strong>：</p><blockquote><p>如果不能看懂，移步原文-&gt;菜鸟教程：<a href="https://www.runoob.com/data-structures/heap-storage.html">堆的基本存储</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-shift-up.html">堆的shift up</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-shift-down.html">堆的shift down</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-sort.html">基础堆排序</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-sort-optimization.html">优化堆排序</a></p></blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180736783.png" alt="image-20241105185854553" style="zoom:80%;" /><ol><li>上图为初始状态，首先利用完全二叉树的性质，得到<strong>第一个非叶子节点</strong>的位置——<code>k = arr.length/2</code>，也就是下标为5，值为22的节点（二叉树只是为了便于理解，实际存储方式是顺序），上图可见：只要<code>1&lt;=i&lt;=5</code>这个范围内的，都需要进行调整。目前这一步先对5这棵子树进行<strong>调整</strong>。</li></ol><ul><li><blockquote><p>调整：对应<a href="https://www.runoob.com/data-structures/heap-shift-down.html">堆的shift up</a>，这里简单说明一下：</p><p>比较当前节点与其左右子节点的大小关系，找到最大的那个与当前节点交换（这里是5号与10号进行交换）</p></blockquote></li></ul><ol start="2"><li>第一步调整完结果如下。提示：节点标绿表示不需要再被操作的节点，标红表示当前要继续操作的节点：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180753119.png" alt="image-20241105190611082" style="zoom:80%;" /><ol start="3"><li>同样道理的，对4号节点进行同样的<strong>调整</strong>。需要将4号与9号交换位置。</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180805455.png" alt="image-20241105190918145" style="zoom:80%;" /><ol start="4"><li>对3号操作，需要将3号与7号交换：（原图没标绿……手动标一下……）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180819527.png" alt="image-20241105191115658" style="zoom:80%;" /><ol start="4"><li>对2号操作，将2号于5号交换：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180833603.png" alt="image-20241105191218231" style="zoom:80%;" /><ol start="5"><li>最后对1号，也就是根节点进行调整，实现了一个大顶堆：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180847848.png" alt="image-20241105191311699" style="zoom:80%;" /><p><strong>思路对应代码部分</strong>：</p><p>上述思路的<strong>调整</strong>，对应代码的<code>adjustHeap</code>方法，</p><p>而对于<strong>从第一个非叶子节点处理到根节点</strong>的代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">//调整操作</span></span><br><span class="line">    adjustHeap(arr,i,arr,length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上述过程调整为一个大顶堆的操作应该能理解了，但最终目的还是为了实现对整个数组的<strong>升序排序</strong>，大顶堆只是这个过程用到的工具。</p><p>后续操作参考<a href="https://www.runoob.com/data-structures/heap-sort-optimization.html">优化堆排序</a>。将堆顶最大元素与末尾元素交换，但是此时破坏了大顶堆的结构，我们可以利用已写好的<code>adjustHeap</code>方法，从上至下，可以对照二叉树来看，也可以看数组：</p><p>注意：</p><p>代码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j= arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp = arr[j];<span class="comment">//将底部元素与顶部元素交换</span></span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们每交换一次首尾，仅使用一次<code>adjustHeap</code>就可以把整个结构重新调整回大顶堆，理由是：交换完最大元素和末尾元素后，整个结构本身就是很有序的，换句话说，除了根节点，其他的子树都符合&quot;大顶堆&quot;的结构（父节点大于其左右子节点）。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180901534.png" alt="image-20241105192344775" style="zoom:80%;" /><blockquote><p>至此，解释完了所有的代码，再不理解，就静下来慢慢看，或者看看别的文章（这些文章我还没看，虽然都找了，但是光看菜鸟就看懂了<a href="https://blog.csdn.net/u010452388/article/details/81283998">博客1</a>、<a href="https://zhuanlan.zhihu.com/p/124885051">博客2</a>、<a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">博客3</a>），或者代码debug看看，或者画图一步步走下去，或者……</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>1</td></tr><tr><td>50000</td><td>5</td></tr><tr><td>80000</td><td>8</td></tr><tr><td>140000</td><td>13</td></tr><tr><td>500000</td><td>46</td></tr><tr><td>900000</td><td>83</td></tr></tbody></table><p><code>HeapSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分步演示：</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp = arr[j];<span class="comment">//将底部元素与顶部元素交换</span></span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将以i对应的非叶子节点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子节点在数组中索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行调整,length逐渐减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//k=2*i+1 是指节点i的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//左子节点小于右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;<span class="comment">//子节点大于父节点</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;<span class="comment">//i变为k，继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环结束，已经将以i为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>基数排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>介绍</strong>：</p><p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数<strong>切割</strong>成不同的数字，然后<strong>按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。–<a href="https://www.runoob.com/w3cnote/radix-sort.html">菜鸟教程</a></p><p><strong>基本思想</strong>:</p><p>将所有待比较数值统一为同样的数值长度，数位较短的前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成后，数据序列就变有序了。</p><blockquote><p>LSD(最低位优先)基数排序思想↑，另有MSD(最高位优先)实现方式。参考<a href="https://blog.csdn.net/m0_64003319/article/details/134540648">blog</a>。</p></blockquote><p><strong>图解</strong>（非常好の图）：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181308737.png" alt="image-20241101173253304" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181321623.png" alt="image-20241101173316664" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181332742.png" alt="image-20241101173347735" style="zoom:80%;" /><p><strong>代码思路</strong>：</p><ol><li>关于上面桶如何表示？用一个二维数组<code>int[][] bucket = new int[10][?]</code>，？处要填<code>arr.length</code>，防止数据溢出。</li><li>所以基数排序就是<strong>空间换时间</strong>的经典算法。</li><li>在某轮取数据时，我们怎么知道要从某个桶中取几个数？因此需要有一个方法，告诉我们<strong>每个桶中有几个数据</strong>。</li><li>因此定义一个一维数组``，表示每轮10个桶中的有效数据个数。</li></ol><blockquote><p>可以形象地表示为不断把元素<strong>放入桶中</strong>，再<strong>从桶中取出</strong>的过程。这样一放一取要执行<code>maxLength</code>轮（<code>maxLength</code>为最高位数长度）</p></blockquote><p><strong>小结</strong>：</p><p>速度快+稳定，但是空间耗费巨大。</p><blockquote><p>特别注意：基数排序只适用于正数的情况（问题出在去<code>maxLength</code>那里，不能有负数）。</p><p>额外的<strong>解决方案</strong>[^6]有两个：<a href="###%E5%81%8F%E7%A7%BB%E6%B3%95">偏移法</a>或<a href="###%E5%88%86%E5%BC%80%E5%A4%84%E7%90%86">分开处理</a>（正数与负数），可跳转见补充方案详解</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>2</td></tr><tr><td>50000</td><td>3</td></tr><tr><td>80000</td><td>10</td></tr><tr><td>140000</td><td>14</td></tr><tr><td>500000</td><td>35</td></tr><tr><td>900000</td><td>35</td></tr></tbody></table><p><code>RadixSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取最大位数!</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();<span class="comment">//少女口阿！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//放入桶中的过程</span></span><br><span class="line">            <span class="comment">//对arr中每个元素遍历，取出其第i位数放入对应桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">                bucketCounts[digit]++;<span class="comment">//用于记录第digit个桶中元素的个数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从桶中取出的过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;<span class="comment">//从桶中取出的过程</span></span><br><span class="line">                <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;<span class="comment">//若第j个桶不为空</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                        arr[index++] = buckets[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//从这个桶中取出元素后，一定要清零!bucketCounts[j] = 0</span></span><br><span class="line">                    bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        radixSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>归并排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>归并排序是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的分治[^5]策略。</p><p><strong>图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181013324.png" alt="image-20241101153840659" style="zoom:80%;" /><p><strong>代码流程图</strong>：</p><img src="https://blogs.muxueavid.top/blogs/归并排序/blog-20250501181116118.jpeg" alt="image-20241101153840659" style="zoom:80%;" /><p><strong>提示+代码思路</strong>：</p><ol><li>归并排序执行次数为<code>N-1</code>次，N为数据量大小，即<code>merge</code>方法执行的次数。</li><li>由图解可知，我们需要完成“<strong>分</strong>”和“<strong>治</strong>”两个步骤：<ul><li>治，也就是合并<code>merge</code>的过程</li><li>merge需要参数为——int[] arr、left、right、mid、int[] temp</li><li><code>arr</code>为原数组</li><li><code>left</code>为待合并数据的左边位置、<code>right</code>为待合并数据的右边位置</li><li><code>mid=(left+right)/2</code></li><li><code>temp</code>为临时数组<ol><li>merge是是对两个有序数组合并的过程（见红色箭头），单个元素的数组无疑是有序的。</li><li>合并时，需要有一个i、j分别代表左数组和右数组，依次比较，将小的那个元素放入到临时数组temp中</li><li>然后将左（或右）数组中剩余元素放入到temp中</li><li>最后将temp中元素拷贝到arr中</li></ol></li><li>分，也就是不断将大问题化为小问题的过程：</li><li>如果传入参数<code>left&lt;right</code>，就不断向左、右递归，进行拆分。<ol><li>对<code>mergeSort</code>进行左右递归即可：</li><li><code>mergeSort(arr,left,mid,temp)</code></li><li><code>mergeSort(arr,mid+1,right,temp)</code></li><li><code>merge(left,right)</code></li></ol></li></ul></li></ol><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>2</td></tr><tr><td>50000</td><td>7</td></tr><tr><td>80000</td><td>18</td></tr><tr><td>140000</td><td>22</td></tr><tr><td>500000</td><td>57</td></tr><tr><td>900000</td><td>93</td></tr></tbody></table><p><code>MergeSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];<span class="comment">//需要一个额外的空间开销</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);<span class="comment">//向左递归--分</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//向右递归--分</span></span><br><span class="line">            merge(arr, left, right, mid, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;<span class="comment">//左边有序数组索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;<span class="comment">//右边有序数组索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//临时数组temp所指</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个有序数组比较、放入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将其中一个剩余的放入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将temp拷贝到arr</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= right) &#123;</span><br><span class="line">            arr[k++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">900000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>快速排序(经典)</h1><blockquote><p>实现1参考了<a href="https://blog.csdn.net/qq_39181839/article/details/109478094">博客</a>，快排讲得很清晰，看完思路代码容易自己写出来。(开头给出的<strong>各类排序算法的总结图</strong>真的很好！)</p><p>实现2参考了atguigu<a href="https://www.bilibili.com/video/BV1E4411H73v/?spm_id_from=333.788.videopod.episodes&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=67">视频</a>，代码部分稍难理解，if条件判断过多，重要的是，代码不美观。</p><p>另外还有一篇<a href="https://blog.csdn.net/justidle/article/details/104203963">博客</a>提到了<strong>原地排序</strong>和<strong>非原地排序</strong>的概念，涉及到空间复杂度，有空了解一下。</p></blockquote><h2 id="思路分析">思路分析</h2><p>快速排序是对冒泡排序的一种改进。有分治[^5]思想</p><p><strong>基本思想</strong>为：</p><p>通过一趟排序将待排序元素<strong>分割</strong>成独立的两个部分，其中<strong>一部分的所有数据要比另一部分的所有数据要小</strong>，然后再按此方法对这两部分分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此使得所有数据变成有序序列。</p><blockquote><p>但是光凭这个基本思想还没法写出代码</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>1</td></tr><tr><td>50000</td><td>6</td></tr><tr><td>80000</td><td>9</td></tr><tr><td>140000</td><td>12</td></tr><tr><td>500000</td><td>37</td></tr><tr><td>900000</td><td>64</td></tr></tbody></table><h3 id="实现1">实现1</h3><blockquote><p>个人感觉这种好理解</p></blockquote><p><code>QuickSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> start;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> end;</span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> arr[l];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="comment">//先从右向左，找到第一个小于base的数，将其移动到l的位置上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt;= base) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[l] = arr[r];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//再从左向右，找到第一个大于base的数，将其移动到r的位置上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt;= base) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[r] = arr[l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出时，l == r</span></span><br><span class="line">            arr[l] = base;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再分别对左、右的数组进行快排</span></span><br><span class="line">            quickSort(arr, start, l - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, r + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现1’">实现1’</h3><p><code>QuickSort</code></p><blockquote><p>仅对上述quickSort部分作了一定修改如下，只是形式不同罢了</p><blockquote><p>展示核心部分代码：</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(arr,start,end);</span><br><span class="line">            <span class="comment">//再分别对左、右的数组进行快排</span></span><br><span class="line">            quickSort(arr, start, pos-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pos + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[r]&gt;=pivot)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[l]&lt;=pivot)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[r] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现2">实现2</h3><p><code>QuickSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(l + r) / <span class="number">2</span>];<span class="comment">//把中间元素定为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//临时的交换变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，arr[l]==pivot，则需将 r-- （试想一下arr[l]和arr[r]同时==pivot的情况，会无限循环）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l==r必须l++,r--</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2025/03/30/algorithm/other/%E9%80%92%E5%BD%92/"/>
      <url>/2025/03/30/algorithm/other/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1>递归入门</h1><h2 id="简单迷宫问题">简单迷宫问题</h2><blockquote><p>判断能否找到出路即可</p></blockquote><p><code>MiGong</code></p><blockquote><p>为穷尽所有路线！仅选择了一种迷宫探索的策略（使用ifelse-if结构-》下右上左策略）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//1为墙</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;8;i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j=0;j&lt;7;j++)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(map[i][j]+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (findWay(map, <span class="number">1</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes，可找到路：&quot;</span>);</span><br><span class="line">            <span class="comment">//输出路径</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                    System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若能走到map[6][5],说明通路找到</span></span><br><span class="line"><span class="comment">     * map[i][j]为0表示没做够，1表示为墙，2表示可以走，3表示已走过</span></span><br><span class="line"><span class="comment">     * 策略：下-&gt;右-&gt;上-&gt;左</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 传入的地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始走</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若能走通，true；反之为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (findWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//改点走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//map[i][j]!=0 可能为1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八皇后问题-经典">八皇后问题(经典)</h2><p>问题：在8×8的棋盘上放置8个皇后，任意两个皇后不能位于同一行、同一列、同一斜线，问有多少种摆法？</p><h3 id="思路分析">思路分析</h3><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放第二行第一列、判断是否ok，不ok再判断第二列、第三列…直到找到一个位置合适</li><li>后续几个皇后的放置同理，直至最后一个皇后也放置成功，找到了一个成功解</li><li>当得到了一个正确解后，在栈回退到上一个栈时，开始回溯…即，将第一个皇后放在第一行第一列的所有正确解全部得到</li><li>然后再将第一个皇后放在第一行第二列，循环执行1234，直至第一个皇后八列均放置过。</li></ol><p>说明：理论上应该创建一个二维数组来表示棋盘，但是可以通过算法用一个一维数组解决问题——<code>arr[8]=&#123;0,4,7,5,2,6,1,3&#125;</code>，下标对应的是第几个皇后。故，<code>arr[i]=val</code>，表示第i+1个皇后放在第i+1行、第val+1列上</p><h3 id="代码实现">代码实现</h3><p><code>Queue8</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">//八皇后问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue8</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue8</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue8</span>();</span><br><span class="line">        q.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;解法一共有：%d种&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;<span class="comment">//说明已经放置了八个皇后（0-7）</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于第n个皇后，每一列依次去放到每一列j：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            array[n] = j;</span><br><span class="line">            <span class="keyword">if</span> (!isAttack(n)) &#123;</span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查摆放第n个皇后时位置是否冲突的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAttack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">//            if(array[i]==array[n] || array[i]+n-i==array[n] || array[i]-i+n==array[n])&#123;</span></span><br><span class="line"><span class="comment">//                return true;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//分别为判断是否在同一列、同一斜线的条件</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将8个皇后位置信息输出的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>希尔排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>首先是关于插入排序存在的问题：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181431723.png" alt="image-20241031183208134" style="zoom:80%;" /><p>会发现当我们要插入的数据是较小的数时，后移的次数明显增多，对效率有影响</p><p><strong>希尔排序介绍</strong>：</p><p>也是一种插入排序，他是简单插入排序经过改进后的一个<strong>更高效版本</strong>，也成为<strong>缩小增量排序</strong></p><p><strong>基本思想</strong>：</p><p>希尔排序是把记录按下标的一定增量<strong>分组</strong>，对每组使用直接插入排序算法排序；随着<strong>增量</strong>减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法终止。</p><ol><li><strong>分组</strong>：希尔排序首先将整个待排序的数组按下标分成若干组。每组的元素之间的下标差为一个预先设定的<strong>增量</strong>（也称为“<strong>步长</strong>”）。例如，假设增量为 3，则数组中的元素会被分成多个子数组，<strong>每个子数组包含的元素是下标相差 3 的元素</strong>。</li><li><strong>直接插入排序</strong>：对每组中的元素使用直接插入排序算法进行排序。直接插入排序是将待排序元素逐个插入到已排序序列中的方法，<strong>适用于小规模数据的排序</strong>。</li><li><strong>减少增量</strong>：随着排序的进行，增量逐渐减少，通常会按照某种规则（如减半或减小固定值）来选择新的增量。每次减少增量后，分组的方式会发生变化，此时会有更多的元素被分到同一组中。</li><li><strong>最终排序</strong>：当增量减小到 1 时，所有元素就会被视为一组，此时使用插入排序对整个数组进行排序。<strong>由于之前的分组和局部排序，整体数据已经趋近于有序</strong>，因此最后的插入排序能够更高效地完成。</li></ol><ul><li><strong>总结</strong>：希尔排序通过<strong>先对远距离的元素进行排序</strong>，然后<strong>逐步缩小距离</strong>，使得数据<strong>逐渐接近有序</strong>，从而<strong>提高插入排序的效率</strong>。这种分组和逐步排序的方式使得希尔排序比直接插入排序<strong>在处理较大数组时效率更高</strong>。</li></ul><p><strong>图解</strong>：</p><ol><li><p><strong>初始数组</strong>：<br>假设我们有一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>选择增量</strong>：<br>假设我们选择初始增量为 4。数组被分为两组：</p><ul><li>第一组（下标 0, 4）：[8, 6]</li><li>第二组（下标 1, 5）：[5, 2]</li><li>第三组（下标 2, 6）：[3, 4]</li><li>第四组（下标 3, 7）：[7, 1]</li></ul></li><li><p><strong>对每组进行插入排序</strong>：<br>对每一组进行插入排序：</p><ul><li>第一组：[6, 8] → 变为 <code>[6, 8]</code></li><li>第二组：[2, 5] → 变为 <code>[2, 5]</code></li><li>第三组：[3, 4] → 变为 <code>[3, 4]</code></li><li>第四组：[1, 7] → 变为 <code>[1, 7]</code></li></ul><p>整体数组变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 2, 3, 1, 8, 5, 4, 7]</span><br></pre></td></tr></table></figure></li><li><p><strong>减小增量</strong>：<br>将增量减小到 2。新的分组：</p><ul><li>第一组（下标 0, 2, 4, 6）：[6, 3, 8, 4]</li><li>第二组（下标 1, 3, 5, 7）：[2, 1, 5, 7]</li></ul></li><li><p><strong>对新组进行插入排序</strong>：</p><ul><li>第一组：[3, 4, 6, 8] → 变为 <code>[3, 4, 6, 8]</code></li><li>第二组：[1, 2, 5, 7] → 变为 <code>[1, 2, 5, 7]</code></li></ul><p>整体数组变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 1, 4, 2, 6, 5, 8, 7]</span><br></pre></td></tr></table></figure></li><li><p><strong>再次减小增量</strong>：<br>将增量减小到 1。此时对整个数组进行插入排序：</p><ul><li>最终排序结果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure></li></ol><p>真-上述过程的图解：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181444173.png" alt="image-20241031191106899" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><h3 id="实现1：希尔排序-交换式">实现1：希尔排序[交换式]</h3><blockquote><p>该种方法每次比较完采用了交换的方式移动数据，效率非常低:(比原生的插入排序还慢！)</p><p>（所以这种方式不能算是对插入排序的优化，只是用于演示思路比较清晰）</p></blockquote><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>71</td></tr><tr><td>50000</td><td>1419</td></tr><tr><td>80000</td><td>4179</td></tr><tr><td>140000</td><td>13005</td></tr></tbody></table><p><code>ShellSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序每轮过程：&quot;</span>);</span><br><span class="line">        shellDetailedSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------下面展示shellSort--------------------&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr2));</span><br><span class="line">        shellSort(arr2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-gap;j&gt;=<span class="number">0</span>;j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                        arr[j] = arr[j+gap];</span><br><span class="line">                        arr[j+gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//详细演示了希尔排序每轮的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellDetailedSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//arr含8个数据：&#123;8, 5, 3, 7, 6, 2, 4, 1&#125;</span></span><br><span class="line">        <span class="comment">//第一轮：增量为4</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">4</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">4</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">4</span>];</span><br><span class="line">                    arr[j+<span class="number">4</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;6, 2, 3, 1, 8, 5, 4, 7&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二轮：增量为2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">2</span>];</span><br><span class="line">                    arr[j+<span class="number">2</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;3, 1, 4, 2, 6, 5, 8, 7&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三轮：增量为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        shellSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现2：希尔排序-移动式">实现2：希尔排序[移动式]</h3><blockquote><p>真-做到了对直接插入排序的究极优化！</p></blockquote><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>3</td></tr><tr><td>50000</td><td>6</td></tr><tr><td>80000</td><td>12</td></tr><tr><td>140000</td><td>17</td></tr></tbody></table><p><code>ShellSort</code>（对上述文件进行了覆盖并修改）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对于第i个元素，采取直接插入的方法</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[insertIndex]) &#123; <span class="comment">//说明还没找到要插入的位置</span></span><br><span class="line">                    arr[insertIndex+gap]=arr[insertIndex];</span><br><span class="line">                    insertIndex-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[insertIndex+gap]=insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        shellSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2025/03/30/algorithm/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>插入排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本思想</strong>为：</p><p>把n个待排序的元素看成为一个有序表和一个无序表，<strong>开始时有序表中只有一个元素</strong>，无序表中有n-1个元素，排序过程中<strong>每次从无序表中取出一个</strong>元素，将它与有序表中元素依次<strong>比较</strong>，<strong>插入到适当位置</strong>，使之成为新的有序表。</p><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>22</td></tr><tr><td>50000</td><td>431</td></tr><tr><td>80000</td><td>1074</td></tr><tr><td>140000</td><td>3214</td></tr></tbody></table><p><code>InsertSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];<span class="comment">//待插入有序表的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//该元素应该插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex]) &#123;</span><br><span class="line">                <span class="comment">//说明还没找到该插入的位置</span></span><br><span class="line">                arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[insertIndex+<span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        insertSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2025/03/30/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>选择排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本思想</strong>为：</p><p>第一次从$arr[0]至arr[n-1]$中选取最小值，与$arr[0]$交换；第二次从$arr[1]至arr[n-1]$中选取最小值，与$arr[1]$交换；第三次从$arr[2]至arr[n-1]$中选取最小值，与$arr[2]$交换……</p><p><strong>图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181508676.png" alt="image-20241031164111535" style="zoom:67%;" /><p><strong>说明</strong>：</p><ol><li>选择排序有<code>arr.length-1</code>轮排序</li><li>每一轮循环，都是找出当前待排序元素的最小值(的索引<code>minIndex</code>)，放置到最前面(<code>swap(arr[minIndex],arr[i])</code>)。</li><li>时间复杂度为$O(n^2)$</li></ol><h2 id="代码实现">代码实现</h2><p><strong>算法性能测试</strong>：</p><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>26</td></tr><tr><td>50000</td><td>592</td></tr><tr><td>80000</td><td>1470</td></tr><tr><td>140000</td><td>4337</td></tr></tbody></table><p><code>SelectSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">80000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        selectSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2025/03/30/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/algorithm/sort/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>冒泡排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>冒泡排序的<strong>基本思想</strong>是：</p><p>对待排序的元素依次从前往后遍历，比较相邻元素的值，若相邻元素逆序，则交换位置，最终会使得值较大的元素逐渐从前移动到后面，犹如水中气泡冒上来一样。</p><p><strong>优化</strong>：</p><p>因为在排序过程中，每个元素都会不断接近自己应在的位置，如果某一趟中没有进行交换，说明已排序完毕。（可新增<code>flag</code>来作为标志）</p><p><strong>图解</strong>：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181359884.png" alt="image-20241031124546183"></p><p>每一趟&quot;冒泡&quot;，就是将<strong>最大</strong>的那个元素放到<strong>待排序元素</strong>的最后，且每过一轮，待排序元素减一。</p><p>从上面例子明显可见，可以优化。</p><p><strong>小结</strong>：</p><ol><li>一共进行<code>arr.length()-1</code>次排序</li><li>每一趟排序的次数逐渐减少</li><li>如果发现某一次没有交换，就可以结束排序（优化）</li><li>时间复杂度为$O(n^2)$</li></ol><h2 id="代码实现">代码实现</h2><p><strong>算法性能测试</strong>：</p><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>43</td></tr><tr><td>50000</td><td>1845</td></tr><tr><td>80000</td><td>5250</td></tr><tr><td>140000</td><td>18690</td></tr></tbody></table><p><code>BubbleSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>; <span class="comment">// 如果一次排序都没有，说明已经有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">80000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        bubbleSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——并查集</title>
      <link href="/2025/03/30/algorithm/datastruct/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/03/30/algorithm/datastruct/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>并查集</h1><blockquote><p>由于目录编排原因，好像并查集是图？并不是，它是一种独立的抽象的数据结构。可以看做是一棵树或森林。</p><p>并查集的定义以及算法实现参考了<a href="https://oi-wiki.org/ds/dsu/">OI WIKI并查集</a>以及<a href="https://blog.csdn.net/the_zed/article/details/105126583">blog</a>提供了形象生动的例子。</p><p>同时参考了GPT所提供应用、代码。</p></blockquote><p><strong>基本介绍</strong>：</p><p><strong>并查集(DSU)</strong>，全称为<strong>Disjoint Set Union</strong>。</p><ol><li><p>并查集是一种用于<strong>管理元素所属集合</strong>的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p></li><li><p>顾名思义，并查集支持两种操作：</p><ul><li><p><strong>合并（Union）</strong>：合并两个元素所属集合（合并对应的树）</p></li><li><p><strong>查询（Find）</strong>：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</p></li></ul><blockquote><p>删除、移动属于扩展的操作，需要将parent数组增加值两倍，还新增一个size[]来记录每个集合中元素个数，其大小也是两倍。</p></blockquote><ul><li>通常情况下并查集的标准实现只需要<code>find</code>和<code>unite</code>就行，如需扩展功能才将数组空间变为两倍，因此也给出两种代码。</li></ul></li></ol><p><strong>并查集的应用</strong>：</p><ol><li><strong>连通性问题</strong><ul><li>并查集最经典的应用之一是判断图中节点是否连通。假设你有一个无向图，需要动态地判断两个节点是否属于同一个连通块，或者在图中添加边并进行连通性判断。并查集通过“合并”和“查找”操作，能够在近乎常数时间内解决这一问题。</li><li>判断两个城市是否在同一条道路网络中。</li><li>判断两个计算机是否在同一个局域网中。</li></ul></li><li><strong>最小生成树</strong><ul><li>并查集是 <a href="##%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95">Kruskal 算法</a>的核心部分。Kruskal 算法通过对边进行排序并逐步合并节点，最终得到图的最小生成树。在这个过程中，使用并查集判断两个节点是否属于同一集合，防止产生环。</li><li>计算带权图的最小生成树，最小成本的通信网络布设。</li></ul></li><li><strong>动态连通性</strong><ul><li>在一些实时问题中，可能会动态地增加边或删除边。并查集可以高效地处理这种动态连通性的问题，例如：在某些社交网络中判断两个人是否处于同一网络中，或者当一条连接断开时判断网络是否仍然连通。</li><li>判断社交网络中两个用户是否在同一个群组。</li><li>判断计算机网络中两个节点是否能通信。</li></ul></li><li><strong>图的环形检测</strong><ul><li>在图的遍历过程中，环的检测是一个常见问题。利用并查集可以高效地检测图中是否有环。当你尝试合并两个已经在同一集合中的节点时，说明已经发现了一个环。</li><li>判断一个无向图中是否存在环。</li><li>判断一个任务依赖图中是否存在循环依赖。</li></ul></li><li><strong>分割问题</strong><ul><li>在图中，分割或切割的目标是将图分割成多个连通块。并查集可以帮助快速地找到哪些节点属于同一块，从而实现图的分割。</li><li>网络中的分区，找到某些节点之间的最大割集。</li><li>计算机科学中的图像分割问题。</li></ul></li><li><strong>动态连通性与并查集扩展</strong><ul><li>一些复杂的动态连通性问题，可以使用并查集的扩展版本进行处理。例如，在动态树形结构的查询和更新中，可以通过并查集进行高效操作。</li><li>在数据流中，快速查询和更新不同数据块之间的连接关系。</li></ul></li><li><strong>岛屿问题</strong><ul><li>给定一个二维矩阵，其中每个元素表示一个格子，格子值为 <code>1</code> 表示陆地，<code>0</code> 表示水域。通过并查集，可以快速求解岛屿的个数，即求连通的陆地块的个数。</li><li>在一个地图中，找到所有孤立的岛屿区域。</li></ul></li><li><strong>动态查询最小生成树</strong><ul><li>并查集也可以用于处理某些动态修改图的问题，如在某些图的边权改变时，需要动态查询和更新最小生成树。通过与其他算法结合，保持并查集的结构可以高效更新图中的连通信息。</li></ul></li></ol><p><strong>算法实现思路</strong>：</p><ol><li><p><strong>初始化</strong></p></li><li><p><strong>查询</strong><code>find</code></p><ol><li><p>我们需要沿着树向上移动，直至找到根节点。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181537510.png" alt="image-20241113105235769" style="zoom:80%;" /></li><li><p>路径压缩，可以加快后续的查找速度。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181548998.png" alt="image-20241113105250975" style="zoom:80%;" /></li></ol></li><li><p><strong>合并</strong></p><p>要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181602623.png" alt="image-20241113105355926" style="zoom:80%;" /><p>补充：<strong>启发式合并</strong></p><p>合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p></li><li><p><strong>删除</strong><code>erase</code></p><p>要删除一个叶子节点，我们可以将其父亲设为自己。为了保证要删除的元素都是叶子，我们可以预先为每个节点制作副本，并将其副本作为父亲。</p><p>实际上，这里的删除操作，只是将该元素的parent指向他自己。</p><ul><li><p>该操作的效果是 <strong>“断开”</strong> 元素 <code>x</code> 与它原来集合的联系，使 <code>x</code> 成为一个新的单元素集合，但并没有真正删除 <code>x</code> 本身，也没有改变其它集合的结构。</p></li><li><p>这意味着，<code>x</code> 会从原集合中“移除”，但其索引仍然存在于数据结构中。换句话说，<code>erase</code> 操作并没有修改 <code>parent</code> 数组的大小，也没有真正从数据结构中“删除”元素，只是把 <code>x</code> 从原来的集合中分离出来。</p></li><li><p><strong>为什么？</strong></p><ul><li><p>这样的设计通常用于 <strong>懒惰删除</strong>（lazy deletion）或者当需要在集合中分割元素时。这种方式避免了删除元素时可能出现的性能开销，特别是在处理大数据结构时。</p></li><li><p>另外，<code>erase</code> 操作本身可能用于某些特定场景，比如让元素独立出来，变成一个单独的集合，供后续操作使用。</p></li></ul></li><li><p><strong>进一步改进</strong>：</p><ul><li>如果需要完全删除某个元素并从集合中移除，可以考虑设计一个额外的机制来真正删除元素，可能会涉及到管理集合中实际元素的列表或数组。</li></ul></li></ul></li><li><p><strong>移动</strong></p><p>与删除类似，通过以副本作为父亲，保证要移动的元素都是叶子。</p></li></ol><p><strong>带权并查集</strong>：</p><p>我们还可以在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算，从而解决更多的问题。</p><p>比如对于经典的<a href="https://www.luogu.com.cn/problem/P2024">「NOI2001」食物链</a>，我们可以在边权上维护模 3 意义下的加法群。</p><h2 id="标准并查集实现">标准并查集实现</h2><p><code>DSUDemo</code></p><blockquote><p>感谢GPT</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.dsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DSUDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含 5 个元素的并查集</span></span><br><span class="line">        <span class="type">DSU</span> <span class="variable">dsu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DSU</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印初始状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Initial state:&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并集合</span></span><br><span class="line">        dsu.unite(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 将 0 和 1 合并</span></span><br><span class="line">        dsu.unite(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 将 1 和 2 合并</span></span><br><span class="line">        dsu.unite(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 将 3 和 4 合并</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印合并后的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After uniting (0,1), (1,2), (3,4):&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 0: &quot;</span> + dsu.find(<span class="number">0</span>));  <span class="comment">// 输出 0 或 2，因为 0 和 2 在同一个集合中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 4: &quot;</span> + dsu.find(<span class="number">4</span>));  <span class="comment">// 输出 4 或 3，因为 3 和 4 在同一个集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次合并 2 和 3</span></span><br><span class="line">        dsu.unite(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 将 2 和 3 合并</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印合并后的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After uniting (2,3):&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 0: &quot;</span> + dsu.find(<span class="number">0</span>));  <span class="comment">// 输出 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 4: &quot;</span> + dsu.find(<span class="number">4</span>));  <span class="comment">// 输出 2，因为 4 通过 3 和 2 连接到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;  <span class="comment">// 用于存储每个元素的父节点</span></span><br><span class="line">    <span class="type">int</span>[] size;    <span class="comment">// 用于存储每个集合的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：初始化并查集，设置每个元素的父节点为自己，集合大小为 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DSU</span><span class="params">(<span class="type">int</span> size_)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size_];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[size_];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化，父节点指向自己，集合大小为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">            parent[i] = i;    <span class="comment">// 每个元素的父节点初始化为它自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>;      <span class="comment">// 每个集合的初始大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作：返回元素 x 所在集合的根节点，同时使用路径压缩优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 的父节点是它自己，说明它是根节点，直接返回</span></span><br><span class="line">        <span class="comment">// 否则递归查找其父节点并进行路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作：将元素 x 和 y 所在的集合合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找元素 x 和 y 的根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 x 和 y 已经在同一个集合中，则不需要合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 根据集合大小来决定将哪个集合合并到另一个集合</span></span><br><span class="line">            <span class="keyword">if</span> (size[rootX] &lt; size[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;  <span class="comment">// 将 x 所在的集合合并到 y 所在的集合</span></span><br><span class="line">                size[rootY] += size[rootX];  <span class="comment">// 更新 y 所在集合的大小</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;  <span class="comment">// 将 y 所在的集合合并到 x 所在的集合</span></span><br><span class="line">                size[rootX] += size[rootY];  <span class="comment">// 更新 x 所在集合的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前并查集的父节点数组和集合大小数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent: &quot;</span> + Arrays.toString(parent));  <span class="comment">// 打印每个元素的父节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Size: &quot;</span> + Arrays.toString(size));      <span class="comment">// 打印每个集合的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展并查集实现">扩展并查集实现</h2><p><code>ExtendedDSUDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.extendedDsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedDSUDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DSU</span> <span class="variable">dsu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DSU</span>(<span class="number">5</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line">        dsu.unite(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dsu.unite(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//        dsu.find(2);</span></span><br><span class="line">        dsu.print();<span class="comment">//此时输出parent[5,5,7,8,9,5,5,5,8,9]为什么呢？</span></span><br><span class="line">                    <span class="comment">//发现第2个元素和7号元素的父节点都应该是5才对？</span></span><br><span class="line">                    <span class="comment">//因为此时刚完成合并，没有进行过find，所以路径没压缩，只要加上那句注释掉的find，此时的parent[2]也会变成5</span></span><br><span class="line">        dsu.move(<span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 将元素 0 移动到元素 3 所在的集合</span></span><br><span class="line">        dsu.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DSU</span><span class="params">(<span class="type">int</span> size_)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size_ * <span class="number">2</span>];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[size_ * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化前半部分，元素属于不同的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">            parent[i] = i + size_;  <span class="comment">// 初始化 parent 数组，前 size_ 个元素依次为 size_ 到 2*size_-1</span></span><br><span class="line">            size[i] = <span class="number">1</span>;            <span class="comment">// 每个集合的初始大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化后半部分，元素是自己的父节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size_; i &lt; size_ * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;          <span class="comment">// 后半部分，pa[i] = i，表示每个元素自己是根</span></span><br><span class="line">            size[i] = <span class="number">1</span>;            <span class="comment">// 初始集合大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并进行路径压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两棵树，按大小合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个元素已经在同一个集合中，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 按大小合并：将小树合并到大树下</span></span><br><span class="line">            <span class="keyword">if</span> (size[rootX] &lt; size[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                size[rootY] += size[rootX];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                size[rootX] += size[rootY];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素 x 移动到元素 y 所在的集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);  <span class="comment">// 查找元素 x 所在的集合的根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);  <span class="comment">// 查找元素 y 所在的集合的根</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 x 和 y 已经在同一个集合中，不需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 x 移动到 y 所在的集合</span></span><br><span class="line">        parent[x] = fy;  <span class="comment">// 让 x 的父节点指向 y 所在的集合</span></span><br><span class="line">        size[fx]--;      <span class="comment">// 原集合的大小减 1</span></span><br><span class="line">        size[fy]++;      <span class="comment">// 目标集合的大小加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 parent 和 size 数组的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent: &quot;</span> + Arrays.toString(parent));</span><br><span class="line">        System.out.println(<span class="string">&quot;Size: &quot;</span> + Arrays.toString(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——图</title>
      <link href="/2025/03/30/algorithm/datastruct/%E5%9B%BE/"/>
      <url>/2025/03/30/algorithm/datastruct/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>图</h1><p>为什幺要有图？</p><ol><li>线性表局限于一个直接前驱和一个直接后继。</li><li>树也只能有一个直接前驱。</li><li>当我们需要<strong>多对多</strong>的关系时，就需要使用<strong>图</strong>。</li></ol><p><strong>图的常用概念</strong></p><ol><li><p><strong>顶点</strong>（<strong>vertex</strong>）</p></li><li><p><strong>边</strong>（<strong>edge</strong>）</p></li><li><p><strong>路径</strong></p></li><li><p><strong>无向图</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183034390.png" alt="image-20241110210336286" style="zoom:80%;" /></li><li><p><strong>有向图</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183045875.png" alt="image-20241110210634499" style="zoom:80%;" /></li><li><p><strong>带权图</strong>（这种边带权值的图也叫<strong>网</strong>）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183055477.png" alt="image-20241110210837126" style="zoom:80%;" /></li></ol><p>图的表示方式：二维数组表示（<strong>邻接矩阵</strong>）；链表表示（<strong>邻接表</strong>）</p><ol><li><p><strong>邻接矩阵</strong></p><ul><li>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1…n个点。</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183106288.png" alt="image-20241113213029646" style="zoom:80%;" /></li><li><p><strong>邻接表</strong></p><ul><li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失。</li><li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501183117013.png" alt="image-20241114115322312" style="zoom:80%;" /></li></ol><p><strong>创建一个无向图-简单案例</strong></p><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(String vertex: Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——树</title>
      <link href="/2025/03/30/algorithm/datastruct/%E6%A0%91/"/>
      <url>/2025/03/30/algorithm/datastruct/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>树</h1><p><strong>为什么需要树这种存储结构?</strong></p><ol><li>数组：<ul><li>优点：通过下标方式查找元素，查找速度快，况且还可以通过排序+查找算法进一步提高查找速度，<strong>随机存取</strong>是其最大优势。</li><li>缺点：插入删除元素复杂，涉及到整体移动的问题，耗费大量时间。</li></ul></li><li>链式存储：<ul><li>优点：插入删除方便。</li><li>缺点：查找效率不高，需要从头开始遍历查找。</li></ul><blockquote><p>提一嘴哈希表（数组+链表版），一定程度上集数组和链表之长，既提高查找效率，又简化了插入删除操作。</p></blockquote></li><li>树：能提高数据的<strong>存储、读取</strong>效率，比如<strong>二叉排序树</strong>，即保证了查询效率，插入删除操作也方便。</li></ol><p><strong>树的常用术语</strong>(不必纠结)：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181746016.png" alt="image-20241103104817501" style="zoom:80%;" /><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>节点</td><td>A、B、C……都是节点</td></tr><tr><td>根节点root</td><td>A</td></tr><tr><td>父节点</td><td>C是F和G的父节点</td></tr><tr><td>子节点</td><td>C是A的子节点</td></tr><tr><td>叶子节点</td><td>没有子节点的节点</td></tr><tr><td>节点的权</td><td>节点值</td></tr><tr><td>路径</td><td>从root找到当前节点的路线</td></tr><tr><td>层</td><td>如图</td></tr><tr><td>子树</td><td>D、H为B的子树</td></tr><tr><td>树的高度</td><td>4</td></tr><tr><td>森林</td><td>多棵树构成</td></tr></tbody></table><p>注意事项：</p><p>树分为有序树和无序树，有序树分左右，无序树不分左右。</p><h1>二叉树</h1><h2 id="基本概念">基本概念</h2><ol><li>每个节点都<strong>至多</strong>有两个子节点。</li><li>二叉树的子节点分为<strong>左节点</strong>和<strong>右节点</strong>。</li><li><strong>满二叉树</strong>：如果<strong>所有叶子节点都在最后一层</strong>，且节点总数为$2^n-1$个，其中n为层数，则称<strong>满二叉树</strong>。</li><li><strong>完全二叉树</strong>：若二叉树的<strong>所有叶子节点都在最后一层或倒数第二层</strong>，且最后一层的叶子节点<strong>左连续</strong>，倒数第二层的叶子节点<strong>右连续</strong>，则称<strong>完全二叉树</strong>。</li></ol><h2 id="性质">性质</h2><blockquote><p>参考《数据结构（C语言版）》–清华大学出版社</p><p>有助于加深对<a href="###%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a>中“<strong>为什么有这样的特点</strong>”的理解，使之成为严谨的数学推导。（当然不看也行，直接找规律也能推出来）</p></blockquote><ol><li>在二叉树的第$i$层至多有$2^{i-1}$个节点（$i\geq1$）</li><li>深度为$k$的二叉树至多有$2^k-1$个节点（$k\geq1$）</li><li>对任意一棵二叉树，如果其终端节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$</li></ol><blockquote><p>关于第三点的推导：</p><p>已知$n=n_0+n_1+n_2$，其中$n$为<strong>节点总数</strong>（这个式子是基于节点数列出来的）</p><p>又因为$n=n_1+2n_2+1$，这个式子的原因为<strong>节点数等于分支数+1</strong>，只有$n_1$有1个分支，$n_2$有2个分支，$n_0$没有分支。</p><p>两式消去$n_1$即可</p></blockquote><ol start="4"><li>具有n个节点的完全二叉树的深度 $\lfloor \log_2 n \rfloor + 1$。</li></ol><blockquote><p>Proof：</p><p>设深度为k，则根据完全二叉树定义以及性质2可知：</p><p>$2^{k-1}-1&lt;n\leq 2^k-1$或$2^{k-1}\leq n &lt; 2^k$，选则其一可解得……</p></blockquote><ol start="5"><li>对于一个有n个节点的完全二叉树，对于任一节点$i$（$1 \leq i \leq n$），有：<ul><li>若$i=1$，则为root节点；若$i&gt;1$，则其<strong>父节点</strong>为$\lfloor i/2 \rfloor$</li><li>若$2i&gt;n$，则节点$i$无左子节点，否则其<strong>左子节点</strong>为$2i$</li><li>若$2i+1&gt;n$，则节点$i$无右节点，否则其<strong>右子节点</strong>为$2i+1$</li></ul></li></ol><h2 id="链式存储二叉树">链式存储二叉树</h2><p>需要创建一个结点类，应包括数据本身的数据、左节点<code>left</code>、右节点<code>right</code>、[父节点<code>root</code>可选]</p><p>连式存储很常见，所以不做代码演示，因为后续的很多都用到了链式存储……</p><p>而且遍历、查找方法在节点类中均有写，但是最终我们是通过调用<code>BinaryTree</code>这个类里面的方法，所以节点类里面写的方法一般情况是给二叉树用的（如遍历、查找[后续代码可见其用意]）</p><h2 id="前序-中序-后续遍历">前序/中序/后续遍历</h2><h3 id="思路分析">思路分析</h3><blockquote><p>区分前/中/后序，看父节点什么时候输出。</p></blockquote><p><strong>概念</strong>：</p><ol><li>前序遍历：先输出<strong>父节点</strong>，再遍历左子树和右子树。</li><li>中序遍历：先遍历左子树，再输出<strong>父节点</strong>，再遍历右子树。</li><li>后续遍历：先遍历左子树，再遍历右子树，最后输出<strong>父节点</strong>。</li></ol><p><strong>流程</strong>：</p><ol><li>创建二叉树</li><li>遍历<ul><li><p>前序遍历</p><ul><li>先<strong>输出当前节点</strong>(初始时为root节点)</li><li>如果左子节点不为空，则向左递归执行前序遍历</li><li>如果右子节点不为空，则向右递归执行前序遍历</li></ul></li><li><p>中序遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行中序遍历</li><li><strong>输出当前节点</strong></li><li>如果当前节点的右子节点不为空，则向右递归执行中序遍历</li></ul></li><li><p>后续遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行后序遍历</li><li>如果当前节点的右子节点不为空，则向右递归执行后序遍历</li><li><strong>输出当前节点</strong></li></ul></li></ul></li></ol><p><strong>小技巧</strong>：</p><blockquote><p>无论何种技巧，画图永远不会错</p></blockquote><p>前序遍历就是走到哪输出到哪（<strong>从根先往左下，再回溯尝试往右</strong>）；中序遍历，某个节点没有左节点了（<strong>优先输出左叶子，没有左叶子后就从根往下，输出一次掉一片叶子</strong>），就输出；后序遍历，某个节点同时没有左右了，输出（<strong>优先左叶子，再右叶子，每次输出一次就相当于掉一片叶子</strong>）。</p><h3 id="代码实现">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrder</code>、<code>infixOrder</code>、<code>postOrder</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>,<span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>,<span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>,<span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;后续遍历：&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前序-中序-后续查找">前序/中序/后续查找</h2><h3 id="思路分析-2">思路分析</h3><p><strong>流程</strong>：</p><ol><li>存在一颗二叉树</li><li>查找<ul><li><strong>前序查找</strong><ul><li>先判断<strong>当前节点</strong>的id是否等于要查找的</li><li>如果相等，则返回当前节点</li><li>如果不等，则判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果左递归找到节点，则返回；否则，判断判断当前节点的<strong>右子节点</strong>是否为空，若不为空，则继续向右递归。</li></ul></li><li><strong>中序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，则判断<strong>当前节点</strong>是否是要找的绩点，如果是，则返回。</li><li>不是，判断<strong>右子节点</strong>是否为空，不为空，则向右递归，找到则返回，否则返回null。</li></ul></li><li><strong>后序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，判断<strong>右子节点</strong>是否为空，不为空，则向左递归，找到则返回。</li><li>若没找到，判断<strong>当前节点</strong>是否是想要找的节点，如果是返回，不是则返回null。</li></ul></li></ul></li></ol><blockquote><p>tips1：无论怎样，凡是遇到需要访问左、右节点的操作，均需要先判断是否为空。</p><p>tips2：前序–&gt;当前，左，右；中序–&gt;左，当前，右；后序–&gt;左，右，当前。</p></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrderSearch</code>、<code>infixOrderSearch</code>、<code>postOrderSearch</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.preOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.infixOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.postOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除节点">删除节点</h2><h3 id="思路分析-3">思路分析</h3><p><strong>删除操作</strong>：</p><ol><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除子树</li></ol><blockquote><p>如果不想把整棵子树删除，</p><p>可以考虑将第二点改为：(放于实现2)</p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……(我这边暂时用一种简单实现：还是让B替代A，但是在B向左while循环，找到最左边的那个位置，然后把C插入(这样子代码实现简单，但是树的层数会变高……))</li></ul><blockquote><p>后续的二叉排序树更有另一套规则</p></blockquote></blockquote><p><strong>思路</strong>：</p><ol start="0"><li><p>若树只有一个root节点，则判断root是否要要删的，若是，置null。然后进行下面操作：(第0步写在<code>BinaryTree</code>的删除方法里[最先判断]，后续5步写在<code>HumanNode</code>的删除方法里)</p></li><li><p>因为二叉排序树是单向的，所以我们判断的是当前节点的子节点是否需要删除，而不是判断当前节点是否需要被删除（除非节点设计上带有父节点、或者查找时带有父节点信息）。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.left != null)</code>，且为要删除的节点，则删除<code>this.left = null</code>(简单粗暴法)，结束递归。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.right != null)</code>，且为要删除的节点，则删除<code>this.right = null</code>(简单粗暴法)，结束递归。</p></li><li><p>若第2、3步都没删除成功，则向左递归（当然要判断是否为空）。</p></li><li><p>若第4步没删除成功，则向右递归（当然要判断是否为空）。</p></li></ol><h3 id="代码实现-3">代码实现</h3><h4 id="实现1-直接把子树删掉">实现1(直接把子树删掉)</h4><p><code>BinaryTreeDemo</code></p><p>核心为：<code>delNodeById</code>inclass <code>BinaryTree</code>和<code>HumanNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现2-仅删节点-清晰">实现2(仅删节点)+清晰</h4><p><code>BinaryTree.delNodeById</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HumanNode.delNodeById</code></p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……<ul><li>我这边暂时用一种简单实现：还是让B替代A，但是<strong>不断在B向左while循环</strong>，找到<strong>最左边的那个位置</strong>，然后把C插入</li><li>这样子代码实现简单，但是树的层数会变高……</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.left))&#123;<span class="comment">//如果是叶子节点</span></span><br><span class="line">                <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是叶子</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.left.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.left.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.left.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.left;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.right))&#123;</span><br><span class="line">                <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.right.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.right.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.right.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.right;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.right.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码1：结果为1 4 6 8 7 3 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode4.setLeft(humanNode6);</span><br><span class="line">        humanNode4.setRight(humanNode7);</span><br><span class="line">        humanNode2.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码2：结果为1 2 4 6 7 8 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode3.setLeft(humanNode6);</span><br><span class="line">        humanNode6.setLeft(humanNode7);</span><br><span class="line">        humanNode6.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="顺序存储二叉树">顺序存储二叉树</h2><h3 id="思路分析-4">思路分析</h3><p><strong>说明</strong>：</p><p>从数据存储来看，数组存储方式和树存储方式可以相互转换（如下：）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181758051.png" alt="image-20241103185227543" /><p><strong>要求</strong>：</p><ol><li>二叉树中的数据用数组的形式存放，如上</li><li>在遍历数组时，仍能实现树的<strong>前序/中序/后序遍历</strong>。</li></ol><p><strong>特点</strong>：</p><ol><li>顺序存储二叉树，通常只考虑<strong>完全二叉树</strong>。</li><li>第n个元素的左子节点为$2*n+1$</li><li>第n个元素的右子节点为$2*n+2$</li><li>第n个元素的父节点为$(n-1)/2$<blockquote><p>n表示二叉树中第几个元素（从0开始），且编号顺序为——<strong>低层优先、左节点优先</strong></p></blockquote></li></ol><blockquote><p>ps：八大排序算法之<strong>堆排序</strong>，就会使用顺序存储二叉树。</p></blockquote><h3 id="代码实现-4">代码实现</h3><p><code>ArrayBinaryTreeDemo</code></p><blockquote><p>实现了数组的前序/中序/后序查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">ArrayBinaryTree</span> <span class="variable">arrayBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBinaryTree</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.preOrder();<span class="comment">//1 2 4 5 3 6 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.infixOrder();<span class="comment">//4 2 5 1 6 3 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.postOrder();<span class="comment">//4 5 2 6 7 3 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现顺序存储二叉树的遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，使得不写参数就是代表从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">线索化二叉树</h2><h3 id="思路分析-5">思路分析</h3><p><strong>问题</strong>：</p><p>将${ 1,3,6,8,10,14 }$构建成一颗二叉树，如下图</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181813911.png" alt="image-20241103201821509" style="zoom:80%;" /><ol><li>当对上述中序遍历时：8，3，10，1，14，6</li><li>但是对于8，10，14，6这几个节点的左右指针没有充分利用</li><li>如果有个新需求——充分利用各个节点的指针，<strong>让每个节点可以指向自己的前后节点</strong></li><li>解决方案：<strong>线索化二叉树</strong></li></ol><p><strong>介绍</strong>：</p><ol><li>$n$个节点的二叉链表中含有$n+1$个空指针域（推导：$2n-(n-1)=n+1$）。利用二叉链表中的空指针域，存放指向该节点在<strong>某种遍历次序</strong>下的<strong>前驱节点</strong>和<strong>后驱节点</strong>，这种附加的指针称为“线索”。</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为<strong>线索二叉树</strong>。分为<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>、<strong>后序线索二叉树</strong>。</li><li>一个节点的前一个节点，称<strong>前驱节点</strong>。</li><li>一个节点的后一个节点，称<strong>后继节点</strong>。</li></ol><p><strong>图解——将上述二叉树按中序遍历线索化</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181827267.png" alt="image-20241104094103323" /><p>8号左指针指向较为特殊，通过代码运行逻辑可以得出。（特地标出来，是为了说明8的<code>leftType = =1</code>，为后续遍历中序线索化二叉树做铺垫）</p><p>但是有些问题：线索化后的二叉树，其<code>left</code>既可能指向左子树（如1），也可能指向其前驱节点（如10）；其<code>right</code>既可能指向后继节点（如8），也可能指向其右子树（如1、3）。</p><ul><li>[x] 进一步简化、讲清楚找<strong>红色线索</strong>的方法！！！参考<a href="https://blog.csdn.net/m0_56494923/article/details/130457392">blog</a>画出线索的方法，很简单，易于记忆！</li></ul><p><em><strong>画出线索的方法（重要！这是分析の方法）</strong></em>:</p><ol><li>中序线索找法<ul><li>根据特定的遍历方式，写出最终的输出。例如上述想实现中序线索化，则先用中序遍历的思路看看——<strong>8，3，10，1，14，6</strong></li><li>根据这个输出顺序，给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li><strong>由于是中序，8号左边null</strong>。其余的：<strong>8右为3</strong>；<strong>10左为3</strong>，<strong>10右为1</strong>；1左右？不需要；<strong>14左1</strong>，<strong>14右6</strong>；6不需要左，最终6右不需要。</li></ul></li><li>前序线索找法<ul><li>先用前序遍历得到输出：<strong>1，3，8，10，6，14</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li>1不需要；3不需要；<strong>8左3</strong>，<strong>8右10</strong>；<strong>10左8</strong>，<strong>10右6</strong>；<strong>6右14</strong>；<strong>14左6</strong>，<strong>14右仍为null</strong>(经测：14的<code>rightType==0</code>)；</li></ul></li><li>后序线索找法<ul><li>先用后序遍历得到输出：<strong>8，10，3，14，6，1</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点、后继节点</strong></li><li><strong>8左为null</strong>，<strong>8右为10</strong>；<strong>10左为8</strong>，<strong>10右为3</strong>；3不需要；<strong>14左为3</strong>，<strong>14右为1</strong>；<strong>6右为1</strong>；1不需要。</li></ul></li></ol><p><strong>线索化代码流程</strong>：（步骤执行顺序的不同）</p><ol><li><p>前序线索化：</p><ul><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>如果左节点的<code>leftType == 0</code> ，再线索化左子树（左递归）</li><li>如果右节点的<code>rightType == 0</code>，再线索化右子树（右递归）</li><li><blockquote><p>进入前序线索化，在进入左、右递归前！一定要判断<code>某某Type == 0</code>！不然会进入死递归！坐等<code>StackOverflowError</code>吧！</p></blockquote></li></ul></li><li><p>中序线索化：</p><ul><li>线索化左子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>线索化右子树</li></ul></li><li><p>后序线索化：</p><ul><li>线索化左子树</li><li>线索化右子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li></ul></li></ol><blockquote><p>神奇吧，只有前序线索化在进入递归前需要判断……</p></blockquote><ul><li>[x] 必须要给<code>threadedNode(HumanNode node)</code>方法画一个图解！（这玩意的设置前驱节点和设置后继节点的代码部分并不是很直观、。而且，画图这一过程可以加深我的印象以及理解。）</li></ul><p><strong>图解–设置前驱结点、后继节点</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181840162.png" alt="image-20241104090654992" /><h3 id="代码实现-5">代码实现</h3><h4 id="中序线索化">中序线索化</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>要点在于：在<code>HumanNode</code>中新增了<code>leftType</code>和<code>rightType</code>两个字段及对应getter、setter方法。</p><p>在<code>ThreadedBinaryTree</code>中使用了<code>threadedNode</code>方法用于(<strong>中序</strong>)线索化二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>,<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>,<span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>,<span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>,<span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d&quot;</span>,node5.getLeft().getId(),node5.getRight().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;8号节点的右指针类型：&quot;</span>+node4.getRightType());</span><br><span class="line"><span class="comment">//        System.out.println(node4.getLeft().getId());//注意，8号节点的left为null，因为此时prev == null。（调试发现）</span></span><br><span class="line">        <span class="comment">//虽然8号节点的leftType已经被设置为1，但是left指向为null。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="前序线索化">前序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索化">后序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序线索化二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">    threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">    threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">    <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.setLeft(prev);</span><br><span class="line">        node.setLeftType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.setRight(node);</span><br><span class="line">        prev.setRightType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;理应新增的线索测试：&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;8号右边为：%d号节点\n&quot;</span>, node4.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号左边为：%d号节点\n&quot;</span>, node5.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号右边为：%d号节点\n&quot;</span>, node5.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号左边为：%d号节点\n&quot;</span>, node6.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号右边为：%d号节点\n&quot;</span>, node6.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;6号右边为：%d号节点\n&quot;</span>, node3.getRight().getId());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树">遍历线索化二叉树</h2><h3 id="思路分析-6">思路分析</h3><p>要求：对已经(中序)线索化的二叉树采取相同策略(中序)的遍历方式。</p><p>问题：因为线索化后，各个节点的指向以发生变化，因此原先的遍历方式不能再使用，需要用新的遍历方式遍历线索化二叉树。</p><p>优点：由于各个节点可以通过线型方式遍历，所以无需使用递归，提高了遍历的效率。</p><h3 id="代码实现-6">代码实现</h3><h4 id="遍历中序线索化二叉树">遍历中序线索化二叉树</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>新增<code>threadedList</code><strong>遍历中序线索化二叉树</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">        <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">        <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.getRight();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历中序线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.threadedList();<span class="comment">// 8 3 10 1 14 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">            <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历前序线索化二叉树">遍历前序线索化二叉树</h4><p><code>threadedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">            System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line"><span class="comment">//        System.out.printf(&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d \n&quot;, node5.getLeft().getId(), node5.getRight().getId());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;14号节点的左指针类型：&quot; + node6.getLeftType());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历前序线索化二叉树是否成功：</span></span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">                System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历后序线索化二叉树">遍历后序线索化二叉树</h4><p><code>threadedList</code></p><p>这个代码很复杂，已经需要使用<strong>三叉链表</strong>了。</p><blockquote><p>引用自<a href="https://blog.csdn.net/m0_56494923/article/details/130457392">博客</a>，暂时不深入思考、以及实现。</p><ul><li>[ ] 有空再说。</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181854902.png" alt="image-20241104193040292" style="zoom:80%;" /></blockquote><h1>赫夫曼树</h1><blockquote><p>Huffman，赫夫曼，哈夫曼，霍夫曼。</p></blockquote><h2 id="基本概念介绍">基本概念介绍</h2><ol><li><strong>路径和路径长度</strong>：从一个节点往下可以到达的孩子或孙子节点的通路，成为<strong>路径</strong>；通路中分支的数目称为<strong>路径长度</strong>。若根节点为第L层，则第L层的节点的路径长度为$L-1$</li><li><strong>结点的权、带权路径长度</strong>：节点中含有一个有某种含义的数值，称为<strong>节点的权</strong>；路径长度*节点的权 = <strong>带权路径长度</strong></li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181905706.png" alt="image-20241105200517736" style="zoom:80%;" /><ol start="3"><li><strong>树的带权路径长度</strong>：<strong>所有叶子节点的带权路径长度之和</strong>，称为<strong>树的带权路径长度</strong>，记为<strong>WPL（weighted path length）</strong>，赫夫曼树的特点就是<em><strong>带权路径长度最短</strong></em>，也就是要让权值越大的节点离根节点越近。</li><li><em><strong>WPL最小的就是赫夫曼树</strong></em>，<strong>图解</strong>(e.g.中间的是赫夫曼树)：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181916896.png" alt="image-20241105201026809" style="zoom:80%;" /><h2 id="创建赫夫曼树">创建赫夫曼树</h2><h3 id="思路分析-7">思路分析</h3><p>构成赫夫曼树的<strong>步骤</strong>：</p><ol><li>将数据从小到大排序(首次，将每个数据都看作根节点) / 或根据每棵树的根节点进行排序(非首次–or通用讲法)。</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小再次排序（也就是回到第一步）。不断重复 ，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><p><strong>简单理解</strong>：一，排序；二，取出最小两颗，组成新树，根节点为；三，回到第一步。（也就是图解中，三张图片为一轮）</p><p><strong>图解</strong>：</p><p>以${ 15,8,6,1,20,10 }$为例</p><ul><li>执行第一步排序，得到${ 1,6,8,10,15,20 }$，相当于有6棵树，每棵树都是一个单独的节点：</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181928786.png" alt="image-20241105204913658" style="zoom:80%;" /><ul><li>第二步，取出最小的两颗二叉树；第三步，新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181940799.png" alt="image-20241105205229638" style="zoom:80%;" /><ul><li>第四步（也可以说是回到），再以新的这些树的<strong>根节点</strong>进行从小到大排序：</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181953985.png" alt="image-20241105205419103" style="zoom:80%;" /><ul><li>开始重复：再次执行第一步（上面已经排有序了）。</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182006239.png" alt="image-20241105210527613" style="zoom:80%;" /><ul><li>再排序：(注意！实际代码运行此处有差异！)</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182018290.png" alt="image-20241105210700873" style="zoom:80%;" /><ul><li>再取、再排：</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182030635.png" alt="image-20241105211006627" style="zoom:80%;" /><ul><li>再取、再排：</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182041472.png" alt="image-20241105211150432" style="zoom:80%;" /><ul><li>最后一步——赫夫曼树的降临：</li></ul><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182052046.png" alt="image-20241105211319376" style="zoom:80%;" /><blockquote><p>（上述仅能展示思路！！但是最终的二叉树视代码实现而定！！）</p><blockquote><p>我的实现代码中，最终得到的huffmanTree就不是上面这个形状的，原因在于有一步的排序过程——出现了两个根节点为15的树。</p><p>我的代码中，采取的策略是——新生成的树都是在ArrayList末尾进行add，然后再排序，所以新生成、根节点为15的树应该在旧的那个之后……下面给出修改后过程（中间有所不同）</p><blockquote><p>为什么前序遍历后怎么和预期不一样……问题就出在这里……</p></blockquote></blockquote></blockquote><p>小结：赫夫曼树根据排序方式的不同，最终形成的赫夫曼树的结构也不同。但是WPL一致、最小。这里的&quot;排序方法&quot;语义较小，是指遇到相同元素的情况下，该如何排序。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182102706.png" alt="image-20241106113028048" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182112861.png" alt="image-20241106113522437" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182126042.png" alt="image-20241106113642780" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182137600.png" alt="image-20241106113746002" style="zoom:80%;" /><p>所以代码的前序遍历应该为：</p><p>$60 \quad 25 \quad 10 \quad 15 \quad 35 \quad 15 \quad 7 \quad 1 \quad 6 \quad 8 \quad 20$</p><h3 id="代码实现-7">代码实现</h3><p><code>HuffmanTree</code></p><p>主要代码：<code>createHuffmanTree</code>创建赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;13, 7, 8, 3, 29, 6,1&#125;;</span></span><br><span class="line"><span class="comment">//        int [] arr = &#123;&#125;;</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;huffman tree is empty&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出次小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//构建新子树：</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.weight+ rightNode.weight,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//删除已处理的，加入新的树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回这棵树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> weight) &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> weight, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">//表示从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历：(用于测试)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼编码">赫夫曼编码</h2><h3 id="思路分析-8">思路分析</h3><blockquote><p>直接采用atguigu的介绍：<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=115">视频链接</a>。</p></blockquote><p><strong>基本介绍</strong></p><p>赫夫曼编码也翻译为<strong>哈夫曼编码(Huffman Coding)</strong>，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p><p>赫夫曼编码广泛地用于<strong>数据文件压缩</strong>。其压缩率通常在20%～90%之间</p><p>赫夫曼码是**可变字长编码(VLC)**的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p><p><strong>原理</strong>：</p><ol><li><p>通信领域中信息的处理方式1-定长编码</p><ul><li><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</li><li><code>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97</code>//对应Ascii码</li><li><code>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001</code>//对应的二进制</li><li>按照二进制来传递信息，总的长度是  359   (包括空格)</li><li><a href="https://www.mokuge.com/tool/asciito16/">在线转码工具</a></li></ul></li><li><p>通信领域中信息的处理方式2-变长编码</p><ul><li><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</li><li><code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5  空格:9</code>// 各个字符对应的个数</li><li><code>0=空格 ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</code> 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.</li><li>按照上面给各个字符规定的编码，则我们在传输  “i like like like java do you like a java” 数据时，编码就是10010110100…</li></ul></li></ol><ul><li><blockquote><p>但是这种编码方式不是<strong>前缀编码</strong>[^9]，会出现二义性。</p></blockquote></li></ul><ol start="3"><li><p>通信领域中信息的处理方式3-赫夫曼编码</p><ul><li><p><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</p></li><li><p><code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</code>  // 各个字符对应的个数</p></li><li><p>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值。</p></li></ul></li></ol><p><strong>赫夫曼编码详解</strong>：</p><p>传输的字符串为：<code>i like like like java do you like a java</code></p><ol><li>统计各个字符对应的个数<code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</code></li><li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值（字符也要传入）</li></ol><blockquote><p>也就是传入$arr=[1,1,1,2,2,2,4,4,4,5,5,9]$去<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>：</p><p>构成赫夫曼树的步骤：</p><ol><li><p>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p></li><li><p>取出根节点权值最小的两颗二叉树</p></li><li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p></li><li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p></li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182149929.png" alt="image-20241106133401235" style="zoom:80%;" /></blockquote><ol start="3"><li>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下：<code>o:000u: 10010d: 100110  y: 100111  i: 101a : 110  k: 1110  e: 1111  j: 0000  v: 0001l: 001   : 01</code></li><li>按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot;   字符串对应的编码为 (注意这里我们使用的无损压缩)<code>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</code>通过赫夫曼编码处理  长度为  133</li><li>长度为:133 说明:原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%。此编码满足前缀编码,，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。赫夫曼编码是无损处理方案。</li></ol><h3 id="数据压缩">数据压缩</h3><p><strong>思路</strong>：</p><ol><li>Node { data (存放数据)， weight (权值)， left  和 right }</li><li>得到  “i like like like java do you like a java”   对应的 byte[] 数组</li><li>编写一个方法，将准备构建赫夫曼树的Node 节点放到 List  , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]…],  体现 d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</li><li>可以通过List 创建对应的赫夫曼树</li></ol><p><strong>代码解释</strong>：</p><p>这个代码过程较多，但是每一部分并不难。<br>简单归纳下：总体的目标是把原始数据对应的<code>byte[]</code> 压缩为更小的<code>byte[]</code></p><ol><li><p>获取原始数据的byte[]</p></li><li><p>将这个根据这个byte[]构建赫夫曼树，规则详见<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>，这里简单回顾：</p><ul><li>排序-》取出两个最小的节点，构成新节点-》删除两个最小节点，将新的节点加入到数组-》只要数组长度大于1，就循环整个操作-》最后通过nodesArray.get(0)就获取到了赫夫曼树的根节点。</li></ul><blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182204232.png" alt="image-20241106163538269" style="zoom:67%;" /></blockquote></li><li><p>创建<strong>赫夫曼树</strong>后，就要利用赫夫曼树，得到对应的<strong>赫夫曼编码</strong>，规则为——为每一个叶子节点的值data编一个&quot;码&quot;，这个码就是从根节点到叶子节点的路径，每向左拼接一个&quot;0&quot;，每向右拼接一个&quot;1&quot;。最终得到赫夫曼编码，存放在Map&lt;key,value&gt;中，key就是数据，比如97('a’的ASCII)，value就是对应的码，比如01</p></li></ol><blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182216330.png" alt="image-20241106163609031" /></blockquote><ol start="4"><li>根据这个赫夫曼编码，可以将原始数据压缩，压缩过程又细分两步：<ol><li>由于光是通过赫夫曼编码处理后，得到的只是&quot;0100110101010…&quot;这样的<strong>字符串</strong>，甚至比原先的字符串还长，所以要将这个字符串转换为8位一个的byte</li><li>第二步就是转换，不足8位就截断。<code>huffmanCodeBytes[k] = (byte) Integer.parseInt(strByte, 2);</code>其中，strByte是每次取了8位（不足就截断）。</li></ol></li><li>最后得到的<code>huffmanCodeBytes</code>就是最终结果（类型为<code>byte[]</code>，且长度比<code>str.getBytes()</code>要短，就做到了压缩）</li></ol><blockquote><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182226996.png" alt="image-20241106164313508" style="zoom: 80%;" /></blockquote><p>可能需要补充的知识？</p><p>原码、反码、补码的转换。（也就是在压缩过程，为什么从&quot;10101000&quot;变成huffmanCodeBytes中的-88）</p><p>10101000(补码)-&gt;10100111(反码)-&gt;11011000(原码)</p><p>补码-1 = 反码；符号位不变，反码取反=原码。原码对应值计算为-88。</p><h4 id="实现1">实现1</h4><p><code>HuffmanCode</code></p><blockquote><p>若对此代码不懂，再看一遍：<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=117">p117</a>至<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=120">p120</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();</span><br><span class="line">        System.out.println(<span class="string">&quot;还未压缩前的长度：&quot;</span> + contentBytes.length);</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;nodes：&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建赫夫曼树为：&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        huffmanTreeRoot.preOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot);</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); <span class="comment">//(其实不新生成也行，如上)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;生成的赫夫曼编码为：&quot;</span> + HuffmanCode.huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(<span class="string">&quot;huffmanCodeBytes：&quot;</span>+Arrays.toString(huffmanCodeBytes));</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩率为:&quot;</span>+(contentBytes.length-huffmanCodeBytes.length * <span class="number">1.0</span>) / contentBytes.length * <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="封装后实现2">封装后实现2</h4><p><code>HuffmanCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输入的原始数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span>+Arrays.toString(huffmanBytes));</span><br><span class="line"><span class="comment">//        对此部分进行封装：</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;还未压缩前的长度：&quot; + contentBytes.length);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //通过getNodes方法得到byte[]数组对应的节点（）</span></span><br><span class="line"><span class="comment">//        List&lt;Node&gt; nodes = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;nodes：&quot; + nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;创建赫夫曼树为：&quot;);</span></span><br><span class="line"><span class="comment">//        Node huffmanTreeRoot = createHuffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        huffmanTreeRoot.preOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot);</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); //(其实不新生成也行，如上)</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生成的赫夫曼编码为：&quot; + HuffmanCode.huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeBytes：&quot;+Arrays.toString(huffmanCodeBytes));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩率为:&quot;+(contentBytes.length-huffmanCodeBytes.length * 1.0) / contentBytes.length * 1.0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes,huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据解压">数据解压</h3><p><strong>思路</strong>：</p><ol><li>将赫夫曼压缩后的字节数组转换为  二进制字符串。使用<code>byteToBitString</code>方法</li><li>再将这个二进制字符串 对照 赫夫曼编码 转换为原始字符串。使用<code>decode</code>方法</li></ol><p><code>HuffmanCode</code></p><blockquote><p>注意：此代码有bug（没修）——如果最后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span> + Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(sourceBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件的压缩和解压">文件的压缩和解压</h3><p><code>zipFile</code>方法和<code>unZipFile</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//        String srcFile = &quot;C:\\Users\\26423\\Desktop\\ceshi22.bmp&quot;;</span></span><br><span class="line"><span class="comment">//        String dstFile =&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;;</span></span><br><span class="line"><span class="comment">//        zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩文件成功&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi2333.bmp&quot;</span>;</span><br><span class="line">        unZipFile(zipFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压文件成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对文件的解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义文件输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和 is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组 huffmanCodes</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//写数据到dstFile文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 希望压缩的文件的完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 压缩后的文件放到哪个目录下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//这里以对象流的形式写入 赫夫曼编码（是为了以后恢复源文件时使用）</span></span><br><span class="line">            <span class="comment">//注意一定要把赫夫曼编码写入压缩文件（不然恢复不了）</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件压缩注意事项">文件压缩注意事项</h3><ol><li>如果文件本身就是经过压缩的，那么使用赫夫曼编码压缩后大小不会有明显变化，比如视频、ppt、png。</li><li>赫夫曼编码是按字节来处理的，因此可以处理所有文件（二进制文件、文本文件）(.xml)</li><li>如果一个文件中的内容重复数据不多，压缩效果也不会很明显。</li></ol><h1>二叉搜索树</h1><h2 id="基本介绍">基本介绍</h2><p><strong>二叉搜索树</strong>，<strong>BST(Binary Search Tree)</strong>，对于二叉搜索树的任何一个<strong>非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。如果有相同的值，可以放在左子节点或右子节点。</p><h2 id="二叉搜索树的创建和遍历">二叉搜索树的创建和遍历</h2><p>新加入节点时：</p><ol><li>若新加入节点为空，直接返回。</li><li>比较插入值和当前节点值大小，若小于当前节点值，判断左节点是否为空，若为空，直接插入到左节点，否则向左递归地插入</li><li>否则（大于等于），判断右节点是否为空，若为空则直接插入到右节点，否则向右递归地插入</li></ol><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试二叉搜索树的中序遍历：&quot;</span>);</span><br><span class="line">        bst.inOrder();<span class="comment">//发现刚好是升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树节点的删除">二叉搜索树节点的删除</h2><h3 id="思路分析-9">思路分析</h3><blockquote><p>由于删除时情况较多（但是不难），所以还是需要理一下所有可能的情况</p></blockquote><p>分以下三种情况：</p><ol><li>删除叶子节点</li><li>删除只有1颗子树的节点</li><li>删除有2颗子树的节点</li></ol><p><strong>具体思路</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182238374.png" alt="image-20241108193248201" style="zoom:80%;" /><ol><li><p>若删除叶子节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，再删除。</li></ul></li><li><p>删除只有一颗子树的节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，以及确定<code>targetNode</code>是有左子树还是右子树</li><li>因此有四种情况：<ul><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有左子树——<code>parent.left = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有右子树——<code>parent.left = targetNode.right</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有左子树——<code>parent.right = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有右子树——<code>parent.right = targetNode.right</code></li></ul></li><li>删除5为例：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182250598.png" alt="image-20241108193304227" style="zoom:80%;" /></li></ul></li><li><p>删除有两颗子树的节点</p><ul><li><p>先要找到目标节点<code>targetNode</code></p></li><li><p>在找的同时，要用<code>parentNode</code>标记其父节点</p></li><li><p>从<code>targetNode</code>的右子树里找到最小的节点    （或从<code>targetNode</code>的左子树里找最大的节点（同样的流程））</p></li><li><p>如图找到：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182303500.png" alt="image-20241108193645936" style="zoom:80%;" /></p></li><li><p>用<code>temp</code>临时存储最小节点<code>minNode</code>的值，删除<code>minNode</code>，这一步删除有点特殊：<code>targetNode.left = minNode.right</code>。这是一句通用的写法，可以适应不同情况：因为既然是在<code>targetNode</code>的右子树里找的<code>minNode</code>，所以其左边必定无节点，且无论其右节点是否为空，都可以这样子写。</p></li><li><p>如图删除：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182315889.png" alt="image-20241108194225832" style="zoom:80%;" /></p></li><li><p>删除<code>targetNode</code>，即<code>targetNode.value = temp</code></p></li><li><p>如图：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182333482.png" alt="image-20241108194625603" style="zoom:80%;" /></p></li></ul></li><li><p>特别注意！上述找到的<code>parentNode</code>可能为null，说明要删除的节点是root节点。</p></li></ol><blockquote><p>思考：上述思路可能有可以改进的地方——也就是&quot;<strong>找到要删除的节点的父节点</strong>&quot;，为了这个父节点，代码实现中还特地写了一个独立的方法去查找。好处是清晰，坏处是可能效率略降低？（原路多找一次）。</p><p>可能的改进思路：可以把<code>search</code>待删除节点的方法作一定修改：可以返回一个集合，里面装两个节点（被删除节点和父节点）；可以直接返回父节点，后续删除时只是需要多判断一下其左右节点哪个是要被删除的，如何保证被删除的节点的稳定——通过<code>if(this.left.value == val)</code>来判断？那么左右节点值都一样呢？（以及万一是根节点要被删除，那么如何返回这个父节点的问题）</p><p>代码暂时不作优化。</p></blockquote><h3 id="代码实现-8">代码实现</h3><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试delNode方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除前：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">        bst.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">        <span class="keyword">if</span>(targetNode == <span class="literal">null</span>) <span class="keyword">return</span>;<span class="comment">//找不到待删除节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">        <span class="keyword">if</span>(parentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明要删除的节点就是root节点（也要分三种……）</span></span><br><span class="line">            <span class="comment">//如果左右为空，直接删</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左右都有子树，选取右子树中最小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//temp 为 找到的root的右子树的最小节点</span></span><br><span class="line">                <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentOfTemp = temp;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                parentOfTemp.left = temp.right;</span><br><span class="line">                root.value = temp.value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有左或右，直接更新root</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>) root = root.left;</span><br><span class="line">                <span class="keyword">else</span> root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的节点不是root（保证了操作parentNode时不出错）</span></span><br><span class="line">        <span class="comment">//1.待删除节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(parentNode.left!=<span class="literal">null</span> &amp;&amp; parentNode.left.value == value) parentNode.left =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> parentNode.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.待删除节点有左子树和右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//temp 为 找到的targetNode的右子树的最小节点</span></span><br><span class="line">            <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> targetNode.right;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> targetNode;</span><br><span class="line">            <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parentOfTemp = temp;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            parentOfTemp.left = temp.right;</span><br><span class="line">            targetNode.value = temp.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.待删除节点只有左子树或右子树</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//目标节点在parentNode的左边</span></span><br><span class="line">            <span class="keyword">if</span>(parentNode.left != <span class="literal">null</span> &amp;&amp; parentNode.left.value == value)&#123;</span><br><span class="line">                <span class="comment">//目标节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.left = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.left = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//目标节点在parentNode的右边</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.right = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.right = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//我总是忘记--这种判断自身是否为空的操作……但其实很必要加，不然就会报空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找待删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) || (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不好的写法，是暴力查找！</span></span><br><span class="line"><span class="comment">//            if(this.left != null) return this.left.searchParent(value);</span></span><br><span class="line"><span class="comment">//            if(this.right != null) return this.right.searchParent(value);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//效率高的写法：</span></span><br><span class="line">            <span class="comment">//如果要查找的值小于当前的值，且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找为value的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明找不到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);<span class="comment">//递归地继续找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>后记：代码中有一部分可以拿出来作为一个方法<code>int delRightTreeMin(Node node)&#123;&#125;</code></p><p>说明：<code>node</code>为传入的结点，方法作用是删除以node为根节点这棵二叉排序树的最小根节点，最后返回最小节点<code>minNode</code>的值。</p><p>ps：该方法可用于替换代码中的两部分——一是待删除结点有左右子树且待删除结点就是root，二是待删除结点有左右子树且待删除结点不是root。</p></blockquote><h1>平衡二叉树</h1><p><strong>问题</strong>：</p><p>如下图可见<strong>二叉搜索树</strong>可能存在的问题:</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182346268.png" alt="image-20241109195852364" style="zoom:80%;" /><p>有以下问题：1.左子树都为空，更像单链表；2.插入速度没有影响，但查询速度大幅减低(每次向下一层前还需要和左比较，比链表还慢)，不能发挥BST（BinarySearchTree）的查询优势。</p><p>解决方案：<strong>平衡二叉树（AVL）</strong></p><p><strong>基本介绍</strong></p><ol><li><strong>平衡二叉树</strong>也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）<strong>又被称</strong>AVL树</strong>，可以保证<strong>查询效率较高</strong>。</li><li>特点：<ul><li>是一颗<strong>空树</strong>或它的<strong>左右子树的高度差的绝对值不超过1</strong>。</li><li><strong>左右子树都是一棵平衡二叉树</strong>。</li></ul></li><li>常用实现算法有：红黑树、AVL、替罪羊树、Treap、伸展树等</li></ol><p>为了使得一棵普通的二叉搜索树变成平衡二叉树，也就是让左右子树的高度差降低，我们引出一些方法——e.g.<strong>左旋转</strong>、<strong>右旋转</strong>、<strong>双旋转</strong></p><h2 id="左旋转">左旋转</h2><p>适用于右子树高度大于左子树的情况</p><p><strong>左旋转步骤</strong>：</p><ol><li>保存当前节点的值，已该值创建<code>newNode</code></li><li>将<code>newNode</code>的left设置为当前节点的左子树</li><li>将<code>newNode</code>的right设置为当前节点的右子树的左子树</li><li>将当前节点的值更新为右子树的值</li><li>将当前节点的right设置为右子树的右子树</li><li>将当前节点的left设置为<code>newNode</code></li></ol><p><strong>左旋转图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182400936.png" alt="image-20241110094040328" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182412965.png" alt="image-20241110094207819" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182432522.png" alt="image-20241110094235038" style="zoom:80%;" /><p>至此，这棵树就符合平衡二叉树的定义。</p><p>可以看出：左旋转用于当一棵树的左子树的高度小于右子树的高度时。（记忆，想象一个旋钮，把它往左边旋转，那么右边就&quot;旋上去&quot;，右边高度就降低了）</p><h3 id="代码实现-9">代码实现</h3><ol><li>新增三个方法<code>height</code>、<code>leftHeight</code>、<code>rightHeight</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回右子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回左子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以当前结点为根节点的树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>左旋转方法<code>leftRotate</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建新节点，记录当前节点的值</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="comment">//2. 将newNode的left设置为当前节点的左子树</span></span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">    <span class="comment">//3. 将newNode的right设置为当前节点的右子树的左子树</span></span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right.left;<span class="comment">//****这里不用判断有没有右子树，因为如果this.right为空的话，也不可能会导致右子树比左子树高，更不会执行左旋转*****</span></span><br><span class="line">    <span class="comment">//4. 将当前节点的值更新为右子树的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">    <span class="comment">//5. 将当前节点的right设置为右子树的右子树</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">    <span class="comment">//6. 将当前节点的left设置为newNode</span></span><br><span class="line">    <span class="built_in">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋转">右旋转</h2><p>适用于左子树高度大于右子树的情况</p><p><strong>右旋转步骤</strong>：</p><ol><li>保存当前结点的值，以该值创建<code>newNode</code></li><li>将<code>newNode</code>的right设置为当前节点的右子树</li><li>将<code>newNode</code>的left设置为当前结点的左子树的右子树</li><li>将当前结点的值更新为左子树的值</li><li>将当前结点的left设置为左子树的左子树</li><li>将当前结点的right设置为<code>newNode</code></li></ol><p><strong>右旋转图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182504801.png" alt="image-20241110133603478" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182514707.png" alt="image-20241110133631995" style="zoom:80%;" /><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182524611.png" alt="image-20241110133707683" style="zoom:80%;" /><h3 id="代码实现-10">代码实现</h3><p><code>rightRotate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">    <span class="built_in">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加节点时使用左旋转和右旋转方法：</p><p><code>Node.add</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归地添加节点的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span>(rightHeight()-leftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">if</span>(leftHeight()-rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双旋转">双旋转</h2><p>有情况下，仅凭一次左旋转或右旋转是无法使的二叉搜索树转换为平衡二叉树的。</p><p>e.g.<code>int[] arr=&#123;10,11,7,6,8,9&#125;;</code>此时发现，经过一次右旋转后，反而使得右子树的高度比左子树的高度大1。</p><p><strong>图示</strong>：<img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182537421.png" alt="image-20241110141336862" style="zoom:80%;" /></p><p><strong>解决方法——双旋转思路+图解</strong>：</p><ol><li><p>当<strong>符合右旋转</strong>的条件时（<code>this.leftHeight() - this.rightHeight() &gt; 1</code>）<br><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182549008.png" alt="image-20241110141635728" style="zoom:80%;" /></p></li><li><p>且如果它的 <strong>左子树的右子树的高度 大于 左子树的左子树的高度</strong>，即<code>this.left.rightHeight() &gt; this.left.leftHeight()</code><br><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182559575.png" alt="image-20241110142528639" style="zoom:80%;" /></p></li><li><p>先需<strong>对当前节点的左子树进行左旋转</strong>，即<code>this.left.leftRotate()</code><br><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182610683.png" alt="image-20241110142933085" style="zoom:80%;" /></p></li><li><p>再对当前节点进行右旋转，即<code>this.rightRotate()</code><br><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182622396.png" alt="image-20241110143304696" style="zoom:80%;" /></p></li></ol><blockquote><p>如果是“<strong>当符合左旋转</strong>”的条件时，且“它的 <strong>右子树的左子树的高度 大于 右子树的右子树的高度</strong>”</p></blockquote><h3 id="代码实现-11">代码实现</h3><p><code>Node.add</code>方法的修改，使其能够进行双旋转（可以对比<a href="####%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">右旋转代码实现</a>里面的add方法，有什么区别）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的右子树的左子树的高度 大于 它的右子树的右子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.leftHeight() &gt; <span class="built_in">this</span>.right.rightHeight()) &#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的右结点 进行右旋转</span></span><br><span class="line">            <span class="built_in">this</span>.right.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的左子树的右子树的高度 大于 它的左子树的左子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.rightHeight() &gt; <span class="built_in">this</span>.left.leftHeight())&#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的左结点 进行左旋转</span></span><br><span class="line">            <span class="built_in">this</span>.left.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>多叉树</h1><p><strong>二叉树存在问题</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182634337.png" alt="image-20241110144142213" style="zoom:80%;" /><ol><li>二叉树加载到内存时，如果节点数量过多，会存在问题：</li><li>构建二叉树时，需进行多次i/o操作（海量数据一般在文件或数据库中），对构建效率有影响。</li><li>海量数据也会造成树的高度过大（谁告诉你一定是满二叉树?）</li></ol><p><strong>多叉树基本介绍</strong></p><ol><li>在二叉树中，每个结点有数据项，最多有两个子节点。如果允许每个结点可以有更多的数据项和子结点，就是<strong>多叉树（Multiway Tree）</strong></li><li>2-3树、2-3-4树就是多叉树，多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化</li><li>举例图：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182644649.png" alt="image-20241110144751794" style="zoom:80%;" /><p><strong>B树基本介绍</strong></p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182654628.png" alt="image-20241110115227975" style="zoom:80%;" /><ol><li>B树通过重新组织结点，降低树的高度，减少了i/o读写次数来提升效率</li><li><strong>文件系统及数据库系统的设计者利用了磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页</strong>(页得大小通常为4k)，这样<strong>每个节点只需要一次I/O</strong>就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中</li></ol><p><strong>2-3树基本介绍</strong></p><p>2-3树是最简单的B树结构，具有如下特点:</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>（B树都满足）</li><li>有两个子节点的节点叫<strong>二节点</strong>，二节点<strong>要么没有子节点</strong>，<strong>要么有两个</strong>子节点</li><li>有三个子节点的节点叫<strong>三节点</strong>，三节点<strong>要么没有子节点</strong>，<strong>要么有三个</strong>子节点</li><li>2-3树是由<strong>二节点和三节点</strong>构成的树。</li></ol><h2 id="2-3树">2-3树</h2><p><strong>关于三节点的说明</strong>：</p><p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182708712.png" alt="image-20241110144908830" style="zoom:80%;" />7号节点在8号左边，10号介于8和12中间，14在12右边。</p><p><strong>构建2-3树</strong>：</p><p><strong>插入规则</strong>：</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>。（B树都满足这个条件）</li><li>二节点要么没有子节点，要么有两个子节点。</li><li>三节点要么没有子节点，要么有三个子节点。</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆</strong>，<strong>如果上层满，则拆本层</strong>，拆后仍然需要满足上面3个条件。</li><li>对于三节点的子树的值大小仍然遵守（BST 二叉搜索树）的规则</li></ol><p><strong>图解</strong>：</p><p>以数列${ 16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20 } $为例</p><ol><li>插入16，24，12，32。十分自然：</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182719769.png" alt="image-20241110164703683" style="zoom:80%;" /><ol start="2"><li>插入14（简单）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182735098.png" alt="image-20241110164746993" style="zoom:80%;" /><ol start="3"><li>插入26（需拆上一层）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182746622.png" alt="image-20241110164905390" style="zoom:80%;" /><ol start="4"><li>插入34（简单）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182756249.png" alt="image-20241110165036078" style="zoom:80%;" /><ol start="5"><li>插入10（复杂）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182805896.png" alt="image-20241110165746037" style="zoom:150%;" /><ol start="6"><li>插入8（自然）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182817198.png" alt="image-20241110170229138" style="zoom:80%;" /><ol start="7"><li>插入28（中间过程演示）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182829094.png" alt="image-20241110170605919" style="zoom:80%;" /><ol start="8"><li>插入38（简单）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182839077.png" alt="image-20241110170903042" style="zoom:80%;" /><ol start="9"><li>插入20（简单）</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182848306.png" alt="image-20241110170950636" style="zoom:80%;" /><h2 id="2-3-4树">2-3-4树</h2><p>2-3-4树概念和2-3树类似，多了一个四节点，也是一种B树</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182858787.png" alt="image-20241110121240298" style="zoom:80%;" /><h2 id="B树">B树</h2><p><strong>B-tree树</strong>即<strong>B树</strong>，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，<strong>B-tree就是指的B树</strong>。（还有写成<strong>B-树</strong>的，实际上没有&quot;B减树&quot;，就是B树）</p><ol><li><strong>B树的阶</strong>：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li><li><strong>B树的搜索</strong>：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong></li><li>搜索<strong>有可能在非叶子结点结束</strong>（已找到）</li><li>其搜索性能<strong>等价于在关键字全集内做一次二分查找</strong></li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182939663.png" alt="image-20241110171831364" style="zoom:80%;" /><h2 id="B-树">B+树</h2><p>B+树是B树的变体，也是一种多路搜索树。</p><ol><li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li><li>不可能在非叶子结点命中</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li><li>更适合文件索引系统</li><li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501182950012.png" alt="image-20241110172528554" style="zoom:80%;" /><h2 id="B-树-2">B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p><ol><li>B* 树定义了非叶子结点关键字个数至少为$\frac{2}{3}M$，即块的最低使用率为$\frac{2}{3}$，而B+树的块的最低使用率为B+树的$\frac{1}{2}$。</li><li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——哈希表</title>
      <link href="/2025/03/30/algorithm/datastruct/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2025/03/30/algorithm/datastruct/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>哈希表(散列)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong>：</p><p>散列表（也叫哈希表），是根据关键码值而直接进行访问的数据结构。</p><p>它通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><strong>哈希表的价值</strong>：</p><p>对于经常要使用的数据，放在缓存层使用，减少了数据库的压力。哈希表相当于起到了一个缓存层的作用。</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181628969.png" alt="image-20241103095217216" style="zoom:80%;" /><p><strong>图解</strong>：</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181641675.png" alt="image-20241102202555264" style="zoom:80%;" /><p>此处用一个实际题目来使用哈希表：</p><p>（google公司上机题:）有一个公司，当有新员工来报到时，要求将该员工的信息加入(id，性别，年龄，住址……)，当输入该员工的id时，要求查找到该员工的所有信息。要求不适用数据库，尽量节省内存，速度越快越好=》哈希表（散列）</p><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501181655290.png" alt="image-20241102203438163" style="zoom:80%;" /><p><strong>思路分析</strong>：</p><ol><li>使用Emp类管理每个员工的信息。</li><li>使用EmpLinkedList表示一条链表。</li><li>HashTable就是真正的哈希表，里面包含了增加、遍历、查找、删除操作。但是必须有<strong>散列函数</strong>，其作用是指示id对应的链表。</li></ol><h2 id="代码实现">代码实现</h2><p><code>HashTabDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.hashTab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a：增加员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;l：显示员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;f：查找员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d：删除员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入id:&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入名字:&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    hashTab.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(id, name));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span> -&gt; &#123;</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要查找的员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要删除的员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTab.deleteByEmpId(id);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Emp</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//默认为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Emp</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//此处的head就是第一个员工</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    假定添加员工时，id自增长（从小到大），则将员工添加到最后即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = emp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;List:&quot;</span> + no + <span class="string">&quot; is empty&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;=&gt; id:&quot;</span> + p.id + <span class="string">&quot; name:&quot;</span> + p.name);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.id == id) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByEmpId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法删除，未找到该员工&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.id == id)&#123;</span><br><span class="line">                    prev.next = p.next;<span class="comment">//删除p节点</span></span><br><span class="line">                    System.out.printf(<span class="string">&quot;员工%d：%s已成功删除\n&quot;</span>,p.id,p.name);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;无法删除，未找到该员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashTab用于管理多条链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//表示有几条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//不要忘了分别初始化！！！！！上述只是得到了一个数组Array，里面全为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//根据员工id得到该员工应该添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(emp.id);</span><br><span class="line">        empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有链表，遍历hashTab（数组+链表才是hashTab）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据输入的id查找员工</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//使用散列函数，确定到哪条链表查找（提高查找速度的关键所在！）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        emp = empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在第&quot;</span>+empLinkedListNo+<span class="string">&quot;条链表中找到员工：&quot;</span>+<span class="string">&quot;id:&quot;</span> + emp.id + <span class="string">&quot; name:&quot;</span> + emp.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到该员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByEmpId</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);<span class="comment">//根据散列函数，定位该id所在链表</span></span><br><span class="line">        empLinkedListArray[empLinkedListNo].deleteByEmpId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数（写法很多，此处用%）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——栈</title>
      <link href="/2025/03/30/algorithm/datastruct/%E6%A0%88/"/>
      <url>/2025/03/30/algorithm/datastruct/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1>栈</h1><h2 id="数组模拟栈实现">数组模拟栈实现</h2><h3 id="思路分析">思路分析</h3><ol><li><p>栈(stack)是一个<strong>后进先出</strong>的有序列表。</p></li><li><p>栈是限制线性表中元素的插入和删除操作只能在线性表的同一端进行的特殊线性表。允许<strong>插入和删除</strong>的一端，为<strong>变化的一端</strong>，称为<strong>栈顶</strong>；另一端为<strong>固定的一端</strong>，称为<strong>栈底</strong>。</p></li><li><p>常用方法：</p><ul><li><code>pop</code>出栈，先判断<code>isEmpty</code>，<code>return arr[top--]</code>先返回数据，后将top指针向下移动。</li><li><code>push</code>入栈，先判断<code>isFull</code>是否已满，若无，再<code>arr[++top]</code>，先指向下一个位置，再入栈。</li><li><code>isFull</code>判断是否为空，<code>top == -1</code></li><li><code>isEmpty</code>判断是否已满，<code>top == maxSize-1</code></li></ul></li><li><p>应用场景：</p><ul><li>子程序的调用：在跳往子程序前，先将下个指令的地址存到堆栈中，等子程序执行完了，再将地址取出，继续执行源程序。</li><li>递归调用：和子程序的调用类似，不过除了存储下一个指令的地址外，还将参数、区域变量等数据存入堆栈。</li><li>表达式的转换[<strong>中缀表达式转后缀表达式</strong>]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图的深度优先搜索法。</li></ul></li></ol><h3 id="代码实现">代码实现</h3><p><code>ArrayStack</code></p><blockquote><p>后续的<a href="##%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8">栈实现简易计算器</a>也基于下方代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is empty，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is full，无法入栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++top] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is empty，无法获取栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法仅为自己查看方便</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;栈arr[%d]=%d \n&quot;</span>, i, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ArrayStackDemo</code></p><blockquote><p>就不写一个简易的用户界面了（与前类似）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stack.push(<span class="number">5</span>);</span><br><span class="line">            stack.push(<span class="number">6</span>);</span><br><span class="line">            stack.push(<span class="number">7</span>);</span><br><span class="line">            stack.push(<span class="number">8</span>);</span><br><span class="line">            stack.push(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//            stack.push(10);</span></span><br><span class="line"></span><br><span class="line">            stack.traverse();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;出栈：&quot;</span>+stack.pop());</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.pop();</span><br><span class="line">            System.out.println(<span class="string">&quot;栈顶元素为：&quot;</span>+stack.top());</span><br><span class="line"></span><br><span class="line">            stack.traverse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈实现简易计算器">栈实现简易计算器</h2><h3 id="思路分析-2">思路分析</h3><p>例如要使用栈完成$2 * 50 - 2 + 8 \div 2 = ?$  $2+3*4 - 1$</p><blockquote><p>使用<strong>中缀表达式</strong>[^1]</p></blockquote><blockquote><p>数字可能不仅仅是个位，运算符号包括加+减-乘*除/，其他符号包括小括号、等号。（这一版代码先不考虑实现小括号）</p></blockquote><ol><li>使用一个索引<code>index</code>来遍历表达式</li><li>使用一个数栈<code>numStack</code>和一个符号栈<code>opStack</code>分别存放数字和运算符</li><li>使用一个<code>isNum</code>记录上一个输入的元素<ul><li>可用作判断输入数字是否为多位数，也可用作判断表达式输入是否有误(比如$1 + - 2$)</li></ul></li><li>当index遍历时，遇到：</li></ol><ul><li>数字。<ul><li>判断上一个入栈的元素，若也为数字，则说明是个多位数；</li><li>若上个入栈的不是数字，则直接入栈。</li></ul></li><li>运算符。<ul><li>如果符号栈为空，直接入栈</li><li>只要符号栈不为空，判断当前读取的符号和栈内符号的优先级。若当前符号的<strong>优先级小于等于</strong>栈内符号，则从数栈中<strong>不断</strong>出栈两个数字、符号栈中出栈一个符号进行运算，将结果入数栈；若当前符号<strong>优先级大于</strong>栈内符号，则继续入栈。</li></ul></li><li>小括号。<ul><li>若为左括号，则直接入符号栈；</li><li>若为右括号，判断栈顶符号——栈顶若为左括号，则说明当前表达式输入有误，若不是，则继续出栈，继续进行出栈时的符号判断，直至将左括号出栈，最后将运算结果入数栈。（小括号就相当于一个弱化版的等号，只是将括号范围内做运算）</li></ul></li><li>等号。每次从数栈取两个、符号栈取一个出栈，得到最终计算结果。</li></ul><blockquote><p>基于<a href="##%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%AE%9E%E7%8E%B0">数组模拟栈实现</a>所使用的<code>ArraryStack</code>类（由于这个栈内存储元素仅为int类型，为了建立int与char类型符号的关联，还增加了一个枚举类）</p><blockquote><p><code>CV</code>前请注意文件目录结构</p></blockquote></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>Calculator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">100</span>);<span class="comment">//数栈</span></span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">opStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">100</span>);<span class="comment">//符号栈</span></span><br><span class="line">    <span class="type">boolean</span> isNum;<span class="comment">//记录上一个入栈的元素是否为数字</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">endCalculate</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasNoneUseChar</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//仅作为最终提示输出的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(String.valueOf(ch).matches(<span class="string">&quot;\\d&quot;</span>))&#123;</span><br><span class="line">                pushNum(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pushOp(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endCalculate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNoneUseChar)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入了无关符号,仅支持0-9以及+-*/=,运算时已忽略无关符号&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numStack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错,是否是遗漏了&#x27;=&#x27;?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushNum</span><span class="params">(<span class="type">char</span> number)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(number));</span><br><span class="line">        <span class="keyword">if</span>(!isNum) &#123;<span class="comment">//上一个 是符号入栈</span></span><br><span class="line">            numStack.push(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp_num</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">            numStack.push(temp_num*<span class="number">10</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">        isNum = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushOp</span><span class="params">(<span class="type">char</span> operator)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOtherChar</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//排除输入其他符号的干扰</span></span><br><span class="line">        <span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(OperateEnum.PLUS.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(OperateEnum.MINUS.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span>  <span class="string">&#x27;*&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="comment">//一定要先判断是否为空，否则当第一个操作符为*时，会出现抛出异常</span></span><br><span class="line">                <span class="comment">//虽然下面的写法有部分代码重合，但是这样子写逻辑清晰：</span></span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty()) &#123;</span><br><span class="line">                    opStack.push(OperateEnum.TIMES.getCode());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opStack.isEmpty() &amp;&amp; (opStack.top()==<span class="number">3</span> || opStack.top()==<span class="number">4</span>)) &#123;</span><br><span class="line">                        <span class="comment">//第一个条件判断必须加，因为在operate后，可能使得opStack中为空！(例如1*1*1...)然后导致top()方法抛出异常</span></span><br><span class="line">                        operate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    opStack.push(OperateEnum.TIMES.getCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty()) &#123;</span><br><span class="line">                    opStack.push(OperateEnum.DIVIDE.getCode());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opStack.isEmpty() &amp;&amp; (opStack.top()==<span class="number">3</span> || opStack.top()==<span class="number">4</span>))&#123;</span><br><span class="line">                        operate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    opStack.push(OperateEnum.DIVIDE.getCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                endCalculate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="built_in">this</span>.hasNoneUseChar = <span class="literal">true</span>;</span><br><span class="line">                isOtherChar = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOtherChar)&#123;</span><br><span class="line">            isNum = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行一次运算：</span></span><br><span class="line">    <span class="comment">//从numStack取出两个数、从opStack取出一个符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> opStack.pop();</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1+num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1-num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1*num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(num2==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(num1/num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>OperateEnum</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;</span><br><span class="line">    PLUS(<span class="number">1</span>),</span><br><span class="line">    MINUS(<span class="number">2</span>),</span><br><span class="line">    TIMES(<span class="number">3</span>),</span><br><span class="line">    DIVIDE(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    OperateEnum(<span class="type">int</span> code) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>TestCalculator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String input = &quot;1*1*1-1*1*2+3*4-4/2-1+100-10*1=&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;1+1 0  )(&#123;&#125;= &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculator.caculate(input);</span><br><span class="line">            System.out.printf(<span class="string">&quot;计算结果为：%d&quot;</span>, res);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>后期留言：一点都不是“简易”计算器，实现过程会有很多小错误……Debug了很久</p></blockquote><h2 id="逆波兰计算器-经典">逆波兰计算器(经典)</h2><h3 id="思路分析-3">思路分析</h3><h4 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h4><p><strong>思路步骤</strong>分析：</p><ol><li>初始化两个栈运算符栈<code>s1</code>和存储中间结果栈<code>s2</code></li><li>从左到右扫描<em>中缀表达式</em>[^1]</li><li>遇到操作数时，将其压入<code>s2</code></li><li>遇到运算符时，比较其与<code>s1</code>栈顶运算符的优先级：<ol><li>如果<code>s1</code>为空，或栈顶元素为<code>(</code>，则直接将该运算符入栈</li><li>否则，若优先级比栈顶元素高，也将该符号压入<code>s1</code></li><li>否则，将<code>s1</code>栈顶的运算符弹出压入<code>s2</code>中，再次转到4.1.与<code>s1</code>中新的栈顶元素比较</li></ol></li><li>遇到括号时：<ol><li>如果是左括号<code>(</code>，则直接压入<code>s1</code></li><li>如果是右括号<code>)</code>，则依次弹出<code>s1</code>中运算符并压入<code>s2</code>，直到遇到左括号<code>)</code>为止，此时就将这一对括号丢弃</li></ol></li><li>重复2.—5.步骤，直到表达式最右边</li><li>将<code>s1</code>中剩余的符号弹出压入<code>s2</code></li><li>依次弹出<code>s2</code>中元素并输出，<strong>结果的逆序</strong>即为中缀表达式所对应的后缀表达式</li></ol><blockquote><p><code>s2</code>可用队列优化（省去了取逆序）</p></blockquote><blockquote><p>代码实现均在<code>PolandNotation</code>中</p></blockquote><h4 id="利用后缀表达式计算">利用后缀表达式计算</h4><p>要求：</p><ol><li>输入一个<em>后缀表达式</em>[^1]（逆波兰表达式），利用栈（Stack）计算结果</li><li>支持小括号和多位整数</li></ol><h3 id="代码实现-3">代码实现</h3><p><code>PolandNotation</code></p><blockquote><p>输入后缀表达式，计算结果</p><p>计算很简单：遍历表达式(存到ArrayList中)遇到数就入栈遇到符号就取出两个数、计算、结果入栈最后栈中剩余的就是结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">        <span class="comment">//为了处理方便，逆波兰表达式的数字和符号间用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 * 6 - &quot;</span>;</span><br><span class="line">        <span class="comment">//1. 先将&quot;3 4 + 5 * 6 - &quot;放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2. 将ArrayList传递给一个方法，遍历ArrayList 配合栈，完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;计算结果为：%d&quot;</span>, calculate(rpnList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String ele: split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; rpnList)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈（一个即可）</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span>(String item:rpnList)&#123;</span><br><span class="line">            <span class="comment">//使用正则表达式取出数（正则表达式为多位数）</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//pop出两个数，运算，再将结果入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算法有问题&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line"><span class="comment">//                stack.push(&quot;&quot;+res);</span></span><br><span class="line">                stack.push(Integer.toString(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的就是结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——队列</title>
      <link href="/2025/03/30/algorithm/datastruct/%E9%98%9F%E5%88%97/"/>
      <url>/2025/03/30/algorithm/datastruct/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1>队列</h1><h2 id="数组模拟队列实现">数组模拟队列实现</h2><h3 id="思路分析">思路分析</h3><p>核心：<strong>先进先出</strong>，这也是队列应用场景的核心思路。</p><p>从代码的角度考虑</p><ol><li>我们需要一个arr[]数组来存储每一个元素</li><li>规定front指向<strong>第一个元素的前一个位置</strong>，front会随着数据的输出而改变。</li><li>规定rear指向<strong>最后一个元素的前一个位置</strong>，rear会随着数据的输入而改变。</li><li>当<code>rear == MAXSIZE - 1</code>时，队列满</li><li>当<code>rear == front</code>时，队列为空</li><li><code>enQueue</code>入队操作时<ul><li>先判断队列是否已满（使用isFull方法）</li><li>将尾指针后移<code>++rear</code>, 再入队列</li></ul></li><li><code>deQueue</code>出队操作时<ul><li>先判断队列是否为空（使用isEmpty方法）</li><li>将头指针后移<code>++front</code>，再出队列</li></ul></li><li><code>headQueue</code>查看队首元素，不能将使用<code>front+1</code>，不能移动front</li></ol><blockquote><p>最后注意一下可能会抛出异常的方法在调用时，要用trycatch包围。</p></blockquote><h3 id="代码实现">代码实现</h3><p><code>ArrayQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.ArrayQueueDemo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MAXSIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队首的前一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//指向队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.MAXSIZE = size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == MAXSIZE - <span class="number">1</span>;<span class="comment">//是队列尾到达MAXSIZE-1,才说明满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++rear] = data;</span><br><span class="line">        System.out.printf(<span class="string">&quot;元素%d已入队\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[++front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但其实这个方法不应该有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front + <span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ArrayQueueDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.ArrayQueueDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(enQueue)入队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d(deQueue)出队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(showQueue)展示队列：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(headQueue)展示队列头部：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入你要入队的元素：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.enQueue(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;元素%d已出队\n&quot;</span>, arrayQueue.deQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列中已有元素为:&quot;</span>);</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队首元素为%d\n&quot;</span>, arrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述代码基本实现了一个队列，但是存在问题：数组只能使用一次，不能复用！</p></blockquote><h2 id="数组模拟环形-循环队列实现">数组模拟环形/循环队列实现</h2><h3 id="思路分析-2">思路分析</h3><p>需充分利用数组空间，则可用<strong>取模</strong>来实现</p><ol><li>规定front为<strong>队首元素</strong>，初始值为0</li><li>规定rear为<strong>队尾的后一个元素</strong>，初始值为0</li><li>采取空余一个空间的方式，当<code>(rear+1)%MAXSIZE == front</code>时，说明队列已满。</li><li>当<code>fornt == rear</code>时，说明队列为空。</li><li><code>enQueue</code>入队列操作<ul><li>先判断队列是否已满<code>isFull</code></li><li>再插入元素：<code>arr[rear] = data</code>，更新rear：<code>rear = (rear+1)%MAXSIZE</code></li></ul></li><li><code>deQueue</code>出队列操作<ul><li>先判断队列是否为空<code>isEmpty</code></li><li>在出队列：<code>return arr[front]</code>，更新front：<code>front = (front+1)%MAXSIZE</code></li></ul></li><li>故，队列中有效数据的个数为：<code>(rear+MAXSIZE-front)%MAXSIZE</code>，不妨增加一个判断有效数据个数的方法</li></ol><blockquote><p>预留一个空间的目的是，方便区分判断队列为空、队列已满的条件。否则，需新增一个变量来辅助判断队列为空还是满。(因为此时rear == front，你不能判断队列是空还是满。)</p></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>CircleArrayQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.CircleArrayQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MAXSIZE;<span class="comment">//本代码实现时，空余的一个空间，所以实际有效数据个数为MAXSIZE-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队首</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//指向队尾的后一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.MAXSIZE = size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % MAXSIZE == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        System.out.printf(<span class="string">&quot;元素%d已入队\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但其实这个方法不应该有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[i % MAXSIZE]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + MAXSIZE - front) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>CircleArrayQueueDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.CircleArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircleArrayQueue</span> <span class="variable">circleArrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(enQueue)入队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d(deQueue)出队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(showQueue)展示队列：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(headQueue)展示队列头部：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入你要入队的元素：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    circleArrayQueue.enQueue(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;元素%d已出队\n&quot;</span>, circleArrayQueue.deQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列中已有元素为:&quot;</span>);</span><br><span class="line">                    circleArrayQueue.showQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队首元素为%d\n&quot;</span>, circleArrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——数组与链表</title>
      <link href="/2025/03/30/algorithm/datastruct/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/03/30/algorithm/datastruct/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>线性表</h1><p>无论是一维数组也好，二维、三维数组也好，本质都是一张表：都是一堆数据元素的排列，只不过二维的每一个元素都是一个一维数组（三维以此类推），那么如何运用好数组呢？也是一门学问——见稀疏数组，就是<strong>数组压缩</strong>的例子之一。</p><p><strong>链表</strong>也是线性表，只不过存储方式是链式的，即在计算机中不是连续存储的。</p><p><strong>队列</strong>和<strong>栈</strong>，都是操作受限的线性表，可以有顺序存储结构和链式存储结构。队列强调<strong>先进先出</strong>，只允许队首元素deQueue、队尾元素enQueue（双向除外）；栈强调<strong>后进先出</strong>，只允许在栈顶push和pop，不允许操作、访问栈底元素（双向除外）。</p><p><strong>哈希表</strong>融<strong>数组+链表</strong> 或 未来的 <strong>数组+二叉树</strong> 于一体，严格意义上应该不能在这个概论里说吧……不过数组+链表的结合还是可以放在这里说，它通过<strong>键值对</strong>的形式存放和<strong>快速查找</strong>某元素，主要体现了查询的迅速。</p><h1>稀疏数组</h1><h2 id="思路分析">思路分析:</h2><p>当一个数组中大部分元素都为0或者为同一个值时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方式是：</p><p>记录数组的<strong>行数</strong>、<strong>列数</strong>、<strong>有多少个不同的值</strong>(或称:<strong>非零值</strong>(仅大部分元素为0的稀疏数组可称))。</p><p>把这些不同值的元素的<strong>行、列、值</strong>三个为一组记录下来。</p><h2 id="代码实现">代码实现</h2><p><code>SparseArray</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.sparseArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个原始的二维数组   11*11</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] chessArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j] != <span class="number">0</span>) sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] spareArray = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    spareArray[k][<span class="number">0</span>] = i;</span><br><span class="line">                    spareArray[k][<span class="number">1</span>] = j;</span><br><span class="line">                    spareArray[k][<span class="number">2</span>] = chessArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; spareArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; spareArray[i].length; j++) &#123;</span><br><span class="line">                System.out.print(spareArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;还原为二维数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[spareArray[<span class="number">0</span>][<span class="number">0</span>]][spareArray[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= spareArray[<span class="number">0</span>][<span class="number">2</span>]; i++) &#123;</span><br><span class="line">            array[spareArray[i][<span class="number">0</span>]][spareArray[i][<span class="number">1</span>]] = spareArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                System.out.print(array[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>链表</h1><h2 id="单向链表">单向链表</h2><h3 id="思路分析-2">思路分析</h3><ol><li>链表是以<strong>节点</strong>的形式<strong>链式存储</strong></li><li>每个节点包含<strong>data域</strong>、<strong>next域</strong></li><li>链表分<strong>带头节点的链表</strong>和<strong>不带头节点的链表</strong></li><li><code>initList</code>初始化一个空的单链表</li><li><code>insertList</code>插入操作有<strong>头插法</strong>和<strong>尾插法</strong>，还可以根据需求在插入时<strong>是否按照顺序</strong>进行插入<ul><li>先给新节点连接好他的尾部<code>newNode.setNext(head.getNext())</code></li><li>再把新节点插入<code>head.setNext(newNode)</code></li></ul></li><li><code>deleteList</code>删除操作，要注意判断能否删，可选择传入参数，来对删除元素作限制（例如根据index删、根据data域来删）</li><li><code>traveseList</code>遍历操作，<code>while(p!=null)</code>作为条件，<code>p=p-&gt;next;</code>作为迭代条件实现遍历操作。</li><li><code>reverseList</code><a href="####%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC">单链表的反转-面试题</a>，使用<code>p,next,prev</code>三个指针可实现反转操作。关键步骤为：<ul><li>初始化<code>p=head</code>或者<code>p=head-&gt;next(带头节点写法)</code>，总之p为第一个有值的节点；<code>prev=NULL</code>；</li><li>循环条件<code>while(p!=NULL)</code><ul><li>保存下一个节点位置信息<code>next=p-&gt;next</code></li><li>反转当前节点指向<code>p-&gt;next=prev</code></li><li>将前一节点更新，为下次反转做准备<code>prev=p</code>。并且更新<code>p=next</code>否则死循环。</li></ul></li><li>退出循环时，将头节点位置更新<code>head=prev</code>或者<code>head-&gt;next=prev(带头节点的写法)</code></li></ul></li></ol><h3 id="代码实现-2">代码实现</h3><p><code>SingleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.linkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//带头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，在使用SingleLinkedList类前，必须执行init操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示头插法</span></span><br><span class="line"><span class="comment">     * 注意头插法和尾插法的唯一区别是，执行遍历打印操作时，元素顺序会不同</span></span><br><span class="line"><span class="comment">     * 实际开发中，传入参数为Node类型更加合理(因为以后这个Node中的data域可能会存放很多数据！)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode 要往链表中新增的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(Node newNode)</span> &#123;</span><br><span class="line">        newNode.setNext(head.getNext());</span><br><span class="line">        head.setNext(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, p.getData());</span><br><span class="line">            p = p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认删除最后插入的那个元素（作为演示）</span></span><br><span class="line">        <span class="keyword">if</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> p.getNext();</span><br><span class="line">            p.setNext(prev);</span><br><span class="line">            prev = p;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.setNext(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.getNext() == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示：以后可以考虑重写toString()方法，以便了解节点内数据。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 虽然本次演示不涉及到toString方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data=&quot;</span> + data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleLinkedListDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.linkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">operate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    0：退出程序</span></span><br><span class="line"><span class="string">                    1：initList初始化链表操作</span></span><br><span class="line"><span class="string">                    2：traverseList遍历并打印链表操作</span></span><br><span class="line"><span class="string">                    3：insertList插入链表新节点</span></span><br><span class="line"><span class="string">                    4：deleteList删除节点</span></span><br><span class="line"><span class="string">                    5：reverseList反转链表</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter your choice: &quot;</span>);</span><br><span class="line">            operate = scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;链表初始化&quot;</span>);</span><br><span class="line">                    list.initList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;链表元素为:&quot;</span>);</span><br><span class="line">                        list.traverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;建立节点(先输入data):&quot;</span>);</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(scanner.nextInt());</span><br><span class="line">                        list.insertList(newNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除节点:&quot;</span>);</span><br><span class="line">                        list.deleteList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;反转链表:&quot;</span>);</span><br><span class="line">                        list.reverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双向链表">双向链表</h2><h3 id="思路分析-3">思路分析</h3><p>对比单向链表：</p><ol><li>查找更自由，可以从头或尾找起</li><li>删除更自由，可以实现<strong>自我删除</strong>，而单链表必须是找到待删除节点的前一个节点。</li><li>双向链表的节点中除了data域、next域，还有prev域</li><li><code>traverseList</code>遍历操作与单向链表一致，只是更加自由（可以额外接受参数，实现从前OR后查找）</li><li><code>insertList</code>无非是新增了prev域，但是具体实现还是要仔细！</li><li><code>deleteList</code>无非是新涉及了prev域的操作，并且删除时可以自我删除。</li></ol><blockquote><p>总体来说双向链表的实现很简单，在单向的基础上多考虑一个prev域就行。</p></blockquote><h3 id="代码实现-3">代码实现</h3><p><code>DoubleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.doubleLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义为首个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到最后面（可以进一步修改为添加到第k个位置）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode 新节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(Node newNode)</span> &#123;</span><br><span class="line">        newNode.setNext(tail.getNext());</span><br><span class="line">        newNode.setPrev(tail);</span><br><span class="line">        tail.setNext(newNode);</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, p.getData());</span><br><span class="line">            p = p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头开始删除元素（此处可以进一步改为删除第k个元素）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">            head.getNext().setPrev(<span class="literal">null</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;<span class="comment">//因为此时规定head是首个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="keyword">private</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getPrev</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrev</span><span class="params">(Node prev)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoubleLinkedListDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.doubleLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">operate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    0：退出程序</span></span><br><span class="line"><span class="string">                    1：initList初始化链表操作</span></span><br><span class="line"><span class="string">                    2：traverseList遍历并打印链表操作</span></span><br><span class="line"><span class="string">                    3：insertList插入链表新节点</span></span><br><span class="line"><span class="string">                    4：deleteList删除节点</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter your choice: &quot;</span>);</span><br><span class="line">            operate = scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;链表初始化&quot;</span>);</span><br><span class="line">                    list.initList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;链表元素为:&quot;</span>);</span><br><span class="line">                        list.traverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;建立节点(先输入data):&quot;</span>);</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(scanner.nextInt());</span><br><span class="line">                        list.insertList(newNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除节点:&quot;</span>);</span><br><span class="line">                        list.deleteList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单向环形-循环链表">单向环形/循环链表</h2><h3 id="思路分析-4">思路分析</h3><blockquote><p>有助于解决<strong>约瑟夫问题</strong></p></blockquote><p>构建一个单向环形链表的思路：</p><ol><li>先创建第一个节点，让first指向该节点，并形成环形。</li><li>后面每创建一个新的节点，就加入到已有的环形链表（画图理解）</li><li><code>traverseList</code>当<code>p.getNext() == first</code>说明已完成遍历</li></ol><h3 id="代码实现-4">代码实现</h3><blockquote><p>这里的单向环形链表的部分方法(<code>deleteList</code>操作)是针对于<strong>约瑟夫问题</strong>特化的</p></blockquote><p><code>JosephuSolved</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.singleCircleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JosephuSolved</span> &#123;</span><br><span class="line">    <span class="comment">//Josephu:有5个人，编号从1-5，从第一个人开始报数，每次报到3的人出圈，直到所有人出圈</span></span><br><span class="line">    <span class="comment">//按照出圈顺序打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleCircleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleCircleLinkedList</span>();</span><br><span class="line">        list.initList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            list.insertList(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.traverseList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在约瑟夫问题中，出去一个后，从下一个接着开始报数</span></span><br><span class="line">        <span class="comment">//也就意味着要修改数据结构中的first、last以适应该问题</span></span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>,list.deleteList(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SingleCircleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.singleCircleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleCircleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span>&#123;</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            first = <span class="keyword">new</span> <span class="title class_">Node</span>(data,first);<span class="comment">//自己与自己构成环形</span></span><br><span class="line">            last = first;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data,first);</span><br><span class="line">        last.setNext(newNode);</span><br><span class="line">        last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从p节点开始，删除第index个节点，但是针对JosePose问题做了特化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引(大于等于1！)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回被删除节点的编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteList</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> last;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">if</span>(first.getNext() == first)&#123;</span><br><span class="line">            first = <span class="literal">null</span>;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> p.getNum();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p=p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        prev.setNext(p.getNext());</span><br><span class="line">        last = prev;</span><br><span class="line">        first = p.getNext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.getNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>,p.getNum());</span><br><span class="line">            p=p.getNext();</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=first);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> num,Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表题目">链表题目</h2><h3 id="查找单链表的倒数第k个节点">查找单链表的倒数第k个节点</h3><ol><li>编写一个方法，接收head节点，同时接收一个index</li><li>index表示倒数第index个节点</li><li>若<code>index&lt;0</code>或者<code>index&gt;length</code>，则查找不到。</li><li>如果在设计单链表时，携带length属性（insert时++、delete时–、有get方法），直接获取总长度，遍历后即可到达第<code>length-index+1</code>个节点，即到时第k个节点。若没有length，则需要先遍历一遍获得<strong>单链表</strong>总长度。(毕竟是单链表，只能从前往后遍历，所以需要预先知道总长才能查询到倒数第k个)</li></ol><h3 id="单链表的反转">单链表的反转</h3><p>见单向链表的<a href="###%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">思路分析</a>部分<code>reverseList</code>。</p><h3 id="从尾到头打印单链表">从尾到头打印单链表</h3><ol><li>方式一：先reverse，再打印，但是破坏了原来的结构（不推荐）</li><li>方式二：把节点压入栈中，利用栈后进先出的的特点，实现逆序打印</li></ol><h3 id="合并两个有序的单链表，合并后仍保持有序">合并两个有序的单链表，合并后仍保持有序</h3><ol><li>两个单链表都还没遍历完，就比大小后再插入</li><li>有一个为空了，剩下的那个直接接入到最后即可</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2025/03/22/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/03/22/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2025/03/22/Java/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/03/22/Java/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2025/03/08/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/08/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>数据结构</h1><blockquote><p>前言：数据结构，好比是一类基本工具，每一类数据结构被抽象出来，必定有其用途。用好数据结构，就相当于用好了这类基本工具。——工欲善其事必先利其器。</p></blockquote><ul><li>TODO:数学渲染有问题……后续改一下</li></ul><h1>算法</h1><h2 id="排序算法-概论">排序算法-概论</h2><h3 id="分类">分类</h3><p>分为<strong>内部排序</strong>和<strong>外部排序</strong>，</p><ol><li>内部排序，是指将要处理的数据都加载到内部存储器（内存）完成排序</li><li>外部排序，当数据量过大，无法全部加载到内存中时，需要借助外部存储进行排序</li></ol><img src="https://blogs.muxueavid.top/blogs/2025/05/20250501180644727.png" alt="image-20241030211412362" style="zoom:67%;" /><h3 id="算法对比">算法对比</h3><table><thead><tr><th><strong>排序算法</strong></th><th><strong>平均时间复杂度</strong></th><th><strong>最好情况</strong></th><th><strong>最坏情况</strong></th><th><strong>空间复杂度</strong></th><th><strong>排序方式</strong></th><th><strong>稳定性</strong></th></tr></thead><tbody><tr><td><strong>冒泡排序</strong></td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td><strong>选择排序</strong></td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>插入排序</strong></td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td><strong>希尔排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log^2 n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>归并排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>快速排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>堆排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>计数排序</strong></td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>桶排序</strong></td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>基数排序</strong></td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr></tbody></table><p><strong>术语解释</strong>：</p><ol><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序后a仍在b前面</li><li><strong>不稳定</strong>：如果a原本在b前面，而a=b，排序后a有可能在b后面</li><li><strong>内排序</strong>：所有排序操作都在内存中完成</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li><li><strong>时间复杂度</strong>： 一个算法执行所耗费的时间</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小</li><li><strong>n</strong>：数据规模</li><li><strong>k</strong>：计数排序、桶排序等中桶的数量；基数排序中，数字的位数</li><li><strong>In-place</strong>：不占用额外内存</li><li><strong>Out-place</strong>：占用额外内存</li></ol><h3 id="实际测试的性能">实际测试的性能</h3><blockquote><p>不同算法对于不同测试数据大小的排序所用时间</p></blockquote><table><thead><tr><th>数据量</th><th><a href="##1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">冒泡排序</a></th><th><a href="##2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">选择排序</a></th><th><a href="##3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">插入排序</a></th><th><a href="##4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">希尔排序</a></th><th><a href="##5%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">快速排序</a></th><th><a href="##6%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">归并排序</a></th><th><a href="##7%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">基数排序</a></th><th><a href="##8%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">堆排序</a></th></tr></thead><tbody><tr><td>10000</td><td>43</td><td>26</td><td>22</td><td>3</td><td>1</td><td>2</td><td>2</td><td>1</td></tr><tr><td>50000</td><td>1845</td><td>592</td><td>431</td><td>6</td><td>6</td><td>7</td><td>3</td><td>5</td></tr><tr><td>80000</td><td>5250</td><td>1470</td><td>1074</td><td>12</td><td>9</td><td>18</td><td>10</td><td>8</td></tr><tr><td>140000</td><td>18690</td><td>4337</td><td>3214</td><td>17</td><td>12</td><td>22</td><td>14</td><td>13</td></tr><tr><td>500000</td><td></td><td></td><td></td><td>52</td><td>37</td><td>57</td><td>35</td><td>46</td></tr><tr><td>900000</td><td></td><td></td><td></td><td>104</td><td>64</td><td>93</td><td>35</td><td>83</td></tr></tbody></table><h2 id="查找算法-概论">查找算法-概论</h2><h3 id="分类-2">分类</h3><ol><li>顺序(线性)查找</li><li>二分查找/折半查找</li><li>插值查找</li><li>斐波那契查找</li></ol><h3 id="简单介绍">简单介绍</h3><ol><li>顺序查找操作的数据可以是无序的（就是遍历……）</li><li>二分查找、插值查找、斐波那契查找要求在一个<strong>有序数组</strong>中</li></ol><h2 id="中缀表达式">中缀表达式</h2><p>中缀表达式，就是我们常见的表达式，如$(3+4) \times 5-6$，但是对于计算机来说操作较为复杂。</p><p>因此，在计算结果时，一般需要转换为其他表达式来计算（一般是后缀表达式）</p><h2 id="前缀表达式">前缀表达式</h2><p>前缀表达式，又称<strong>波兰式</strong>。前缀表达式的运算符位于操作数之前</p><p>e.g.$(3+4)\times5-6$对应的前缀表达式为$-*+3456$ （关键在于将原先表达式转换为前缀表达式）</p><ul><li>前缀表达式的求值：<ul><li><strong>从右至左</strong>扫描前缀表达式，遇到数字时，压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们进行运算，并将结果入栈。重复该过程直至表达式最左端。</li><li>e.g.$-*+3456$</li><li>将6、5、4、3压入堆栈（<code>numStack=[6,5,4,3]</code>）</li><li>遇到+，弹出3、4，运算$3+4=7$，将7入栈。（<code>numStack=[6,5,7]</code>）</li><li>遇到*，弹出7、5，运算$7 \times 5=35$，将35入栈（<code>numStack=[6,35]</code>）</li><li>遇到-，弹出35、6，运算$35-6=29$，将29入栈（<code>numStack=[29]</code>）</li></ul></li></ul><h2 id="后缀表达式">后缀表达式</h2><p>后缀表达式，又称<strong>逆波兰表达式</strong>，与前缀表达式类似，只是运算符放在操作数之后。</p><ul><li><p>例如$(3+4)\times 5 -6$的后缀式为：$3 \quad 4 + 5 \times 6 - $</p></li><li><p>$a+b$为$a \quad b +$</p></li><li><p>$a+(b-c)$为$a \quad b \quad c - +$</p></li><li><p>$a+(b-c)\times d$为$a \quad b \quad c - d \times +$</p></li><li><p>$a+d \times (b-c)$为$a \quad d \quad b \quad c - \times +$</p></li><li><p>$a=1+3$为$a \quad 1 \quad 3 +=$</p></li></ul><p>后缀表达式的求值：</p><p><strong>从左至右</strong>表达式，遇到数字时，压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们进行运算，并将结果入栈。重复该过程直至表达式最右端。(演示过程和前缀表达式一致)</p><blockquote><p>关键在于如何将中缀表达式转换为后缀表达式</p></blockquote><h2 id="递归">递归</h2><h3 id="递归介绍">递归介绍</h3><p>简单来说，递归就是<strong>自己调用自己</strong>，每次调用时<strong>传入不同的变量</strong>。</p><p>递归调用机制：</p><ol><li>当程序每次调用一个方法时，就会开辟一个独立的空间（栈）</li><li>每个空间的数据（局部变量），都是独立的</li></ol><p>递归能解决的问题：</p><ol><li>数学类：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题</li><li>算法中：快排、归并排序、二分查找、分治算法</li><li>将用栈解决的问题-&gt;使用递归，代码简洁</li></ol><h3 id="递归需遵守的规则">递归需遵守的规则</h3><ol><li>执行一个方法，就创建一个独立空间</li><li>局部变量独立</li><li>引用类型变量是共享的（例如数组）</li><li>递归必须设计<strong>递归出口</strong>，<strong>必须向退出递归的条件逼近</strong></li><li>当一个方法执行完毕，谁调用，谁接收返回结果，并且继续执行调用者后面的代码</li></ol><h2 id="分治">分治</h2><blockquote><p>先见<a href="https://blog.csdn.net/daaikuaichuan/article/details/80765604?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%88%86%E6%B2%BB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-80765604.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">博客1</a>与<a href="https://www.cnblogs.com/leishitou/p/5436201.html">博客2</a>的解释</p></blockquote><ol><li>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</li><li>分治算法可以求解的一些经典问题<ol><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ol></li></ol><p><strong>分治算法的基本步骤</strong></p><p>分治法在每一层递归上都有三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解。</li></ol><p><strong>分治(Divide-and-Conquer(P))算法设计模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> |P|≤n0</span><br><span class="line">   then <span class="title function_">return</span><span class="params">(ADHOC(P)</span>)</span><br><span class="line"><span class="comment">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span><br><span class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</span><br><span class="line"><span class="keyword">do</span> yi ← Divide-and-Conquer(Pi)   递归解决Pi</span><br><span class="line">T ← MERGE(y1,y2,…,yk)   合并子问题</span><br><span class="line"><span class="keyword">return</span>(T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中$|P|$表示问题P的规模；$n_0$为一阈值，表示当问题P的规模不超过$n_0$时，问题已容易直接解出，不必再继续分解。<code>ADHOC(P)</code>是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过$n_0$时直接用算法<code>ADHOC(P)</code>求解。算法<code>MERGE(y1,y2,…,yk)</code>是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h2 id="基数排序处理负数">基数排序处理负数</h2><h3 id="偏移法">偏移法</h3><h4 id="介绍">介绍</h4><ol><li><strong>找出最小值</strong>：首先遍历数组，找出最小值。</li><li><strong>偏移所有数</strong>：将数组中的所有元素都加上一个正数，使得数组中的所有元素都变为非负数。这个正数可以是绝对值最小值加一。例如，如果最小值是 -10，可以将所有元素加 11，使得最小值变为 1。</li><li><strong>进行基数排序</strong>：对偏移后的数组进行基数排序。</li><li><strong>恢复原值</strong>：排序完成后，再将每个元素减去之前加的正数，恢复到原始值。</li></ol><h4 id="代码实现">代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">            min = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> Math.abs(min);</span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>] + offset; <span class="comment">// 加上偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] += offset; <span class="comment">// 偏移</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 放入桶中的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">            bucketCounts[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从桶中取出的过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] -= offset; <span class="comment">// 恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释">解释</h4><ol><li><strong>偏移处理</strong>：在进行排序前，将所有数加上偏移量（绝对值最小值），确保数组中所有元素为非负数。</li><li><strong>基数排序</strong>：对偏移后的数组进行基数排序。</li><li><strong>恢复值</strong>：排序完成后，减去偏移量以恢复到原始值。</li></ol><p>这种方法较为简单，且在排序完成后，时间复杂度仍然保持在 $(O(d \cdot (n + k)))$，其中 d 是数字的位数，n 是元素个数，k 是基数的大小。</p><h3 id="分开处理">分开处理</h3><h4 id="介绍-2">介绍</h4><ol><li><strong>分为正负数组</strong>：创建两个数组，分别存放正数和负数。</li><li><strong>对正数进行基数排序</strong>：对正数数组进行基数排序。</li><li><strong>对负数进行基数排序</strong>：对负数数组的绝对值进行基数排序，然后将结果反转。</li><li><strong>合并结果</strong>：将负数数组（排序后）和正数数组（排序后）合并。</li></ol><h4 id="代码实现-2">代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>, -<span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, -<span class="number">214</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 分为正负数组</span></span><br><span class="line">        <span class="type">int</span>[] positive = Arrays.stream(arr).filter(x -&gt; x &gt;= <span class="number">0</span>).toArray();</span><br><span class="line">        <span class="type">int</span>[] negative = Arrays.stream(arr).filter(x -&gt; x &lt; <span class="number">0</span>).map(Math::abs).toArray(); <span class="comment">// 取绝对值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对正数进行基数排序</span></span><br><span class="line">        <span class="keyword">if</span> (positive.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            radixSortPositive(positive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对负数进行基数排序</span></span><br><span class="line">        <span class="keyword">if</span> (negative.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            radixSortPositive(negative);</span><br><span class="line">            <span class="comment">// 反转负数排序后的结果</span></span><br><span class="line">            reverseArray(negative);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先填充负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : negative) &#123;</span><br><span class="line">            arr[index++] = -num; <span class="comment">// 恢复负号</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后填充正数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : positive) &#123;</span><br><span class="line">            arr[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSortPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 放入桶中的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">                bucketCounts[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从桶中取出的过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                        arr[index++] = buckets[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">200000</span>) - <span class="number">100000</span>; <span class="comment">// 生成范围为 -100000 到 100000 的随机数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        radixSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-2">解释</h4><ol><li><p><strong>分开处理</strong>：</p><ul><li>使用 <code>Arrays.stream</code> 分别创建正数数组 <code>positive</code> 和负数数组 <code>negative</code>（取绝对值）。</li></ul></li><li><p><strong>基数排序</strong>：</p><ul><li>对正数数组调用 <code>radixSortPositive</code> 方法进行排序。</li><li>对负数数组同样调用 <code>radixSortPositive</code>，但处理时将元素取绝对值。</li></ul></li><li><p><strong>反转负数数组</strong>：</p><ul><li>对负数排序后的结果进行反转，以确保负数按正确顺序排列。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>先将负数（带负号）放入最终数组，再将正数放入，得到完整的排序结果。</li></ul></li></ol><h3 id="两者比较、总结">两者比较、总结</h3><h4 id="偏移法-2">偏移法</h4><ul><li><p><strong>优点</strong>：</p><ul><li>实现相对简单，不需要额外的空间来存储正数和负数数组。</li><li>对于负数和正数的排序都是在同一个数组中进行的，合并结果的步骤被省略。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>需要对整个数组进行遍历以找出最小值并计算偏移量，这在数据量很大时会增加时间开销。</li><li>需要额外的空间用于桶（假设桶大小为常数，空间复杂度为 $O(n)$），但实际上，空间利用率可能受到偏移量影响。</li></ul></li></ul><h4 id="分开处理法">分开处理法</h4><ul><li><p><strong>优点</strong>：</p><ul><li>明确分开了负数和正数的排序，逻辑更清晰。</li><li>在处理负数时，直接对绝对值排序，可以有效避免负数带来的问题。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>需要额外的数组来存储正数和负数，空间复杂度更高（需要 $O(n)$ 的额外空间）。</li><li>合并结果时需要再次遍历数组，增加了额外的时间开销。</li></ul></li></ul><h4 id="性能比较">性能比较</h4><ul><li><strong>时间复杂度</strong>：两种方法的时间复杂度均为 $O(d \cdot (n + k))$，其中 $d$ 是数字的位数，$n$ 是元素个数，$k$ 是基数的大小。因此，从理论上讲，时间复杂度相同。</li><li><strong>实际性能</strong>：<ul><li>对于大多数情况，偏移法在空间上更高效，适合数据范围较小的情况。</li><li>分开处理法在逻辑上更易于理解，且能更好地处理极端情况（例如全是负数或全是正数）。</li></ul></li></ul><h4 id="结论">结论</h4><p>在性能上，两种方法在大多数情况下相似，但具体的选择可以根据实际需求和数据特性来决定。</p><p>如果需要处理的数组范围较大且包含负数，分开处理法可能会更加灵活；如果希望简化实现，偏移法是一个不错的选择。</p><h2 id="斐波那契查找的意义何在">斐波那契查找的意义何在?</h2><p>这个问题，我浅浅看了几篇文章，但都没有满意的答案。</p><p>可能的原因千奇百怪：</p><ol><li>斐波那契查找在计算<code>mid</code>值时，只使用了加减法——<code>mid = low + f[k-1] - 1</code>，而二分查找使用了除法，除法是极耗费时间的。但是吧，也没那么耗时间，很多编辑器都优化成&gt;&gt;1了，也没比加减法慢。</li><li>斐波那契查找将mid点设置在0.618处，如果所以元素落在$[low,mid-1]$区间的概率较大，判断一次的可能更高；而二分查找两个区间长度都为一半，所以仅需判断一次的概率相比更小。貌似很有道理，但是为什么是0.618？我没看到一篇文章有过详细的数学证明……所以还是觉得这两者查找效率半斤八两。</li></ol><h2 id="自用の界面菜单">自用の界面菜单</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="前缀编码">前缀编码</h2><p>简单理解：10010110100是编码结果，但是在解读时，a编码为1，b编码为10，那么在解读这个编码时，开头的1究竟是1？还是说10是b？</p><p>如果在一个编码方案中，任何一个编码都不是其他任何编码的前缀（最左子串），则称该编码是前缀编码。</p><p>补充资料：<a href="https://blog.csdn.net/qq_30787727/article/details/112210023">blog1</a>、<a href="https://blog.csdn.net/ak201605050122/article/details/100169591">blog2</a>。</p><h2 id="动态规划">动态规划</h2><p><strong>动态规划介绍</strong>：</p><ol><li><strong>动态规划(Dynamic Programming)<strong>算法的核心思想是：将</strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong>。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过<strong>填表</strong>的方式来逐步推进，得到最优解</li></ol><h2 id="贪心算法">贪心算法</h2><p><strong>贪心算法介绍</strong>：</p><ol><li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</li><li>贪婪算法所得到的结果<strong>不一定是最优的结果(有时候会是最优解)</strong>，但是都是相对近似(接近)最优解的结果</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/03/08/other/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/08/other/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>测试测试测试-3</p><blockquote><p>标题写法：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure><h1>一级标题</h1><h2 id="二级标题">二级标题</h2><blockquote><p>注释内容</p></blockquote><p>注释写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面是注释</span><br><span class="line"><span class="quote">&gt; 注释内容</span></span><br><span class="line">ps：&#x27;&gt;&#x27;+空格</span><br></pre></td></tr></table></figure><h1>代码</h1><blockquote><p>代码块</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="code">```[语言类型]+Enter</span></span><br><span class="line"><span class="code">写代码语言</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>着重号</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="code">`被着重号包围的内容`</span></span><br></pre></td></tr></table></figure><p><code>被着重号包围的内容</code></p><blockquote><p>内联HTML代码:<br><img src="https://blogs.muxueavid.top/blogs/2025/04/20250429230431735.png" alt=""></p></blockquote><div style="text-align:center">    <font style="color:red">目前已能看懂HTML</font></div><center>简单的文字居中</center><h1>列表</h1><blockquote><p>无序列表，使用<code>-</code>或<code>*</code>或<code>+</code>都可以</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 一个雪乃</span><br><span class="line"><span class="bullet">-</span> 两个雪乃</span><br><span class="line"><span class="bullet">  -</span> (再按个Tab)-&gt;变成子集</span><br><span class="line"><span class="bullet">    -</span> 子子集</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 雪乃我爱你</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 我爱你雪乃！</span><br></pre></td></tr></table></figure><ul><li>一个雪乃</li><li>两个雪乃<ul><li>(再按个Tab)-&gt;变成子集<ul><li>子子集</li></ul></li></ul></li></ul><ul><li>雪乃我爱你</li></ul><ul><li>我爱你雪乃！</li></ul><blockquote><p>有序列表，<code>数字.空格 内容</code></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象塞进去</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure><p>如何把大象放进冰箱？(数字.空格)</p><ol><li>打开冰箱</li><li>把大象塞进去</li><li>关上冰箱</li></ol><blockquote><p>任务列表，<code>- [ ] 内容</code></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 敲代码</span><br><span class="line"><span class="bullet">-</span> [x] 雪乃爱我</span><br><span class="line"><span class="bullet">-</span> [x] 我爱雪乃</span><br></pre></td></tr></table></figure><ul><li>[ ] 敲代码</li><li>[x] 雪乃爱我</li><li>[x] 我爱雪乃</li></ul><h1>文字</h1><blockquote><p>一般文字样式</p></blockquote><p><code>*斜体*</code>，<em>斜体</em>（Ctrl+I）</p><p><code>**加粗**</code>，<strong>加粗</strong>（Ctrl+B）</p><p><code>***斜体加加粗***</code>，<em><strong>斜体加加粗</strong></em>（先Ctrl+I再Ctrl+B）</p><p><code>~~删除线~~</code>，<s>删除线</s></p><p><code>&lt;u&gt;下划线&lt;/u&gt;</code>，<u>下划线</u>（Ctrl+U）</p><blockquote><p>特殊化文字(Emoji可能不支持)</p></blockquote><p>Emoji表情 :smile: :sweat_smile: :drooling_face:<br>:clown_face:<br><a href="https://emojipedia.org/apple/">Emoji表情大全</a></p><blockquote><p>表格</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|姓名|年龄|国文成绩|数学成绩|</span><br><span class="line">|:---|---:|:---:|:---|</span><br><span class="line">|比企谷八幡|19|98|100|</span><br><span class="line">|雪之下雪乃|19|100|100|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:right">年龄</th><th style="text-align:center">国文成绩</th><th style="text-align:left">数学成绩</th></tr></thead><tbody><tr><td style="text-align:left">比企谷八幡</td><td style="text-align:right">19</td><td style="text-align:center">98</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">雪之下雪乃</td><td style="text-align:right">19</td><td style="text-align:center">100</td><td style="text-align:left">100</td></tr></tbody></table><blockquote><p>分割线</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">+++</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">ps：并不一定支持所有的分割线语法</span></span><br></pre></td></tr></table></figure><hr><hr><h1>数学公式</h1><ul><li><p>行间数学公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\lambda</span> l&#125;&#123;4 <span class="keyword">\pi</span> <span class="keyword">\varepsilon</span><span class="built_in">_</span>0 d&#125; <span class="keyword">\frac</span>&#123;l&#125;&#123;(d<span class="built_in">^</span>2+<span class="keyword">\frac</span>&#123;l<span class="built_in">^</span>2&#125;&#123;4&#125;)<span class="built_in">^</span><span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li></ul><p>$$<br>\frac{\lambda l}{4 \pi \varepsilon_0 d} \frac{l}{(d^2+\frac{l^2}{4})^\frac{1}{2}}<br>$$</p><ul><li><p>行内数学公式：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内公式展示——$x \div y$</span><br></pre></td></tr></table></figure></li></ul><p>行内公式展示——$x \div y$</p><h1>HTML</h1><blockquote><p>ps：理论上完全可以，不过不建议用html写Markdown。</p></blockquote><h1>扩展语法</h1><blockquote><p><em>可能不适用其它地方</em></p></blockquote><ol><li><p>下标H~2~O</p></li><li><p>上标x^2^</p></li><li><p>==这是一段高亮文字==</p></li><li><p>注释<a href="%E6%B3%A8%E9%87%8A%E5%93%9F">^1</a> YukinoshitaYukino<a href="%E9%9B%AA%E4%B9%8B%E4%B8%8B%E9%9B%AA%E4%B9%83%E7%9A%84%E7%BD%97%E9%A9%AC%E5%90%8D">^雪之下雪乃</a>Avidity<a href="%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E8%80%81%E5%B8%88%EF%BC%81%E5%A4%A7%E8%80%81%E5%B8%88%E5%B0%B1%E6%98%AF%E6%88%91%EF%BC%81">^比企谷八幡</a></p></li><li><p>数学公式:</p></li></ol><p>$$<br>\frac{partial f}{\partial x}=2\sqrt{a}x<br>$$</p><p>行内数学公式:$2\sqrt{a}x$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
