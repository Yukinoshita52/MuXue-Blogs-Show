<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM学习笔记--初版大杂烩</title>
      <link href="/2025/05/16/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2025/05/16/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<h1>JVM运行的整体流程</h1><blockquote><p>笔记：依据<a href="https://www.bilibili.com/video/BV1PJ411n7xZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d">视频教程</a>学习后，纯看配图，使用的个人语言的书写（有水印的配图进行了自己绘制）</p><p>目前版本：1.0</p></blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516201106780.jpg" style="zoom:67%;" /><p>宏观来看，JVM的不同操作系统的实现，使得Java经过一次编译后的.class字节码文件，能够在不同的平台上运行</p><p>印证了流程很广泛的一句话——“一次编译，处处运行”</p><p>其实不仅仅是Java语言，其他的语言，只要仅编译器编译后符合JVM所定义的字节码文件的格式规范，就能在Java虚拟机上运行：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516201832202.jpg" style="zoom:67%;" /><p><strong>JVM的作用</strong></p><p>Java虚拟机就是二进制字节码文件的<strong>运行时环境</strong>，负责装载字节码到其内部，解释or编译为对应操作系统平台的机器指令执行。</p><p><strong>JVM架构图</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516202357582.jpg" style="zoom: 67%;" /><p>注：此图非常重要，要非常熟悉。</p><p>上图较为简易的描述了JVM的工作流程：</p><ol><li>从一个class字节码文件开始</li><li>首先经过类加载子系统的加载</li><li>然后把加载后的信息保存进入运行时数据区</li><li>运行时数据区的内存结构划分为不同的结构——方法区用于存放类的方法信息；堆中主要用于保存对象、字符串常量等信息；程序计数器仅用于保存程序要执行的下一条指令信息；本地方法栈中保存的是一些Java的核心类库的实现（一般用C/C++实现）；虚拟机栈中是一个个栈帧，栈帧保存了当前执行方法的所需信息（比如使用到的对象的引用、基本数据类型的值、String的引用）。</li><li>执行引擎负责具体的执行过程；本地方法接口从本地方法库加载方法的实现、然后被本地方法栈调用。</li></ol><blockquote><p>ps：描述不一定准确</p></blockquote><p>更加详细的架构图如下，可供复习使用：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516205131610.jpg" style="zoom: 67%;" /><p><strong>JVM架构模型</strong></p><p>JVM是<strong>基于栈的架构模型</strong>，不妨与另一种（<strong>基于寄存器的架构模型</strong>）进行对比，来说明其特点。</p><p>栈这种结构，联系数据结构与算法所学的知识，无非“进栈”、“出栈”、“后进先出”等特点</p><p>那么基于这些特点，其每一条指令就非常小，因为无需指定指令所对应的位置（因为对栈的操作就是在栈顶）；而基于寄存器的，每一条指令就显得长一些，因为它不光要指出指令的具体操作，还要明确操作的位置。举个简单例子：</p><p>同样执行2+3，基于栈架构所用指令（JVM为例）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>基于寄存器架构（80x86汇编语言举例）举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">2</span> <span class="comment">//将ax寄存器的值设为1</span></span><br><span class="line">add ax,<span class="number">3</span> <span class="comment">//使ax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p>可见，基于栈架构的所用指令数量会更多，即使其每一条指令很简单</p><p>那么JVM为什么要采用栈的架构呢？总结如下：</p><ol><li>基于栈架构，<strong>跨平台性更好</strong>。因为不同平台CPU架构不同，所以不能用基于寄存器架构的</li><li>虽然经过汇编后，相比于寄存器架构方式指令更多、运行效率更低，但是考虑到跨平台性和可移植性，JVM选择了栈架构的设计</li></ol><h1>类加载子系统（Class Loader SubSystem）</h1><h2 id="总括：Class-Loader-SubSystem的作用">总括：Class Loader SubSystem的作用</h2><p>类加载子系统只负责将class文件中的类的信息加载到JVM中，<strong>加载的类信息存放于一块称为方法区的内存空间</strong>，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p>它起了一个<strong>创造模板</strong>的作用，详细些：class文件中存储了一些类的模板信息（比如定义了哪些字段、有哪些方法、实现了哪些接口、父类是谁等），然后类加载子系统把这些模板的信息读取进来（到JVM中）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516211557952.png" style="zoom:67%;" /><p>这些“模板信息”存放于方法区中（JDK8前叫做永久代，在堆中；JDK8后改为云空间，在系统内存中）</p><h2 id="类加载过程">类加载过程</h2><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250516213120744.png" style="zoom:67%;" /><h3 id="1-加载（Loading）">1 加载（Loading）</h3><blockquote><p>非自己语言</p></blockquote><p><strong>加载：</strong></p><ol><li><p>通过一个类的<strong>全限定名</strong>获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="2-链接（Linking）">2 链接（Linking）</h3><blockquote><p>非自己语言</p></blockquote><p>分为三个子阶段：验证、准备、解析</p><h4 id="2-1-验证（Verification）">2.1 验证（Verification）</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求（e.g.开头的：<strong>CAFEBABE</strong>），保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><h4 id="2-2-准备（Preparation）">2.2 准备（Preparation）</h4><ol><li>为<strong>类变量</strong>（<strong>static变量</strong>）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-解析（Resolution）">2.3 解析（Resolution）</h4><ol><li><p><strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p><strong>符号引用</strong>就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><h3 id="3-初始化（Initialization）">3 初始化（Initialization）</h3><blockquote><p>即<clinit>方法的调用——在此时发生</p></blockquote><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.yukino.User”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h2 id="类加载器分类">类加载器分类</h2><blockquote><p>非自己语言</p></blockquote><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517122036577.png" style="zoom: 80%;" /><h3 id="JDK1-8中源码继承关系图">JDK1.8中源码继承关系图</h3><p><strong>ExtClassLoader</strong>（<strong>Launcher内部类</strong>）——扩展类加载器</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517122512461.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器（也成系统类加载器）</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517122710042.png" alt=""></p><h3 id="JDK1-9及之后的">JDK1.9及之后的</h3><blockquote><p>注意继承于<strong>BuiltinClassLoader</strong>了，不再是<strong>URLClassLoader</strong></p></blockquote><p><strong>PlatformClassLoader（Launcher内部类）</strong>——平台类加载器</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517123421236.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517123544208.png" alt=""></p><h3 id="虚拟机自带的加载器">虚拟机自带的加载器</h3><blockquote><p>非自己语言</p></blockquote><h4 id="启动类加载器">启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器">扩展类加载器</h4><blockquote><p><strong>扩展类加载器（ExtClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器">系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><h3 id="用户自定义类加载器">用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？">什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li><strong>隔离加载类</strong>（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架、中间件之间是隔离的）</li><li><strong>修改类加载的方式</strong></li><li><strong>扩展加载源</strong>（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li><strong>防止源码泄漏</strong>（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？">如何自定义类加载器？</h4><ol><li>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findclass()</code>方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写<code>findclass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="关于ClassLoader">关于ClassLoader</h2><p>ClassLoader是一个抽象类，其后所有的类加载器都继承自ClassLoader（JDK8的启动类加载器除外）</p><p>（JDK9之后的BootClassLoader又间接继承与ClassLoader了）</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517185020815.png" alt=""></p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>defineClass(String name,byte[] b,int off, int len)</td><td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的示例</td></tr><tr><td>resolveClass(Class&lt;?&gt; e)</td><td>连接指定的一个Java类</td></tr></tbody></table><p><strong>获取ClassLoader的途径</strong></p><table><thead><tr><th>获取当前类的ClassLoader</th><th>clazz.getClassLoader()</th></tr></thead><tbody><tr><td><strong>获取当前线程上下文的ClassLoader</strong></td><td>Thread.currentThread().getContextClassLoader()</td></tr><tr><td><strong>获取系统的ClassLoader</strong></td><td>ClassLoader.getSystemClassLoader()</td></tr><tr><td><strong>获取调用者的ClassLoader</strong></td><td>DriverManager.getCallerClassLoader()</td></tr></tbody></table><h2 id="双亲委派机制">双亲委派机制</h2><h3 id="双亲委派机制原理">双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517190508639.png" style="zoom:67%;" /><h3 id="双亲委派机制优势">双亲委派机制优势</h3><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制">沙箱安全机制</h2><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="如何判断两个class对象是否相同？">如何判断两个class对象是否相同？</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li><p><strong>类的全类名一致</strong></p></li><li><p><strong>加载这个类的ClassLoader实例对象一致</strong></p><blockquote><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p></blockquote></li></ol><h2 id="对类加载器的引用">对类加载器的引用</h2><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ol><h1>运行时数据区（Runtime Data Area）</h1><blockquote><p>通过之前的：类的加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，就会使用执行引擎对类进行使用，同时执行引擎还会使用到运行时数据区中的数据</p></blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517193445230.png" style="zoom:80%;" /><h2 id="概述">概述</h2><h3 id="运行时数据区与内存">运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><h3 id="JVM-线程">JVM 线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><p><strong>JVM 系统线程</strong></p><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括&quot;stop-the-world&quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h2 id="程序计数器（PC-Register）">程序计数器（PC Register）</h2><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517201638237.png" style="zoom:67%;" /><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><p><strong>PC寄存器的作用</strong>，一言以蔽之：</p><p>PC寄存器用来存储指向下一条指令的地址。由执行引擎读取下一条指令，并执行该指令。</p><h2 id="本地方法接口-本地方法库">本地方法接口+本地方法库</h2><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517202140204.png" style="zoom: 67%;" /><p>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong></p><p>因此，在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，初衷是融合C/C++程序。</p><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><strong>就是用于调用本地方法接口的</strong></p></blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250517202533710.png" style="zoom: 80%;" /><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><h2 id="虚拟机栈">虚拟机栈</h2><blockquote><p>栈管运行，堆管存储</p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p></blockquote><h3 id="虚拟机栈是什么？">虚拟机栈是什么？</h3><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518114956160.png" style="zoom:67%;" /><ul><li><p>虚拟机栈（VM Stack）。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p></li><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点">虚拟机栈的特点</h3><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518115530548.png" style="zoom:67%;" /><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><h3 id="虚拟机栈的异常">虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h2 id="栈的存储单位">栈的存储单位</h2><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518120415477.png" style="zoom:80%;" /><h3 id="栈中存储什么？">栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理">栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518120603099.png" style="zoom:67%;" /><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构">栈帧的内部结构</h3><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518120634048.png" style="zoom:67%;" /><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><h2 id="局部变量表">局部变量表</h2><h3 id="认识局部变量表">认识局部变量表</h3><h4 id="概念">概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h3 id="关于slot的理解">关于slot的理解</h3><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518121636958.png" style="zoom:67%;" /><blockquote><p>可见除double、long类型占2个slot外，其余类型均占1个slot</p></blockquote><h3 id="slot的重复利用">slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量<strong>过了其作用域</strong>，那么在其作用域之后申明新的局部变量变就很有可能会<strong>复用</strong>过期局部变量的槽位，从而达到节省资源的目的。</p><h3 id="静态变量与局部变量的对比">静态变量与局部变量的对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line">1、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line">2、按照在类中声明的位置分：</span><br><span class="line">  2-1、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明">补充说明</h3><ol><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h2 id="操作数栈">操作数栈</h2><h3 id="操作数栈的特点">操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><h3 id="操作数栈的作用">操作数栈的作用</h3><ol><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><h3 id="操作数栈字节码示例">操作数栈字节码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518123010951.png" style="zoom: 80%;" /><p>详细运行过程如下：</p><ol><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518123758242.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518123943672.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124040895.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124229041.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124327892.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124617207.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124744230.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518124859690.png" style="zoom:67%;" /></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518125044802.png" style="zoom:67%;" /></li></ol><h3 id="栈顶缓存技术">栈顶缓存技术</h3><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h3 id="动态链接">动态链接</h3><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p></li></ol><p><strong>符号引用</strong>，指向的为——方法名、方法参数、返回值类型等信息，而<strong>直接引用</strong>就是指向了实际要执行的方法信息（例如符号引用指向的是接口中定义的方法，然后直接引用就是指向其实现类的实现方法？）</p><p><strong>为什么要用常量池呢？</strong></p><ol><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h3 id="方法的调用">方法的调用</h3><h4 id="静态链接与动态链接">静态链接与动态链接</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="早期绑定与晚期绑定">早期绑定与晚期绑定</h4><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><h4 id="多态与绑定">多态与绑定</h4><ol><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol><h5 id="虚方法与非虚方法">虚方法与非虚方法</h5><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h5 id="关于-invokedynamic-指令">关于 invokedynamic 指令</h5><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><h5 id="动态语言和静态语言">动态语言和静态语言</h5><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java：String info = &quot;mogu blog&quot;;     (Java是静态类型语言的，会先编译就进行类型检查)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS：var name = &quot;shkstart&quot;;    var name = 10;（运行时才进行检查）   </span><br></pre></td></tr></table></figure><pre><code>Python: info = 130.5 (运行时才检查)</code></pre><h5 id="Java语言中方法重写的本质">Java语言中方法重写的本质</h5><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表">虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p></li></ol><p><strong>举例</strong></p><p>如下图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p>再比如：</p><ul><li><p>son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p></li><li><p>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p></li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JVM/blog-20250518131803931.png" style="zoom:67%;" /><h3 id="方法返回地址">方法返回地址</h3><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p><strong>正常退出</strong>：正常执行完成</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ul></li><li><p><strong>异常退出</strong>：出现未处理的异常，非正常退出</p><ul><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>，方便在发生异常的时候找到处理异常的代码</p><blockquote><p>异常处理表：</p></blockquote><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul></li></ul></li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><h3 id="一些附加信息">一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h3 id="栈相关面试题">栈相关面试题</h3><h4 id="举例栈溢出的情况？">举例栈溢出的情况？</h4><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h4 id="调整栈大小，就能保证不出现溢出么？">调整栈大小，就能保证不出现溢出么？</h4><p>不能保证不溢出，只能保证SOF出现的几率小</p><h4 id="分配的栈内存越大越好么？">分配的栈内存越大越好么？</h4><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h4 id="垃圾回收是否涉及到虚拟栈？">垃圾回收是否涉及到虚拟栈？</h4><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h4 id="方法中定义的局部变量是否线程安全？">方法中定义的局部变量是否线程安全？</h4><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>To Be Continue</h1>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>汇编语言</h1><h2 id="寄存器">寄存器</h2><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250429230756497.png" style="zoom:80%;" /><blockquote><ol><li><p>对于8086、8088或80286，阴影区域是不可用的</p></li><li><p>FS和GS寄存器无专用名称</p></li></ol></blockquote><ol><li><p><strong>通用寄存器</strong></p><ul><li>数据寄存器：AX（accumulator）、BX（base）、CX（count）、DX（data）</li><li>指针寄存器：SP（stack pointer）、BP（base pointer）</li><li>变址寄存器：DI（destination index）、SI（source index）</li></ul></li><li><p><strong>控制寄存器</strong></p><ul><li>IP（instruction pointer）、FLAGS</li></ul></li><li><p><strong>段寄存器</strong></p><ul><li>CS（code segment）、DS（data segment）、ES（extra segment）、SS（stack segment）</li></ul></li><li><p><strong>标志寄存器</strong></p><ul><li>OF溢出标志，运算过程溢出置1，否则置0</li><li>SF符号标志，<strong>结果为负置1，否则置0</strong></li><li>ZF零标志，运算结果为0置1，否则置0</li><li>CF进位标志，e.g.加法运算中，有进位置1，否则置0</li><li>AF辅助进位标志，记录运算时第三位产生的进位值</li><li>PF奇偶标志。结果操作数中1个数为偶置1，否则置0</li></ul></li></ol><h2 id="标志位">标志位</h2><table><thead><tr><th>标志名</th><th>标志为1</th><th>标志为0</th></tr></thead><tbody><tr><td>OF     溢出（是/否）</td><td>OV</td><td>NV</td></tr><tr><td>DF     方向（减量/增量）</td><td>DN</td><td>UP</td></tr><tr><td>IF       中断（允许/关闭）</td><td>EI</td><td>DI</td></tr><tr><td>SF      符号（负/正）</td><td>NG</td><td>PL</td></tr><tr><td>ZF      零（是/否）</td><td>ZR</td><td>NZ</td></tr><tr><td>AF      辅助进位（是/否）</td><td>AC</td><td>NA</td></tr><tr><td>PF      奇偶（偶/奇）</td><td>PE</td><td>PO</td></tr><tr><td>CF      进位（是/否）</td><td>CY</td><td>NC</td></tr></tbody></table><h2 id="80x86寻址方式">80x86寻址方式</h2><h3 id="与数据有关的寻址方式">与数据有关的寻址方式</h3><ol><li><p><strong>立即寻址方式（immediate addressing）</strong></p><ul><li><code>MOVAL,5</code></li><li><code>MOVAX,3064H</code></li><li><code>MOVEAX,12345678H</code></li></ul></li><li><p><strong>寄存器寻址方式（register addressing）</strong></p><ul><li><code>MOVAX,BX</code></li><li><code>MOVECX,EDX</code></li></ul></li><li><p><strong>直接寻址方式（direct addressing）</strong></p><ul><li><code>MOVAX,[2000H]</code></li><li><code>MOV AX,VALUE</code>等价<code>MOV AX,[VALUE]</code></li><li><code>MOVAX,ES:VALUE</code>（段跨越前缀，默认为DS）</li></ul></li><li><p><strong>寄存器间接寻址方式（register indirect addressing）</strong></p><ul><li><code>MOVAX,[BX]</code></li><li><code>MOVAX,ES:[BX]</code>（段跨越前缀，默认为DS）</li></ul><blockquote><p>使用BP、SP时，默认段位SS。其他寄存器的默认段位DS寄存器。</p></blockquote></li><li><p><strong>寄存器相对寻址方式（register relative addressing）（或称直接变址寻址方式）</strong></p><ul><li><code>MOVAX,COUNT[SI]</code>等价于<code>MOV AX,[COUNT+SI]</code></li><li><code>MOVDL,ES:STRING[SI]</code></li></ul></li><li><p><strong>基址变址寻址方式（based indexed addressing）</strong></p><ul><li><code>MOVAX,[BX][DI]</code>等价于<code>MOVAX,[BX+DI]</code></li><li><code>MOVAX,ES:[BX][DI]</code></li></ul></li><li><p><strong>相对基址变址寻址方式（relative based indexed addressing）</strong></p><ul><li><code>MOVAX,MASK[BX][SI]</code></li></ul></li><li><p>比例变址寻址方式（scaled indexed addressing）</p></li><li><p>机制比例变址寻址方式（based scaled indexed addressing）</p></li><li><p>相对基址比例变址寻址方式（relative based scaled index addressing）</p></li></ol><h3 id="与转移地址有关的寻址方式">与转移地址有关的寻址方式</h3><ol><li>段内直接寻址（intrasegment direct addressing）</li><li>段内间接寻址（intrasegment indirect addressing）</li><li>段间直接寻址（intersegment direct addressing）</li><li>段间间接寻址（intersegment indirect addressing）</li></ol><h2 id="指令">指令</h2><h3 id="数据传送指令">数据传送指令</h3><h4 id="通用数据传送指令">通用数据传送指令</h4><ol><li><p><strong>MOV</strong></p><ul><li><code>MOVDST,SRC</code>将SRC内容传送至DST</li></ul><blockquote><p>双操作数指令<strong>不允许两个操作数都使用存储器</strong>，必须有一个是寄存器</p><p>DST不允许是立即数、不允许是CS寄存区（代码段）</p></blockquote></li><li><p>MOVSX</p><ul><li><code>MOVSXDST,SRC</code>，带符号拓展传送指令</li></ul></li><li><p>MOVSX</p><ul><li><code>MOVZXDST,SRC</code>，带符号拓展传送指令</li></ul></li><li><p><strong>PUSH</strong></p><ul><li><code>PUSHSRC</code>：先移动指针，后压入数据（所以压完数据后，指针是指向着该数据的）</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250429230831387.png" style="zoom:80%;" /></li><li><p><strong>POP</strong></p><ul><li><code>POPDST</code>：先弹出数据，后移动指针</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250429230927655.png" style="zoom:80%;" /></li><li><p>PUSHA/PUSHAD，所有寄存器进栈指令</p></li><li><p>POPA/POPAD，所有寄存器出栈指令</p></li><li><p><strong>XCHG</strong></p><ul><li><code>XCHGOPR1,OPR2</code>，由于是双操作数指令，必须有一个在寄存器中</li></ul></li></ol><h4 id="累加器专用传送指令">累加器专用传送指令</h4><ol><li>IN</li><li>OUT</li><li>XLAT</li></ol><h4 id="地址传送指令">地址传送指令</h4><ol><li><strong>LEA</strong><ul><li><code>LEAREG,SRC</code>，指令把原操作数的有效地址送到指定的寄存器中（用于获得地址的）</li></ul></li><li>LDS、LES、LFS、LGS、LSS</li></ol><h4 id="标志寄存器传送指令">标志寄存器传送指令</h4><ol><li>LAHF、SAHF、PUSHF/PUSHFD、POPF/POPFD</li></ol><h4 id="类型转换指令">类型转换指令</h4><ol><li>CBW，字节转换为字</li><li>CWD/CWDE，字转换为双字</li><li>CDQ，双字转换为4字</li><li>BSWAP，字节转换为字指令</li></ol><h3 id="算术指令">算术指令</h3><h4 id="加法指令">加法指令</h4><blockquote><p>ADD、INC常用</p><p>除INC外，其余指令影响标志位</p></blockquote><ol><li>ADD<ul><li><code>ADDDST,SRC</code></li></ul></li><li>ADC<ul><li><code>ADCDST,SRC</code>，带进位加法</li></ul></li><li>INC<ul><li><code>INCOPR</code>，加一</li></ul></li><li>XADD<ul><li><code>XADDDST,SRC</code></li><li>执行操作：<code>TEMP←(SRC)+(DST)</code>，<code>(SRC)←(DST)</code>，<code>(DST)←TEMP</code></li></ul></li></ol><p>加法指令（除INC指令）会影响标志位，CF位可表示<strong>无符号数</strong>的溢出，OF位可表示带符号数的溢出</p><p>故，若是无符号数的加法运算下，CF=1，则运算错误；若是带符号数的加法运算，OF=1，运算错误。</p><p><strong>INC不会影响CF标志位</strong></p><h4 id="减法指令">减法指令</h4><blockquote><p><strong>SUB、DEC、CMP</strong>常用</p><p>除DEC外，其余指令均影响CF标志位</p></blockquote><ol><li><strong>SUB</strong><ul><li><code>SUBDST,SRC</code>，执行<code>(DST)←(DST-SRC)</code>操作</li></ul></li><li>SBB<ul><li><code>SBBDST,SRC</code>，带借位减法指令，执行<code>(DST)←(DST)-(SRC)-CF</code>操作</li></ul></li><li><strong>DEC</strong><ul><li><code>DECOPR</code>，减一指令，执行<code>(OPR)←(OPR)-1</code>操作</li></ul></li><li>NEG<ul><li><code>NEGOPR</code>，求补指令，执行<code>(OPR)←-(OPR)</code>操作（或表示为<code>(OPR)←0FFFH-(OPR)+1</code>）</li></ul></li><li><strong>CMP</strong><ul><li><code>CMPDST,SRC</code>，执行<code>(DST-SRC)</code>操作，不保存结果，但影响标志位CF，后常接跳转指令</li></ul></li></ol><p>CF位表示无符号数的溢出，OF代表带符号位数的溢出。</p><p>故，减法中：无符号数减法，<code>被减数-减数 &lt; 0</code>，CF设置为1（“不够减”），否则为0；带符号数减法，若被减数与减数符号相同，减后结果符号与被减数（或减数）相反，则OF设置为1，其余情况为0。</p><h4 id="乘法指令">乘法指令</h4><ol><li>MUL<ul><li><code>MULSRC</code>，无符号乘法，执行操作如下：<ul><li>字节操作数：<code>(AX)←(AL)*(SRC)</code></li><li>字操作数：<code>(DX,AX)←(AX)*(SRC)</code></li><li>双字操作数：<code>(EDX,EAX)←(EAX)*(SRC)</code></li></ul></li><li>执行操作视SRC类型而定</li></ul></li><li>IMUL<ul><li><code>IMULSRC</code>，带符号乘法，执行操作与MUL指令一致</li></ul></li></ol><p>以使用MUL指令、SRC是AL为例，若结果(AX)的高8位为0，则CF位和OF位均为0，否则CF、OF位均设置为1</p><p>乘法指令中，CF、OF标志位可用于检查<strong>字节相乘的结果是字节还是字</strong>、<strong>字相乘的结果是字还是双字</strong>、……</p><h4 id="除法指令">除法指令</h4><ol><li>DIV<ul><li><code>DIVSRC</code>，无符号数除法，执行操作如下：<ul><li>字节操作：<code>(AL)←(AX)/(SRC)的商</code>，<code>(AH)←(AX)/(SRC)的余数</code></li><li>字操作：<code>(AX)←(DX,AX)/(SRC)的商</code>，<code>(DX)←(DX,AX)/(SRC)的余数</code></li><li>双字操作：<code>(EAX)←(EDX,EAX)/(SRC)的商</code>，<code>(EDX)←(EDX,EAX)/(SRC)的余数</code></li></ul></li></ul></li><li>IDIV<ul><li><code>IDIVSRC</code>，带符号数除法，执行操作同上</li></ul></li></ol><h3 id="逻辑指令">逻辑指令</h3><h4 id="逻辑运算指令">逻辑运算指令</h4><blockquote><p>NOT的操作数不能是立即数，其余指令DST必须是寄存器</p></blockquote><ol><li>AND<ul><li><code>ANDDST,SRC</code>，逻辑与，执行<code>(DST)←(DST)⋀(SRC)</code>操作</li></ul></li><li>OR<ul><li><code>ORDST,SRC</code>，逻辑或，执行<code>(DST)←(DST)⋁(SRC)</code>操作</li></ul></li><li>NOT<ul><li><code>NOTOPR</code>，逻辑非，执行<code>(DST)←(OPR)的非</code>操作</li></ul></li><li>XOR<ul><li><code>ORDST,SRC</code>，异或，执行<code>(DST)←(DST)与(SRC)的异或</code>操作</li></ul></li><li>TEST<ul><li><code>TESTOPR1,OPR2</code>，测试，执行<code>(DST)⋀(SRC)</code>操作</li></ul></li></ol><h4 id="位测试并修改指令（略）">位测试并修改指令（略）</h4><ol><li>BT</li><li>BTS</li><li>BTR</li><li>BTC</li></ol><h4 id="位扫描指令（略）">位扫描指令（略）</h4><ol><li>BSF</li><li>BSR</li></ol><h4 id="移位指令">移位指令</h4><ol><li><p>移位指令</p><ul><li><p>SHL</p></li><li><p>SAL</p></li><li><p>SHR</p></li><li><p>SAR</p></li></ul></li><li><p>循环移位指令</p><ul><li><p>ROL</p></li><li><p>ROR</p></li><li><p>RCL</p></li><li><p>RCR</p></li></ul></li><li><p>双精度移位指令</p><ul><li><p>SHLD</p></li><li><p>SHRD</p></li></ul></li></ol><h3 id="串处理指令（略）">串处理指令（略）</h3><ol><li>MOVS</li><li>CMPS</li><li>SCAS</li><li>LODS</li><li>STOS</li><li>INS</li><li>OUTS</li></ol><p>与上述配合使用前缀有</p><ol><li>REP</li><li>REPE/REPZ</li><li>REPNE/REPNZ</li></ol><h3 id="控制转移指令">控制转移指令</h3><h4 id="无条件转移指令">无条件转移指令</h4><p>JMP跳转指令</p><ol><li><code>JMPSHORT OPR</code></li><li><code>JMPNEAR PTR OPR</code></li></ol><h4 id="条件转移指令">条件转移指令</h4><h4 id="条件设置指令（略）">条件设置指令（略）</h4><h4 id="循环指令">循环指令</h4><h4 id="子程序">子程序</h4><h2 id="汇编语言程序（练习）">汇编语言程序（练习）</h2><h3 id="把BX寄存器内的二进制数以十六机制的形式在屏幕上打印">把BX寄存器内的二进制数以十六机制的形式在屏幕上打印</h3><ol><li><p>在<code>print_loop</code>中：</p><ul><li><p><code>rol     bx, 4</code>会将BX循环左移4位，比如原先为<code>0010,1010,1111,0011B</code>则变为<code>1010,1111,0011,0010B</code>，也就是原先的最高的4位到了BX的末尾的4位上</p></li><li><p>下一步——使用<code>mov     al, bl</code>指令将bl内容移动至al（bl是bx的后八位）</p></li><li><p>由于一个十六进制数需要4位进行表示，所以此时al中的高4位是不需要的，使用<code>and     al, 0Fh</code>指令对高四位进行消除</p></li><li><p>处理得到<code>0000????</code>这样一个低四位有效的al后，要判断al是属于0-9还是A-F</p></li><li><p>al的数值有效范围是0-15，若是0-9，直接打印（后续加上’0’即可）</p></li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250507154346239.png" style="zoom:50%;" /></li><li><p>若是10-15，先加上7（这样的话，后续也加上’0’，就能对应上ASCII的’A’-‘F’）</p></li></ul></li><li><p>关于<strong>在屏幕上打印</strong>（固定语句）</p><ul><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/blog-20250507154327650.png" alt=""></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">prognam segment           ; 定义一个名为 prognam 的段（Segment）</span><br><span class="line">main    proc far          ; 声明一个远程（far）过程 main</span><br><span class="line">    assume cs:prognam     ; 告诉汇编器：此时 CS 寄存器指向 prognam 段</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; ---- 初始化 DS ----</span><br><span class="line">    push    ds            ; 保存原 DS</span><br><span class="line">    mov     ax, cs        ; AX ← CS（当前段选择子）</span><br><span class="line">    mov     ds, ax        ; DS ← AX，使 DS 与 CS 同段</span><br><span class="line"></span><br><span class="line">    ; ---- 将 BX 设为要显示的 16 位二进制数 ----</span><br><span class="line">    mov     bx, 0010101011110011B  </span><br><span class="line">                          ; BX ← 二进制 0010?1010?1111?0011?（0x2AF3）</span><br><span class="line"></span><br><span class="line">    mov     cx, 4         ; CX ← 4，表示要输出 4 个半字节（nibble）</span><br><span class="line"></span><br><span class="line">print_loop:</span><br><span class="line">    rol     bx, 4         ; BX 循环左移 4 位，下一个半字节移到 BL 低 4 位</span><br><span class="line">    mov     al, bl        ; AL ← BX 的低字节</span><br><span class="line">    and     al, 0Fh       ; AL ← AL AND 0x0F，只保留最低 4 位</span><br><span class="line"></span><br><span class="line">    cmp     al, 9         ; 判断当前值是否 ≤ 9</span><br><span class="line">    jbe     is_digit      ; 如果是数字（0–9），跳到数字处理</span><br><span class="line">    add     al, 7         ; 否则（10–15），先加 7 使其对应到 A–F</span><br><span class="line"></span><br><span class="line">is_digit:</span><br><span class="line">    add     al, &#x27;0&#x27;       ; AL += &#x27;0&#x27;，转换为 ASCII 字符</span><br><span class="line"></span><br><span class="line">    mov     dl, al        ; DL ← 要打印的 ASCII 字符</span><br><span class="line">    mov     ah, 02h       ; DOS 中断 21h 功能号 2：打印 DL 中的字符</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">    dec     cx            ; CX--，处理完一个半字节</span><br><span class="line">    jnz     print_loop    ; 如果 CX ≠ 0，则继续循环</span><br><span class="line"></span><br><span class="line">    ; ---- 恢复 DS 并退出 ----</span><br><span class="line">    pop     ds            ; 恢复原 DS</span><br><span class="line">    mov     ah, 4Ch       ; DOS 中断 21h 功能号 4Ch：程序退出</span><br><span class="line">    mov     al, 00        ; 返回码 0</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">main    endp             ; 过程结束</span><br><span class="line">prognam ends              ; 段结束</span><br><span class="line">    end     start        ; 程序入口（指向 start 标签）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="从键盘接受十六进制数并存入BX">从键盘接受十六进制数并存入BX</h3><ol><li>关于<strong>从屏幕输入</strong><ul><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250507155431128.png" style="zoom: 67%;" /></li></ul></li><li>关于输入的数字的判断——判断是属于’0’-‘9’还是’A’-‘F’（后续还可以拓展为’a’-‘f’）<ul><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250507155841900.png" style="zoom:50%;" /></li><li>首先我们从屏幕输入的都是ASCII，比如输入的是’0’，实际上al中的十进制值是48，故减去48以使其范围落到数值0-9（若不是后续判断）</li><li><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/汇编语言/blog-20250508095417146.png" style="zoom:80%;" /></li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">prognam segment           ; 定义代码段</span><br><span class="line">main    proc far          ; 定义远程过程 main</span><br><span class="line">    assume cs:prognam     ; 告诉汇编器：CS 段寄存器关联 prognam</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    ; ---- 初始化 DS 段 ----</span><br><span class="line">    push    ds            ; 保存 DS</span><br><span class="line">    mov     ax, cs        ; 将 CS 的值赋给 AX</span><br><span class="line">    mov     ds, ax        ; 设置 DS ← CS</span><br><span class="line"></span><br><span class="line">    ; ---- BX 初始化为 0 ----</span><br><span class="line">    mov     bx, 0         ; 用于存储输入的十六进制数</span><br><span class="line"></span><br><span class="line">newchar:</span><br><span class="line">    mov     ah, 1         ; DOS 功能号 1：带回显读取字符</span><br><span class="line">    int     21h           ; 调用 DOS 中断，输入字符保存在 AL 中</span><br><span class="line"></span><br><span class="line">    sub     al, 30h       ; AL -= &#x27;0&#x27;，尝试转为数字 0–9</span><br><span class="line">    jl      exit          ; 如果小于 0，非法输入 → 退出</span><br><span class="line">    cmp     al, 10</span><br><span class="line">    jl      add_to        ; 如果 AL &lt; 10，说明是 0–9 → 继续处理</span><br><span class="line"></span><br><span class="line">    sub     al, 7         ; AL -= (&#x27;A&#x27; - 10) = 0x41 - 0x0A = 0x37</span><br><span class="line">                          ; 所以等价于：AL ← AL - 27h</span><br><span class="line"></span><br><span class="line">    cmp     al, 0Ah       ; 检查是否是合法十六进制字母（A–F）</span><br><span class="line">    jl      exit          ; 小于 A → 非法 → 退出</span><br><span class="line">    cmp     al, 10h</span><br><span class="line">    jge     exit          ; 大于 F → 非法 → 退出</span><br><span class="line"></span><br><span class="line">add_to:</span><br><span class="line">    mov     cl, 4         ; 每次移位 4 位，为新位腾出空间</span><br><span class="line">    shl     bx, cl        ; BX ← BX &lt;&lt; 4，相当于“进位”</span><br><span class="line">    xor     ah, ah        ; 清除 AH，确保 AX = AL（16 位加法安全）</span><br><span class="line">    add     bx, ax        ; BX += AL，即追加新的十六进制位</span><br><span class="line"></span><br><span class="line">    jmp     newchar       ; 继续读取下一个字符</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    pop     ds            ; 恢复原 DS（可选，但良好习惯）</span><br><span class="line">    mov     ah, 4Ch       ; DOS 功能号 4Ch：正常退出程序</span><br><span class="line">    mov     al, 00        ; 返回代码 0</span><br><span class="line">    int     21h</span><br><span class="line"></span><br><span class="line">main    endp              ; 过程结束</span><br><span class="line">prognam ends              ; 段结束</span><br><span class="line">        end start         ; 程序入口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="往有序数组中插入数据">往有序数组中插入数据</h3><ol><li>已知是一个有限数组，要求插入一个数据，思路是从后向前找</li><li>逐个比较，每次比较时，若待插入数小于当前数，则将当前位置的数后移</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    x dw ?</span><br><span class="line">    array_head dw 3,5,15,23,37,49,52,65,78,99</span><br><span class="line">    array_end dw 105</span><br><span class="line">    n dw 32</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line"></span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov ax,n</span><br><span class="line">    mov array_head-2,0ffffh  ;0ffffh的0是因为十六进制开头添加</span><br><span class="line">    mov si,0</span><br><span class="line">    </span><br><span class="line">compare:</span><br><span class="line">    cmp array_end[si],ax</span><br><span class="line">    jle insert</span><br><span class="line">    mov bx,array_end[si]</span><br><span class="line">    mov array_end[si+2],bx</span><br><span class="line">    sub si,2</span><br><span class="line">    jmp short compare</span><br><span class="line">insert:</span><br><span class="line">    mov array_end[si+2],ax</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    a dw 100,30,78,99,15,-1,66,45,189,255</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov cx,10  ;设置循环次数</span><br><span class="line">    dec cx     ; 10个数，需9次即可</span><br><span class="line">    </span><br><span class="line">loop1:</span><br><span class="line">    mov di,cx</span><br><span class="line">    mov bx,0</span><br><span class="line">loop2:</span><br><span class="line">    mov ax,a[bx]</span><br><span class="line">    cmp ax,a[bx+2]</span><br><span class="line">    jge continue</span><br><span class="line">    xchg ax,a[bx+2]</span><br><span class="line">    mov a[bx],ax</span><br><span class="line">continue:</span><br><span class="line">    add bx,2</span><br><span class="line">    loop loop2</span><br><span class="line">    </span><br><span class="line">    mov cx,di</span><br><span class="line">    </span><br><span class="line">    loop loop1</span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="例5-5">例5.5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">datarea segment</span><br><span class="line">    x dw 1,2,3,4,5,6,7,8,9,-3</span><br><span class="line">    y dw 9,8,-7,-6,-5,4,-3,-2,1,13</span><br><span class="line">    z dw 0,0,0,0,0,0,0,0,0,0</span><br><span class="line">    logic_rule dw 00dch;逻辑尺，为</span><br><span class="line">datarea ends</span><br><span class="line"></span><br><span class="line">prognam segment</span><br><span class="line">main proc far</span><br><span class="line">    assume cs:prognam,ds:datarea</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax,ax</span><br><span class="line">    push ax</span><br><span class="line">    </span><br><span class="line">    mov ax,datarea</span><br><span class="line">    mov ds,ax</span><br><span class="line">    </span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,10</span><br><span class="line">    mov dx,logic_rule</span><br><span class="line">next:</span><br><span class="line">    mov ax,x[bx]</span><br><span class="line">    shr dx,1</span><br><span class="line">    jc subtract</span><br><span class="line">    add ax,y[bx]</span><br><span class="line">    jmp short result</span><br><span class="line">subtract:</span><br><span class="line">    sub ax,y[bx]</span><br><span class="line">result:</span><br><span class="line">    mov z[bx],ax</span><br><span class="line">    add bx,2</span><br><span class="line">    loop next</span><br><span class="line">    ret                </span><br><span class="line">main endp</span><br><span class="line">prognam ends</span><br><span class="line">    end start</span><br></pre></td></tr></table></figure><h3 id="折半查找（二分）">折半查找（二分）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">    array dw 12,11,22,33,44,55,66,77,88,99,111,222,333  ; array[0] 存个数，后面是有序数组</span><br><span class="line">    number dw 55                                        ; 要查找的目标数</span><br><span class="line">    low_inx dw ?                                        ; 保存 low index</span><br><span class="line">    high_inx dw ?                                       ; 保存 high index</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">main proc far</span><br><span class="line">    assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    push ds</span><br><span class="line">    sub ax, ax</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    lea di, array         ; DI ← 数组首地址</span><br><span class="line">    mov cx, [di]          ; CX ← 元素个数（不含 array[0]）</span><br><span class="line">    mov ax, number        ; AX ← 要查找的目标数</span><br><span class="line"></span><br><span class="line">    mov low_inx, 1        ; low index ← 1（跳过 array[0]）</span><br><span class="line">    mov high_inx, cx      ; high index ← 元素个数</span><br><span class="line"></span><br><span class="line">binary_search:</span><br><span class="line">    mov cx, low_inx</span><br><span class="line">    cmp cx, high_inx</span><br><span class="line">    ja not_found          ; if low &gt; high，说明找不到</span><br><span class="line"></span><br><span class="line">    mov cx, low_inx</span><br><span class="line">    add cx, high_inx</span><br><span class="line">    shr cx, 1             ; CX ← mid index</span><br><span class="line"></span><br><span class="line">    mov si, cx</span><br><span class="line">    mov bx, si</span><br><span class="line">    shl bx, 1             ; bx ← si * 2（字节偏移）</span><br><span class="line">    add bx, di            ; bx ← 元素地址</span><br><span class="line"></span><br><span class="line">    mov dx, [bx]          ; DX ← 当前比较值</span><br><span class="line">    cmp ax, dx</span><br><span class="line">    je found              ; 如果相等，跳转</span><br><span class="line"></span><br><span class="line">    jb less_than          ; 如果 ax &lt; array[si]，搜索左半边</span><br><span class="line"></span><br><span class="line">    ; 否则搜索右半边</span><br><span class="line">    inc si</span><br><span class="line">    mov low_inx, si</span><br><span class="line">    jmp binary_search</span><br><span class="line"></span><br><span class="line">less_than:</span><br><span class="line">    dec si</span><br><span class="line">    mov high_inx, si</span><br><span class="line">    jmp binary_search</span><br><span class="line"></span><br><span class="line">not_found:</span><br><span class="line">    stc                   ; 未找到，CF = 1</span><br><span class="line">    jmp finish</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    clc                   ; 找到了，CF = 0</span><br><span class="line">    shl si, 1             ; 转换为字节偏移</span><br><span class="line">                          ; si 即偏移地址（从 array 起）</span><br><span class="line">finish:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">    end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>已做实验</h1><p>1.1：在数据段DATA中有两个字数据X和Y， 假设X=1122H，Y=3344H， 编程求两个字的和,结果存放到Z单元中。</p><p>1.2：从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。</p><p>2.1：计算1+2+3+…+10，将结果显示在屏幕上。对1-10求和、将结果打印（这个比较关键、利用除法进行输出）（div指令的商在AX、余数在DX）（所以每次得到一个DX就进行PUSH、并同时用CX记录位数）（最后POP DX即可输出——记得转成ascii）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH, 1    ; AH存入子功能号1</span><br><span class="line">INT 21H       ; 调用21H中断，等待用户键盘输入一个字符，并存入AL</span><br></pre></td></tr></table></figure><p>2.2：利用01H号功能调用输入10个一位数字，将其由数字字符转换为相应整数，并依次保存到字节变量BUF。编程求出这10个数中的最大数和最小数，分别存入字节变量MAX和MIN，并分别将其在屏幕上显示出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AH, 2     ; AH存入子功能号2</span><br><span class="line">MOV DL, ‘A’    ; DL存入要显示的字符‘A’</span><br><span class="line">INT 21H        ; 调用21H中断，屏幕上显示DL中的字符</span><br></pre></td></tr></table></figure><p>2.3：输入一个不大于65535的十进制非负整数，判断其是否为素数，如果是素数，输出字符串“It’s a prime.”，否则输出字符串“It’s not a prime.”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据段：</span><br><span class="line">定义变量，并初始化为字符串：</span><br><span class="line">STR  DB  “hello world”, ‘$’</span><br><span class="line">代码段：</span><br><span class="line">MOV AH, 9             ; AH存入子功能号9</span><br><span class="line">MOV DX, OFFSET STR   ; DX中存入字符串的首地址</span><br><span class="line">INT 21H                ; 调用21H中断，屏幕上显示DX指向的字符串“hello world”</span><br></pre></td></tr></table></figure><p>3.1：从键盘上输入多个长度小于30的字符串，直到输入空行为止，将其中最长的一行字符串显示输出。</p><p>要求：（1）定义子过程GETS，实现从键盘输入字符串到参数数组中，读取包括空格在内的所有字符，直到遇到换行符为止，在字符数组中以‘\0’字符作为字符串末尾标记，该过程的返回值为输入的字符串的长度，返回值用寄存器AX传递。</p><p>（2）定义子过程PUTS，实现输出参数数组中的字符串，该过程的返回值为输出的字符个数，返回值用寄存器AX传递。</p><p>（3）定义主过程MAIN，调用两个子过程实现程序功能。</p><p>（4）输入一个字符通过调用21H号DOS中断的1号功能，输出一个字符通过该中断的2号功能调用。</p><p>3.2：编写十进制数到十六进制的转换程序。用户从键盘输入一个十进制无符号整数，然后把该数以十六进制形式（包括后缀字符H）在屏幕上显示出来。</p><p>要求：（1）定义两个子过程INPUT和OUTPUT。过程INPUT实现键盘输入一个十进制无符号整数，存入寄存器BX。过程OUTPUT实现以十六进制形式（包括后缀字符H）在屏幕上输出寄存器BX的值。</p><p>（2）定义主过程MAIN调用两个子过程实现程序功能。</p><h1>other</h1><p>自写：输入一连串数字保存、再输出（每个位上+1）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">; multi-segment executable file template.</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    num db 20 dup(0)</span><br><span class="line">    len dw 0</span><br><span class="line">ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">; set segment registers:</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">   call INPUT</span><br><span class="line">    </span><br><span class="line">    call OUTPUT</span><br><span class="line">    </span><br><span class="line">    mov ax, 4c00h ; exit to operating system.</span><br><span class="line">    int 21h    </span><br><span class="line">ends</span><br><span class="line">               </span><br><span class="line">INPUT proc</span><br><span class="line">    push ax</span><br><span class="line">    push si</span><br><span class="line">    </span><br><span class="line">    mov si,0 ;用于计数（偏移量）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">input_loop:</span><br><span class="line">    mov ah,1</span><br><span class="line">    int 21h</span><br><span class="line">    cmp al,0Dh  ;若为回车，则退出输入</span><br><span class="line">    je end_loop    </span><br><span class="line">    sub al,&#x27;0&#x27;  ;这里已经保证输入的数据是0-9</span><br><span class="line">    mov num[si],al</span><br><span class="line">    inc si</span><br><span class="line">    jmp input_loop</span><br><span class="line">    </span><br><span class="line">end_loop:</span><br><span class="line">    mov len,si  ;将长度信息保存到len</span><br><span class="line">              </span><br><span class="line">    pop si      </span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line">INPUT endp</span><br><span class="line"></span><br><span class="line">OUTPUT proc</span><br><span class="line">    mov cx,len</span><br><span class="line">    mov si,0</span><br><span class="line">output_loop:</span><br><span class="line">    mov ah,2</span><br><span class="line">    mov dl,num[si]  ;将num转为字符     （为了区别显示，加了1）</span><br><span class="line">    add dl,&#x27;1&#x27;</span><br><span class="line">    int 21h  ;输出dl中的值</span><br><span class="line">    inc si</span><br><span class="line">    loop output_loop</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line">OUTPUT endp</span><br><span class="line"></span><br><span class="line">end start ; set entry point and stop the assembler.</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS逆向</title>
      <link href="/2025/04/23/Python/JS%E9%80%86%E5%90%91/"/>
      <url>/2025/04/23/Python/JS%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1>JS逆向</h1><h2 id="浏览器调试工具介绍">浏览器调试工具介绍</h2><ol><li><strong>元素</strong>界面，用于展示当前网页信息（但是注意这个不是静态资源）</li></ol><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429231322792.png" alt=""></p><ol start="2"><li><strong>控制台</strong>界面，用于调试打印信息的（类比cmd）</li></ol><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429231416377.png" alt=""></p><ol start="3"><li><strong>源代码/来源</strong>界面，存放了js代码、图片、css、html等静态资源文件</li></ol><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429231437460.png" alt=""></p><ol start="4"><li><strong>网络</strong>界面，用于网络请求的监听（非抓包，抓包是可以对其中内容作修改的）<ul><li>Fetch/XHR：动态数据</li><li>文档：静态数据</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429231527621.png" alt=""></p><h2 id="tips">tips</h2><ol><li>在网页中找到对应的接口，注意区分动态与静态接口<ul><li>动态接口返回的是结构化数据（通过后端返回的），静态接口返回的是非结构化数据（HTML、CSS、JS）</li></ul></li><li>查看返回的数据大小，来排除一些返回数据过小的接口（如果你想要的数据是很大的数据的话）</li></ol><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429231556422.png" alt=""></p><ol start="3"><li><p>快速生成爬虫代码，<a href="https://curlconverter.com/">工具网站</a></p><ul><li><p>复制接口的crul代码（bash格式）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS逆向/blog-20250429231725983.png" style="zoom:67%;" /></li><li><p>复制到网站后，直接生成代码：</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429232219382.png" alt=""></p></li></ul></li><li><p>如果发现浏览器返回数据是这种带有大括号的，直接在接受后，使用.json()进行转换</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429232255492.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429232338834.png" alt=""></p></li><li><p>网络-&gt;选中接口-&gt;启动器</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/JS%E9%80%86%E5%90%91/blog-20250429232439491.png" alt=""></p></li><li><p>确定JS是否存在混淆或加密（eval）</p></li><li><p>若无，则定位加密位置或者解密</p><ol><li></li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之Scrapy框架使用</title>
      <link href="/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>爬虫之Scrapy框架使用</h1><h2 id="安装">安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><h2 id="quick-start">quick_start</h2><ol><li>使用<code>scrapy startproject 项目名称</code>创建scrapy项目</li><li>项目组成</li><li>创建爬虫文件<ul><li><code>cd 目录名称/目录名称/spiders</code>跳转到spiders文件夹</li><li><code>scrapy genspider 爬虫名字 网页的域名</code>，网页域名不用加协议</li></ul></li><li>运行爬虫文件（在spiders目录下执行）<code>scrapy crawl 爬虫名称</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫基础</title>
      <link href="/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Python爬虫基础</h1><p>爬虫，就是通过一个程序，根据url进行爬取网页，获取有用信息。</p><p>爬虫的核心在于：</p><ol><li>根据需求，确定要爬取的url</li><li>模拟浏览器进行访问，获取到返回的HTML源码</li><li>对该HTML进行解析，获取需要的数据</li></ol><p>爬虫的难点在于——<strong>如何应对反爬手段</strong>。</p><p>本文聚焦与两方面内容：</p><ol><li>一些基本爬虫工具库的使用（urllib、xpath、jsonpath、bs4、request）</li><li>进行爬虫过程中遇到的一些问题以及解决方案</li></ol><h2 id="urllib">urllib</h2><p><a href="https://docs.python.org/zh-cn/3.13/library/urllib.html">官方文档</a>：其中<code>urllib.request</code>库用于打开和读取URL、<code>urllib.parse</code>用于解析URL，此两库常用。</p><p><a href="https://www.runoob.com/python3/python-urllib.html">urllib 菜鸟教程</a>：简单使用、查常用的API</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="XPath">XPath</h2><p><a href="https://lxml.de/tutorial.html">官方文档</a></p><p><a href="https://www.cnblogs.com/shizidushu/p/18398770">lxml.etree库-博客园</a>：API</p><p><a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 菜鸟教程</a>：重点关注XPath语法</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="jsonpath">jsonpath</h2><p><a href="https://goessner.net/articles/JsonPath/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="bs4">bs4</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="requests">requests</h2><p><a href="https://requests.readthedocs.io/projects/cn/zh-cn/latest/">官方文档</a></p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="Selenium">Selenium</h2><p><a href="http://www.selenium.org.cn/">官方？</a></p><p><a href="https://www.runoob.com/selenium/selenium-tutorial.html">菜鸟教程</a>：里面的方法名已经过时（在高版本被移除），通过传入一个<code>By.[ID等可选]</code>参数来解决</p><ul><li>[ ] 补充一些使用demo，放github仓库</li></ul><h2 id="问题以及解决方案">问题以及解决方案</h2><h3 id="1-根据url已获取到HTML，但没解析出内容？">1. 根据url已获取到HTML，但没解析出内容？</h3><p>具体场景为：使用urllib.request定制Request对象、模拟浏览器发送请求后，成功获取到HTML源码</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python爬虫基础/blog-20250501180159657.png" alt="image-20250419142009694" style="zoom:67%;" /><p>而在进行xpath解析时，却出了问题，先在网页HTML源码中寻找资源路径、且通过xpath插件验证过可行</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python爬虫基础/blog-20250501180235550.png" alt="image-20250419142702805" style="zoom:67%;" /><p>调试发现：无法通过该xpath表达式获取到对应内容</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python爬虫基础/blog-20250501180304051.png" alt="image-20250419143158604" style="zoom:67%;" /><p>原因并不是处在xpath解析式上，而是返回的content中的HTML源码与网页的HTML源码不是同一个！</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180323036.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180338752.png" alt="bfaefc76209c3851838238742d645bd1"></p><p>调试发现，获取的HTML版本是通过网络请求直接返回的那个</p><p>不一样的原因在于：<strong>浏览器执行了js代码，修改了类名</strong>，而爬取的网页是原始静态html，没修改类名。</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180351318.png" alt="image-20250419143547537"></p><h3 id="2-图片懒加载——你所见的不一定是真实的">2. 图片懒加载——你所见的不一定是真实的</h3><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python爬虫基础/blog-20250501180404511.png" alt="blog-20250501180404511" style="zoom:80%;" /><p>那么问题又来了，当有两个属性都是图片的链接地址，我该选择哪一个？有个小技巧是重新刷新网页——因为你有可能已经向下滑动，使得图片已被加载，刷新后，不要向下拖动，直接观察靠后的图片的链接地址，可以发现问题：图片在还没有被加载时，src属性并没有对应上图片链接（是默认图），所以在此例子中，original-data才是我们想要的</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python爬虫基础/blog-20250501180454474.png" alt="e8d52429156edcb9934aab91e91f722e" style="zoom:80%;" /><h3 id="3-selenium测试时元素定位失败？">3.selenium测试时元素定位失败？</h3><blockquote><p>原因：本地测试时，某个元素可能确实在那个位置上，标签信息也没写错。但是在selenium打开的浏览器中，同样的元素，对应的标签名可能有细微的差异，所以需要在selenium打开浏览器后，开F12进行定位</p></blockquote><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180508240.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180531396.png" alt=""></p><p>遇到问题：使用本地浏览器测试得到的、正确的xpath语句，在代码的selenium环境下却无法查询到元素！</p><p>然后，在selenium环境下的“浏览器”中F12进行元素定位：</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/blog-20250501180545437.png" alt=""></p><p>修改代码中的xpath解析式，成功定位到该元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马踏棋盘问题</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>马踏棋盘/骑士周游问题</h1><blockquote><p>DFS算法的应用</p></blockquote><h2 id="思路分析">思路分析</h2><p><strong>骑士周游问题的解决步骤和思路：</strong></p><ol><li><p><strong>创建棋盘</strong></p><p>初始化一个棋盘 <code>chessBoard</code>，它是一个二维数组，最终会显示出棋盘被访问的顺序（从1开始计数），也作为标记某个点是否被访问过使用（0则表示未访问过）。</p></li><li><p><strong>设置当前位置已访问</strong></p><p>将骑士的当前位置标记为已访问，并根据当前位置计算骑士能够跳到的合法位置。将这些位置存放在一个集合（如 <code>ArrayList</code>）中，最多包含8个合法的跳跃位置。每走一步，将步数 <code>step</code> 加 1（<code>step</code>从1开始）。</p></li><li><p><strong>遍历可能的跳跃位置</strong></p></li></ol><p>遍历 <code>ArrayList</code> 中存放的所有跳跃位置，检查哪个位置可以合法地走通。如果找到可以继续走的合法位置，则继续往下走；如果走不通，进行回溯，尝试其他可能的路径。</p><ol start="4"><li><p><strong>判断是否完成任务</strong></p><p>在每一步后，通过比较当前步数 <code>step</code> 和应走的总步数（例如，棋盘上总共有 64 格）来判断骑士是否完成了任务。如果步数未达到目标，表示任务尚未完成，需要将当前走的这步回溯（标记为未访问 + 从棋盘上移除step）</p></li></ol><h2 id="引入贪心算法的优化">引入贪心算法的优化</h2><p><strong>原始算法回顾：</strong></p><p>在原始的回溯算法中，每当骑士移动到一个新位置时，它会尝试从当前的位置出发，向所有可能的方向移动，直至找到一个合法的位置。如果某个位置无法继续走下去，算法就会回溯，尝试其他路径。这个过程有可能产生很多冗余的回溯操作，特别是当某些路径已经没有出路时，算法依然需要探索。</p><p><strong>优化的贪心策略：</strong></p><p>在优化后的版本中，我们对每一步的可能跳跃位置进行了排序，排序的依据是<strong>下一步的合法移动的数量</strong>。具体做法是，对于每一个当前位置，首先计算出它的所有可能的跳跃位置，接着计算每一个跳跃位置的下一步可能走的格子的数量（即它的“后继”点的数量），然后将这些点按“后继点数量”进行非递减排序，优先选择那些后继点数量少的点进行探索。</p><p><strong>为什么这个优化是有效的？</strong></p><ol><li><p><strong>减少回溯的次数：</strong></p><p>通过优先选择“后继点数目少”的点，我们可以有效减少不必要的回溯。原因如下：</p><ul><li>如果我们首先选择一个“后继点数目少”的点，那么骑士的下一步选择就会变得相对明确，不会出现太多的回溯，因为如果某个位置后继点数多，则它很可能导致更多的可能路径，造成更多的回溯操作。</li><li>反之，如果先选择了“后继点数目多”的点，可能导致骑士走入一个“死胡同”，这时算法会进行回溯，重新尝试其他的路径。通过贪心策略，减少了这类不必要的回溯。</li></ul></li><li><p><strong>更高效的路径探索：</strong></p><p>通过排序后的优先选择，我们相当于是在“预测”哪些路径最有可能找到解，并优先探索这些路径。这使得每次选择跳跃点时，骑士能较早地走到棋盘的“易走”区域，避免在困难区域做无谓的探索，从而提高算法的效率。</p></li><li><p><strong>防止局部最优：</strong></p><p>贪心算法的一大优势是局部最优的选择能够帮助我们尽量避免走入死胡同。通过选择“后继点数目少”的位置，实际上是让骑士先走到那些可能性更少的地方，这样如果后续真的出现死局（即所有可能的后继都被访问过），程序可以尽早发现并进行回溯，而不是等到最后一步才回溯。</p></li><li><p><strong>贪心策略的实际效果：</strong></p><ul><li>在没有优化的情况下，骑士可能在某些点周围存在很多可选的下一步位置（例如：有多个合法的跳跃位置），但这些位置的后继可能很复杂，导致更多的回溯。而引入贪心算法后，程序会先探索那些“跳跃空间”最小的路径，尽量避免复杂的回溯。</li><li><strong>非递减排序</strong>的策略本质上是在优先选择“后继点最少”的点，这是一种启发式的选择方法。通过这种方法，算法通常能够更快地找到解决方案，或者发现路径的死胡同，减少了回溯的开销。</li></ul></li></ol><blockquote><p>优化前：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/马踏棋盘问题/blog-20250501183456517.png" alt="image-20241114173601773" style="zoom:80%;" /></p><p>优化后：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/马踏棋盘问题/blog-20250501183506715.png" alt="image-20241114173523463" style="zoom: 80%;" /></p></blockquote><h2 id="代码实现">代码实现</h2><p><code>HorseStepChess</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.horseStepOnAChessBoard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HorseStepChess</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> R; <span class="comment">// 棋盘行数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> C; <span class="comment">// 棋盘列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] chessBoard; <span class="comment">// 使用棋盘作为标记数组（也同时记录行动路线）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> isFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义马的8个可能的移动方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] X_MOVE = &#123;-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] Y_MOVE = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        R = C = <span class="number">8</span>;</span><br><span class="line">        chessBoard = <span class="keyword">new</span> <span class="title class_">int</span>[R][C];</span><br><span class="line">        KnightTour(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessBoard.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessBoard[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessBoard[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 骑士周游方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r    当前行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c    当前列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 第 step 步（从1开始）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">KnightTour</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">        chessBoard[r][c] = step; <span class="comment">// 标记当前位置为第几步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前位置可走的下一步位置</span></span><br><span class="line">        ArrayList&lt;Point&gt; nextPoints = getNext(<span class="keyword">new</span> <span class="title class_">Point</span>(c, r));</span><br><span class="line">        <span class="keyword">while</span> (!nextPoints.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> nextPoints.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断该点是否未被访问过（chessBoard[][]为0就是未访问过）</span></span><br><span class="line">            <span class="keyword">if</span> (chessBoard[p.y][p.x] == <span class="number">0</span>) &#123; <span class="comment">// 注意 Point.x 是列，Point.y 是行</span></span><br><span class="line">                KnightTour(p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        <span class="comment">// 如果未完成任务且走不通，则重置当前格子</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; R * C &amp;&amp; !isFinished) &#123;</span><br><span class="line">            chessBoard[r][c] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFinished = <span class="literal">true</span>; <span class="comment">// 任务完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前位置下一步可能走的所有点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title function_">getNext</span><span class="params">(Point current)</span> &#123;</span><br><span class="line">        ArrayList&lt;Point&gt; points = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> current.x + X_MOVE[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> current.y + Y_MOVE[i];</span><br><span class="line">            <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; C &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; R) &#123;</span><br><span class="line">                points.add(<span class="keyword">new</span> <span class="title class_">Point</span>(newX, newY));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优化后代码">优化后代码</h2><ol><li>在<code>KnightTour</code>方法里，获取了当前点的下一步可走的所有点后，进行排序：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前位置可走的下一步位置</span></span><br><span class="line">ArrayList&lt;Point&gt; nextPoints = getNext(<span class="keyword">new</span> <span class="title class_">Point</span>(c, r));</span><br><span class="line"><span class="comment">//排序--优化部分，当按 下一个位置的下一次可能位置数 非递减排序时，可以减少回溯次数。</span></span><br><span class="line">sortPoints(nextPoints);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>sortPoints</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了优化骑士周游回溯的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortPoints</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> &#123;</span><br><span class="line">        ps.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Point&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Point o1, Point o2)</span> &#123;</span><br><span class="line">                <span class="comment">//获取o1的下一步所有可能位置 的个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> getNext(o1).size();</span><br><span class="line">                <span class="comment">//获取02的下一步所有可能位置 的个数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> getNext(o2).size();</span><br><span class="line">                <span class="keyword">return</span> size1 - size2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>main</code>方法中，可以以下方式对比优化前后的效率（测优化前就在<code>KnightTour</code>方法注释掉sortPoints）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        R = C = <span class="number">8</span>;</span><br><span class="line">        chessBoard = <span class="keyword">new</span> <span class="title class_">int</span>[R][C];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录算法开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        KnightTour(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 记录算法结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 输出运行时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;算法运行时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessBoard.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessBoard[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessBoard[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd算法</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Floyd%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Floyd%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>Floyd算法</h1><p><strong>Floyd算法介绍</strong></p><ol><li>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li><li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li><li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径</li><li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li></ol><p><strong>弗洛伊德算法思路</strong>：</p><ol><li>假设图中有顶点 $ v_i $、$ v_j$ 和 $ v_k $，其中 $ L_{ik} $表示从顶点 $v_i $到顶点 $ v_k $ 的最短路径，$ L_{kj} $ 表示从顶点 $ v_k $ 到顶点 $ v_j $ 的最短路径。那么，顶点 $ v_i $ 到顶点 $ v_j $ 的最短路径 $ L_{ij} $ 可以通过以下方式计算：</li></ol><p>$$<br>L_{ij} = \min(L_{ij}, L_{ik} + L_{kj})<br>$$</p><p>也就是说，从 $ v_i $ 到 $ v_j $ 的最短路径，可能是直接从 $ v_i $ 到 $ v_j $ 的路径（即 $ L_{ij} $），或者是通过一个中间顶点 $ v_k $ 经过 $ v_k $ 的路径，即先从 $ v_i $ 到 $ v_k $，再从 $ v_k $ 到 $ v_j $。</p><ol start="2"><li><p>在实际算法中，针对每一对顶点 $ (v_i, v_j) $，我们都会依次考虑所有可能的中间顶点 $ v_k $（即图中的每个顶点），计算并更新从 $ v_i $ 到 $ v_j $ 的最短路径。具体来说，对于每一个中间顶点 $ v_k $，我们更新所有顶点对 $ (v_i, v_j) $ 的最短路径：</p><p>$$<br>L_{ij} = \min(L_{ij}, L_{ik} + L_{kj})<br>$$</p></li><li><p>最终，当所有的顶点都作为中间点被考虑过之后，我们就能够得到每一对顶点之间的最短路径。</p></li></ol><p><strong>图解</strong>：</p><p>求每A-G点到其余各点的最短路径/距离？<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Floyd算法/blog-20250501183845217.png" alt="image-20241114144607382" style="zoom:80%;" /></p><ol><li><p>在算法进行过程中，重点维护两张表：<strong>距离表</strong>、<strong>前驱表</strong>，初始化如下：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Floyd算法/blog-20250501183857459.png" alt="image-20241114145839072" style="zoom:80%;" /></li><li><p>仅以第一次为例，将A作为中间节点，对两张表进行更新：其中，只更新了B-A-G[23]（经过中间顶点A），<strong>故更新B-G为23</strong>，标黄的B-F[7]比B-A-F[24]小，所以<strong>不更新B-F</strong>。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Floyd算法/blog-20250501183908186.png" alt="image-20241114150317574" style="zoom:67%;" /></li><li><p>真–人工手动跑一遍结果（代码验证无误）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Floyd算法/blog-20250501183918817.png" alt="image-20241114154612640" style="zoom:80%;" /></li></ol><h2 id="代码实现">代码实现</h2><p><code>FloydAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.floyd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">11</span>, N, N, N, <span class="number">13</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">0</span>, <span class="number">10</span>, N, N, <span class="number">7</span>, N&#125;,</span><br><span class="line">                &#123;N, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, N&#125;,</span><br><span class="line">                &#123;N, N, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, N, N&#125;,</span><br><span class="line">                &#123;N, N, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">6</span>, N, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, N, N, N, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex.length,vertex,matrix);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输出某两点的最短路径:&quot;</span>);</span><br><span class="line">        graph.path(<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//输出A到D的最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dis;<span class="comment">//最短路矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] pre;<span class="comment">//前驱矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.dis = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="built_in">this</span>.pre = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.vertex[i] = vertex[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dis[i][j] = matrix[i][j];</span><br><span class="line">                pre[i][j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;距离表为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(dis[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;前驱表为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(pre[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>;k&lt;dis.length;k++)&#123;<span class="comment">//遍历中间节点</span></span><br><span class="line">            <span class="comment">//从i到j  与  从i到k再到j的比较。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;dis.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;dis.length;j++)&#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="keyword">if</span>(len &lt; dis[i][j])&#123;</span><br><span class="line">                        dis[i][j] = len;</span><br><span class="line">                        pre[i][j] = pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">path</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">            System.out.print(vertex[v1] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre[v1][v2] == v1) &#123;</span><br><span class="line">            System.out.print(vertex[v1] + <span class="string">&quot; &quot;</span> + vertex[v2] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path(v1, pre[v1][v2]); <span class="comment">// 递归输出路径</span></span><br><span class="line">            System.out.print(vertex[v2] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>迪杰斯特拉算法</h1><p><strong>算法介绍</strong><br><strong>Dijkstra 算法</strong> 是经典的 <strong>最短路径算法</strong>，用于计算从一个源顶点到图中其他所有顶点的最短路径。它的核心思想是从起始顶点开始，逐步“扩展”到其他顶点，每次选择距离起始顶点最近的未处理顶点，从而逐步找到最短路径。Dijkstra 算法本质上是基于 <strong>贪心算法</strong> 的思想，优先选择当前最短的路径。</p><p><strong>算法过程</strong></p><ol><li><strong>初始化</strong><br>假设我们以顶点 $v$ 作为起始点，图中的顶点集合为 $V = { v_1, v_2, \cdots, v_n }$。<br>初始化一个距离集合 $Dis = { d_1, d_2, \cdots, d_n}$，其中 $d_i$ 表示从起点 $v$ 到顶点 $v_i$ 的当前最短距离。<ul><li>对于起点 $v$，距离为 0，即 $d_v = 0$；</li><li>对于其他顶点，初始距离设置为无穷大（表示还未找到路径）。<br>初始时，所有顶点都没有被访问过，所有的距离值都存储在集合 $Dis$ 中。</li></ul></li><li><strong>选择当前最短的顶点</strong><br>从距离集合 $Dis$ 中选择当前距离最小的顶点 $v_i$，并将其从 $Dis$ 集合中移除。<br>此时，$v$ 到 $v_i$ 的路径就是最短路径。</li><li><strong>更新邻接顶点的距离</strong><br>以 $v_i$ 为中心，更新从 $v$ 到其他尚未访问顶点的距离。<br>对于每个未访问的邻接顶点 $v_j$，我们需要比较：<ul><li>从 $v$ 直接到 $v_j$ 的距离（即$dis[v_j]$）；</li><li>从 $v$ 经由 $v_i$ 到 $v_j$ 的距离（即 $dis[v_i] + \text{weight}[v_i][v_j]$）。<br>如果通过 $v_i$ 的路径更短，就更新 $Dis$ 中对应的距离，并且更新 $v_j$ 的前驱节点为 $v_i$，表示通过 $v_i$ 到达 $v_j$。</li></ul></li><li><strong>重复步骤 2 和 3</strong><br>重复执行步骤 2 和步骤 3，直到所有顶点都被访问过，或者找到了目标顶点的最短路径。</li><li><strong>终止条件</strong><br>当所有顶点都被处理过时，或者当最短路径已经找到（即目标顶点的距离已经确定），算法结束。</li></ol><p><strong>思路总结</strong>：</p><p>Dijkstra 算法通过**逐步“扩展”**最短路径来寻找从源顶点到其他顶点的最短路径。它的核心思想是：<strong>每次选择当前已知的最短路径</strong>，<strong>更新其邻接顶点的路径</strong>，并通过不断重复这一过程，最终得到从起点到所有其他顶点的最短路径。</p><p><strong>题目</strong>：</p><p>求G点到其余各点的最短路径（后一版代码可以更进一步求出具体路径是什么）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Dijkstra算法/blog-20250501183818774.png" alt="image-20241113211412388" style="zoom:80%;" /><h2 id="代码实现-简洁版">代码实现(简洁版)</h2><p><code>DijkstraAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 顶点数组，表示图中的7个顶点</span></span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无限大表示没有连接的边</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 邻接矩阵表示图，0表示自己到自己，其他值表示两点之间的权重</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">            <span class="comment">// A   B   C   D   E   F   G</span></span><br><span class="line">            &#123;<span class="number">0</span>,  <span class="number">10</span>, <span class="number">20</span>, N,  N,  N,  N&#125;, <span class="comment">// A</span></span><br><span class="line">            &#123;<span class="number">10</span>, <span class="number">0</span>,  N, <span class="number">30</span>, <span class="number">50</span>,  N,  N&#125;, <span class="comment">// B</span></span><br><span class="line">            &#123;<span class="number">20</span>, N, <span class="number">0</span>,  N, <span class="number">10</span>,  N,  N&#125;, <span class="comment">// C</span></span><br><span class="line">            &#123;N, <span class="number">30</span>, N, <span class="number">0</span>,  N,  N, <span class="number">60</span>&#125;,  <span class="comment">// D</span></span><br><span class="line">            &#123;N, <span class="number">50</span>, <span class="number">10</span>, N, <span class="number">0</span>,  <span class="number">20</span>, N&#125;,  <span class="comment">// E</span></span><br><span class="line">            &#123;N, N, N, N, <span class="number">20</span>, <span class="number">0</span>,  <span class="number">30</span>&#125;,  <span class="comment">// F</span></span><br><span class="line">            &#123;N, N, N, <span class="number">60</span>, N, <span class="number">30</span>, <span class="number">0</span>&#125;    <span class="comment">// G</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选择源顶点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 从 A（索引 0）开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Dijkstra 算法计算最短路径</span></span><br><span class="line">        dijkstra(matrix, start, vertex.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dijkstra 算法实现</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 邻接矩阵表示的图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexCount 顶点数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> start, <span class="type">int</span> vertexCount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[vertexCount]; <span class="comment">// dist[i]存储从start到i的最短路径</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[vertexCount]; <span class="comment">// visited[i]表示i节点是否已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：所有距离为无穷大，起始节点的距离为0</span></span><br><span class="line">        Arrays.fill(dist, <span class="number">65535</span>); </span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 选择未访问的节点中距离起点最小的节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minDist</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexCount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) &#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    minDist = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果所有节点都已访问，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (u == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记当前节点已访问</span></span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新与当前节点相邻节点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; vertexCount; v++) &#123;</span><br><span class="line">                <span class="comment">// 如果从u到v有路径且v节点未访问过</span></span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != <span class="number">65535</span> &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">newDist</span> <span class="operator">=</span> dist[u] + graph[u][v];</span><br><span class="line">                    <span class="keyword">if</span> (newDist &lt; dist[v]) &#123;</span><br><span class="line">                        dist[v] = newDist; <span class="comment">// 更新最短路径</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印从起始节点到其他节点的最短路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从 &quot;</span> + (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + start) + <span class="string">&quot; 出发的最短路径：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] == <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i) + <span class="string">&quot; 不可达&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i) + <span class="string">&quot; 的最短路径长度为: &quot;</span> + dist[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码实现-封装">代码实现(封装)</h2><p><code>DijkstraAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, N, N, N, N&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">0</span>, N, <span class="number">30</span>, <span class="number">50</span>, N, N&#125;,</span><br><span class="line">                &#123;<span class="number">20</span>, N, <span class="number">0</span>, N, <span class="number">10</span>, N, N&#125;,</span><br><span class="line">                &#123;N, <span class="number">30</span>, N, <span class="number">0</span>, N, N, <span class="number">60</span>&#125;,</span><br><span class="line">                &#123;N, <span class="number">50</span>, <span class="number">10</span>, N, <span class="number">0</span>, <span class="number">20</span>, N&#125;,</span><br><span class="line">                &#123;N, N, N, N, <span class="number">20</span>, <span class="number">0</span>, <span class="number">30</span>&#125;,</span><br><span class="line">                &#123;N, N, N, <span class="number">60</span>, N, <span class="number">30</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertex, matrix);</span><br><span class="line"><span class="comment">//        graph.showGraph();</span></span><br><span class="line">        graph.dijkstra(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        graph.showResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertex;<span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="comment">//里面有三个表：1. 记录已访问过节点的表；2. 前驱节点的下标；3. 已访问的节点到其余节点的距离</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">char</span>[] vertex, <span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertex = vertex;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] m : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dijkstra算法实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 开始顶点（起点）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">VisitedVertex</span>(vertex.length, index);</span><br><span class="line">        update(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">            index = vis.updateArr(); <span class="comment">//选择新的访问顶点</span></span><br><span class="line">            update(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新加入index节点后 的 vis（每一个顶点对应前一个顶点的下标、访问过的顶点到其余顶点的距离）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="comment">//len = 出发顶点到index的距离 + index到j的距离</span></span><br><span class="line">            len = vis.getDis(index) + matrix[index][j];</span><br><span class="line">            <span class="keyword">if</span> (!vis.isVisited(j) &amp;&amp; len &lt; vis.getDis(j)) &#123;</span><br><span class="line">                vis.updatePre(j, index);<span class="comment">//更新j的前驱为j</span></span><br><span class="line">                vis.updateDis(j, len);<span class="comment">//更新出发节点到j的距离为len</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示结果：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showResult</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有顶点是否都已访问过?visted[]为:&quot;</span>+Arrays.toString(vis.visited));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vis.dis.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis.dis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;起点&quot;</span> + vertex[start] + <span class="string">&quot;到其余顶点的最短距离为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            System.out.println(vertex[start] + <span class="string">&quot;-&gt;&quot;</span> + vertex[i] + <span class="string">&quot;(&quot;</span> + vis.dis[i] + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;每个顶点的前驱顶点为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertex.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex[i] != vertex[vis.preVisited[i]]) &#123;</span><br><span class="line">                System.out.println(vertex[i] + <span class="string">&quot;的pre是&quot;</span> + vertex[vis.preVisited[i]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(vertex[i] + <span class="string">&quot;是起始点&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisitedVertex</span> &#123;</span><br><span class="line">    <span class="comment">//记录各个顶点是否被访问过（1访问过，0未访问）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">//每一个点对应的前一个顶点的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preVisited;</span><br><span class="line">    <span class="comment">//记录已访问过的节点到其余节点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexNums 顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index      出发节点下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VisitedVertex</span><span class="params">(<span class="type">int</span> vertexNums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        <span class="built_in">this</span>.preVisited = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        <span class="built_in">this</span>.dis = <span class="keyword">new</span> <span class="title class_">int</span>[vertexNums];</span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        dis[index] = <span class="number">0</span>;</span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preVisited.length; i++) &#123;</span><br><span class="line">            preVisited[i] = i;<span class="comment">//初始化每个顶点的前驱为自己（也就是没有前驱）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVisited</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visited[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDis</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新前驱pre顶点的前驱为index</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePre</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        preVisited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDis</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续选择并返回 下一个 访问结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateArr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; minLen) &#123;</span><br><span class="line">                minLen = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[index] = <span class="number">1</span>;<span class="comment">//更新这个节点被访问过</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal算法</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Kruskal%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Kruskal%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>Kruskal算法</h1><blockquote><p>和Prim算法一样，也是求最小生成树的，先补<a href="##%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>部分知识，对于Kruskal算法的“判断该节点属于哪一类”可以有更深刻的理解。</p></blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184258850.png" alt="image-20241113100012659" style="zoom:80%;" /><p>如上图，给城市的公交站修路，使得所有点连通，同时总路径最小。</p><p><strong>思路</strong></p><ol><li>克鲁斯卡尔算法，是用来求加权连通图的最小生成树的算法。</li><li><strong>基本思想</strong>：按照权值<strong>从小到大</strong>的顺序选择n-1条边，并保证这n-1条边<strong>不构成回路</strong>。</li><li><strong>做法</strong>：<ul><li>将边按权值从小到大排序</li><li>不断将按边的权值从小到大加入森林，同时保证森林中不产生回路，直到选择了n-1条边。</li></ul></li></ol><p><strong>图解</strong></p><ol><li><p>首先有n个顶点，则需选择n-1条边</p></li><li><p>第一步选择<code>E-F[2]</code>边</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184310455.png" alt="image-20241113132132187" style="zoom: 67%;" /></li><li><p>第二步，选择<code>C-D[3]</code>边</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184320565.png" alt="image-20241113132202345" style="zoom: 67%;" /></li><li><p>第三步，选择<code>D-E[4]</code>边</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184330035.png" alt="image-20241113132232489" style="zoom: 67%;" /></li><li><p>第四步，拟选择<code>C-E[5]</code>但是发现构成回路，不能选；拟选择<code>C-F[6]</code>但是发现构成回路，不能选；故选择<code>B-F[7]</code>。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184341650.png" alt="image-20241113132535294" style="zoom: 67%;" /></li><li><p>第五步，选择<code>E-G[8]</code></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184351076.png" alt="image-20241113132631408" style="zoom: 67%;" /></li><li><p>第六步，拟选择<code>F-G[9]</code>构成回路，不能选；拟选择<code>B-C[10]</code>，构成回路，不能选；故选择<code>A-B[11]</code></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184400832.png" alt="image-20241113132754135" style="zoom: 67%;" /></li><li><p>已选择$n-1$，即6条边，最小生成树已生成。最后结果为：<code>E-F[2]</code>、<code>C-D[3]</code>、<code>D-E[4]</code>、<code>B-F[7]</code>、<code>E-G[8]</code>、<code>A-B[11]</code></p></li></ol><p>上述过程中，有两个问题需要解决：</p><ol><li><p>将边按权值从小到大排序，这个易解决</p></li><li><p>每次新加入边时，需判断是否会构成回路，这个要利用<strong>并查集</strong>：</p><ul><li>以下面状态举例：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Kruskal算法/blog-20250501184411676.png" alt="image-20241113132232489" style="zoom: 67%;" /></li><li>此时：<ul><li><code>C</code>的终点节点为<code>F</code></li><li><code>D</code>的终点节点为<code>F</code></li><li><code>E</code>的终点节点为<code>F</code></li><li><code>F</code>的终点节点为<code>F</code></li></ul></li><li>如果新加入的边，其两个节点的终点节点相同，比如<code>C-E[5]</code>，<code>C</code>和<code>E</code>的终点节点都为<code>F</code>，用并查集里面的术语来讲，<code>C</code>与<code>E</code>就是同一树上的节点，此时若连接<code>C</code>与<code>E</code>，则会构成回路。</li></ul><blockquote><p>不懂什么意思就看看<a href="##%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a>这种数据结构。</p></blockquote></li></ol><h2 id="代码实现">代码实现</h2><p><code>KruskalDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kruskal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//此处构造是，自身顶点是0，是跟后续“并查集”的算法有关</span></span><br><span class="line">        <span class="comment">// 即，while(i != 0) &#123; i = ends[i]; &#125;，去找到&quot;根节点&quot;，判断某两条边是否是&quot;同一个集合&quot;，防止回路生成</span></span><br><span class="line">        <span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">11</span>, INF, INF, INF, <span class="number">13</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">                <span class="type">Kruskal</span> <span class="variable">kruskal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kruskal</span>(vertexs, matrix);</span><br><span class="line"><span class="comment">//                kruskal.print();</span></span><br><span class="line">                kruskal.createMinTree();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Kruskal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> edgeNum;<span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] vertexs;<span class="comment">//顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;<span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    Edge[] edges;<span class="comment">//所有边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span>Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">char</span>[] vertexs, <span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vlen</span> <span class="operator">=</span> vertexs.length;</span><br><span class="line">        <span class="built_in">this</span>.vertexs = <span class="keyword">new</span> <span class="title class_">char</span>[vlen];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制拷贝，对外不影响</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vlen; i++)&#123;</span><br><span class="line">            <span class="built_in">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="built_in">this</span>.matrix = <span class="keyword">new</span> <span class="title class_">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">                <span class="built_in">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计边的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != INF)&#123;</span><br><span class="line">                    <span class="built_in">this</span>.edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        edges = getEdges();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Edge[] getEdges()&#123;</span><br><span class="line">        Edge[] edges1 = <span class="keyword">new</span> <span class="title class_">Edge</span>[<span class="built_in">this</span>.edgeNum];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//给边赋值（由于是无向图，只需遍历上三角（不包括自身））</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != INF)&#123;</span><br><span class="line">                    edges1[k++] = <span class="keyword">new</span> <span class="title class_">Edge</span>(vertexs[i],vertexs[j],matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges1);</span><br><span class="line">        <span class="keyword">return</span> edges1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pirnt</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(matrix[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印边，&quot;</span>+<span class="string">&quot;总共&quot;</span>+edges.length+<span class="string">&quot;条边：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">            System.out.println(edges[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对应站点的下标  &#x27;A&#x27; -&gt; 0，找不到则-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">char</span> ch)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vertexs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i] == ch)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下标为i的顶点对应的“终点”节点 对应的下标</span></span><br><span class="line"><span class="comment">     * 用于后续判断，新加入的边是否会造成回路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 记录每个顶点的终点的数组，初始化时，每个顶点的终点都是自身</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 传入的顶点对应下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取下标为i的顶点对应的“终点”对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getEnd</span><span class="params">(<span class="type">int</span>[] ends,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != ends[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> ends[i] = getEnd(ends,ends[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成最小生成树算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMinTree</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[edgeNum];<span class="comment">//用于保存 当前已有边的顶点的集合中 每个顶点的终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ends.length;i++)&#123;<span class="comment">//用并查集的思路，给所有节点的 根节点 设置为其自身，也就是各自为一棵树</span></span><br><span class="line">            ends[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Edge[] result = <span class="keyword">new</span> <span class="title class_">Edge</span>[vertexs.length-<span class="number">1</span>];<span class="comment">//保存最后结果（最后只需顶点数 - 1 条边即可）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//edges是在构造时，已经按照边的权值从小到大拍好的Edge数组</span></span><br><span class="line">        <span class="comment">//对边edges进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edgeNum;i++)&#123;</span><br><span class="line"><span class="comment">//            //优化</span></span><br><span class="line"><span class="comment">//            if(index == vertexs.length)&#123;</span></span><br><span class="line"><span class="comment">//                break;//此时已经能将所有顶点练成最小生成树，后面的边没必要遍历了</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前边的两个顶点的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> getPosition(edges[i].start);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前边两个顶点各自的终点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> getEnd(ends,p1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> getEnd(ends,p2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若没有构成回路</span></span><br><span class="line">            <span class="keyword">if</span>(m != n)&#123;</span><br><span class="line"><span class="comment">//                ends[m] = getEnd(ends,n);//将边m的终点设置为n的终点（做了一个压缩路径！）</span></span><br><span class="line">                ends[m] = n;<span class="comment">//设置m的终点</span></span><br><span class="line">                result[index++] = edges[i];<span class="comment">//有一条边加入结果中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出最小生成树：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            System.out.println(result[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt;&#123;</span><br><span class="line">    <span class="type">char</span> start;<span class="comment">//起点</span></span><br><span class="line">    <span class="type">char</span> end;<span class="comment">//终点</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//权</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">char</span> start, <span class="type">char</span> end, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Edge&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;start=&quot;</span> + start +</span><br><span class="line">                <span class="string">&quot;, end=&quot;</span> + end +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prim算法</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Prim%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/Prim%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>普利姆(Prim)算法</h1><p><strong>实际问题——修路问题</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Prim算法/blog-20250501184507327.png" alt="image-20241112171709616" style="zoom:80%;" /><p>有ABCDEFG七个村庄，修路使得村庄连通，同时要求修路公里数最小，问修路方案。</p><h2 id="最小生成树">最小生成树</h2><p>修路问题本质就是就是最小生成树问题， 先介绍一下<strong>最小生成树(Minimum Cost Spanning Tree)，简称MST</strong>。</p><ol><li><p>给定一个带权的无向连通图,如何选取一棵生成树,使树上<strong>所有边上权的总和为最小</strong>,这叫最小生成树</p></li><li><p>N个顶点，一定有N-1条边</p></li><li><p>包含全部顶点</p></li><li><p>N-1条边都在图中</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Prim算法/blog-20250501184521355.png" alt="image-20241112172040546" style="zoom:80%;" /></li><li><p><strong>求最小生成树</strong>的算法主要是<strong>普里姆算法</strong>和<strong>克鲁斯卡尔算法</strong></p></li></ol><h2 id="普利姆算法介绍">普利姆算法介绍</h2><ol><li><p><strong>普利姆(Prim)算法</strong>求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong></p></li><li><p><strong>算法步骤</strong>：</p><ol><li>设$G=(V,E)$是连通网，$T=(U,D)$是最小生成树，$V,U$是顶点集合，$E,D$是边的集合</li><li>若从顶点$u$开始构造最小生成树，则从集合V中取出顶点$u$放入集合$U$中，标记顶点$v$的$visited[u]=1$</li><li>若集合$U$中顶点$u_i$与集合$V-U$中的顶点$v_j$之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点$v_j$加入集合$U$中，将边$(ui,vj)$加入集合$D$中，标记$visited[vj]=1$</li><li>重复步骤2，直到$U$与$V$相等，即所有顶点都被标记为访问过，此时$D$中有$n-1$条边</li></ol></li><li><p>虽然步骤用了离散数学的术语显得抽象，但是图解很清晰：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Prim算法/blog-20250501184534200.png" alt="image-20241112202738570" style="zoom:80%;" /><p>∴最终修路：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Prim算法/blog-20250501184544097.png" alt="image-20241112203225175" style="zoom:80%;" /></p></li><li><p>为什么这种“<strong>每次  在已访问过的节点的基础上  选取最短的路径加入</strong>”能得到最短总路径呢？仔细想想，是因为修路问题的题目条件是——<strong>每个节点都必须连通</strong>，因此比如一开始选取了G，他就必须要和其他的某个村庄有联系，那么不妨就选取最短的那个，每次都这样找，总的修路路径就是最短的。</p></li></ol><h2 id="代码实现">代码实现</h2><p><code>PrimAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.prim;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlgorithm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">vertexNum</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">char</span>[] villages = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//        int[][] weight = new int[vertexNum][vertexNum];</span></span><br><span class="line">        <span class="type">int</span>[][] weight = &#123;</span><br><span class="line">                &#123;INF, <span class="number">7</span>, <span class="number">7</span>, INF, INF, INF, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, INF, INF, <span class="number">9</span>, INF, INF, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, INF, INF, INF, <span class="number">8</span>, INF, INF&#125;,</span><br><span class="line">                &#123;INF, <span class="number">9</span>, INF, INF, <span class="number">7</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">8</span>, <span class="number">7</span>, INF, <span class="number">7</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;INF, INF, INF, <span class="number">6</span>, <span class="number">7</span>, INF, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">3</span>, INF, INF, <span class="number">4</span>, <span class="number">4</span>, INF&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        for(int i = 0; i &lt; vertexNum; i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 0; j &lt; vertexNum; j++)&#123;</span></span><br><span class="line"><span class="comment">//                weight[i][j] = Integer.MAX_VALUE;//表示此路不通</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//输入各村庄之间的路径：</span></span><br><span class="line">        <span class="comment">//0-6 表示A-G，之后输入对应</span></span><br><span class="line"><span class="comment">//        int v1,v2,len=0;</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;输入地图数据:&quot;);//0 1 7 0 2 7 0 6 6 2 4 8 1 6 3 1 3 9 4 6 4 4 5 7 3 5 6 5 6 4 -1</span></span><br><span class="line"><span class="comment">//        while(true)&#123;</span></span><br><span class="line"><span class="comment">//            v1=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            if(v1 == -1) break;</span></span><br><span class="line"><span class="comment">//            v2=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            len=sc.nextInt();</span></span><br><span class="line"><span class="comment">//            weight[v1][v2] = len;</span></span><br><span class="line"><span class="comment">//            weight[v2][v1] = len;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(vertexNum, villages, weight);</span><br><span class="line"><span class="comment">//        graph.showGraph();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MinTree</span> <span class="variable">minTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinTree</span>();</span><br><span class="line">        minTree.prim(graph, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小生成树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普利姆算法来创建最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     开始构建的顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(Graph graph, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.vertexNum];</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用v1，v2记录两个顶点的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//因为有graph.vertexNum个顶点，所以prim算法结束应该有graph.vertexNum-1条边被记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; graph.vertexNum - <span class="number">1</span>; k++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//其实每一次就是在已访问过的节点的基础上，判断最短的路径并加入</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.vertexNum; i++) &#123;         <span class="comment">//访问过的节点    i</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph.vertexNum; j++) &#123;     <span class="comment">//未访问过的节点   j</span></span><br><span class="line">                    <span class="keyword">if</span> (visited[i] &amp;&amp; !visited[j] &amp;&amp; graph.weight[i][j] &lt; minLen) &#123;</span><br><span class="line">                        minLen = graph.weight[i][j];</span><br><span class="line">                        v1 = i;</span><br><span class="line">                        v2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;修路：&quot;</span> + graph.villages[v1] + <span class="string">&quot;&lt;--&quot;</span> + graph.weight[v1][v2] + <span class="string">&quot;--&gt;&quot;</span> + graph.villages[v2]);</span><br><span class="line">            visited[v1] = <span class="literal">true</span>;</span><br><span class="line">            visited[v2] = <span class="literal">true</span>;</span><br><span class="line">            minLen = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            //其实每一次就是在已访问过的节点的基础上，判断最短的路径并加入</span></span><br><span class="line"><span class="comment">//            for(int i=0;i&lt;graph.vertexNum;i++)&#123;         //访问过的节点    i</span></span><br><span class="line"><span class="comment">//                if(!visited[i])&#123;//找到访问过的节点i</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                for(int j=0;j&lt;graph.vertexNum;j++)&#123;     //未访问过的节点   j</span></span><br><span class="line"><span class="comment">//                    if(visited[j])&#123;//找到未访问过的节点j</span></span><br><span class="line"><span class="comment">//                        continue;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    if(graph.weight[i][j] &lt; minLen)&#123;</span></span><br><span class="line"><span class="comment">//                        minLen = graph.weight[i][j];</span></span><br><span class="line"><span class="comment">//                        v1 = i;</span></span><br><span class="line"><span class="comment">//                        v2 = j;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> vertexNum;<span class="comment">//节点个数</span></span><br><span class="line">    <span class="type">char</span>[] villages;</span><br><span class="line">    <span class="type">int</span>[][] weight;<span class="comment">//带权图</span></span><br><span class="line"></span><br><span class="line">    Graph(<span class="type">int</span> vertexNum, <span class="type">char</span>[] villages, <span class="type">int</span>[][] weight) &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertexNum = vertexNum;</span><br><span class="line">        <span class="built_in">this</span>.villages = villages;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    System.out.println(villages[i] + <span class="string">&quot;&lt;--&quot;</span> + weight[i][j] + <span class="string">&quot;--&gt;&quot;</span> + villages[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合覆盖问题</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>贪心-集合覆盖(简单例子)</h1><p>例子很简单，主要是了解这种思想–<strong>贪心算法</strong>[^11]</p><p><strong>题目</strong>：</p><p>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”, “上海”, “天津”</td></tr><tr><td>K2</td><td>“广州”, “北京”, “深圳”</td></tr><tr><td>K3</td><td>“成都”, “上海”, “杭州”</td></tr><tr><td>K4</td><td>“上海”, “天津”</td></tr><tr><td>K5</td><td>“杭州”, “大连”</td></tr></tbody></table><p><strong>步骤</strong>：</p><ol><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区，但没有关系）</li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1步直到覆盖了全部的地区</li></ol><p><strong>代码</strong>：</p><p><code>GreedyAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.greedy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建广播电台，放入到Map</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">        <span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入到map</span></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allAreas 存放所有地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        allAreas.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        allAreas.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ArrayList 存放所有地区</span></span><br><span class="line">        ArrayList&lt;String&gt; selects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历过程中的电台覆盖的地区和当前还没有覆盖的地区</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            maxKey = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                tempSet.retainAll(allAreas);<span class="comment">//retainAll是取出tempSet和allAreas中公共的，重新赋值给tempSet</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (maxKey == <span class="literal">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="literal">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;选择的电台为&quot;</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>KMP算法</h1><h2 id="暴力匹配法-bad">暴力匹配法(bad)</h2><p>假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p><ol><li>如果当前字符匹配成功（即<code>str1[i] == str2[j]</code>），则<code>i++，j++</code>，继续匹配下一个字符</li><li>如果失配（即<code>str1[i]! = str2[j]</code>），令<code>i = i - (j - 1)，j = 0</code>。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。</li></ol><h2 id="暴力匹配代码实现">暴力匹配代码实现</h2><p><code>ViolenceMatch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolenceMatch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;yukinoYukinoShiTAyukinoYukinoshitaYukino&quot;</span>;<span class="comment">//23</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;YukinoshitaYukino&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> violenceMatch(s1,s2);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力匹配算法实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">violenceMatch</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向s1的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向s2的索引</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有匹配成功</span></span><br><span class="line">                i = i-(j-<span class="number">1</span>);</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==len2)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="KMP算法">KMP算法</h2><p><strong>KMP算法介绍</strong></p><ol><li>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li><li><strong>Knuth-Morris-Pratt 字符串查找算法</strong>，简称为 “<strong>KMP算法</strong>”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法</li><li>KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li><li><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">参考blog</a></li></ol><p><strong>示例-字符串匹配问题</strong></p><ol><li>有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=“ABCDABD”</li><li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li><li>要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法</li></ol><h3 id="详细思路">详细思路</h3><blockquote><p>最详细的见此：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">blog</a></p></blockquote><p>以<code>str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;</code>以及<code>str2 = &quot;ABCDABD&quot;</code>进行举例，判断str1中是否含有str2。</p><ol><li><p>首先，用str1的第一个字符与str2的第一个字符比较，发现不匹配，则关键词后移一位</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501183957359.png" alt="image-20241112093421135" style="zoom:80%;" /></li><li><p>再往后比较，不匹配则一直重复步骤1</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184008287.png" alt="image-20241112093602904" style="zoom:80%;" /></li><li><p>重复步骤1，直到找到str1中和str2的第一个字符匹配（如下：）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184022570.png" alt="image-20241112093800648" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184031989.png" alt="image-20241112093851050" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184041469.png" alt="image-20241112093929032" style="zoom:80%;" /></li><li><p>之后方别移动<code>i</code>和<code>j</code>，比较两个str1与str2的重合度，发现当子串到最后的<code>'D'</code>时与源字符串的<code>' '</code>不匹配</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184051782.png" alt="image-20241112094320306" style="zoom:80%;" /></li><li><p>之后就是与暴力匹配有所区别的地方，不能简单地再让子串第一个字母A与源字符串的’B’、‘C’、‘D’进行比较，这些步骤都是浪费的，因为第4步其实已经比较过&quot;BCD&quot;了，我们知道了子串的第一个字符’A’不可能与’B’、‘C’、'D’匹配上。更准确说，当str1的空格与str2的’D’不匹配时，我们已经遍历过str1中的&quot;ABCDAB&quot;，所以正确地做法是将子串直接移动到下一个’A’的位置，这样子做才能提升搜索效率，而不要再让B与A比较</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184102724.png" alt="image-20241112130246079" style="zoom:80%;" /></li><li><p>怎么样能把这些重复步骤省略呢？我们可以对子串<code>str2</code>计算<strong>部分匹配表</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184113625.png" alt="image-20241112151917543" style="zoom:80%;" /><ul><li>如何得到部分匹配表？</li><li>先介绍<strong>前缀</strong>与<strong>后缀</strong>，例如字符&quot;yukino&quot;，<strong>前缀</strong>就是&quot;y&quot;、“yu”、“yuk”、“yuki”、“yukin”；<strong>后缀</strong>就是&quot;o&quot;、“no”、“ino”、“kino”、“ukino”</li><li><strong>部分匹配值</strong>：一个字符串前缀和后缀共有元素的最大长度，回到&quot;ABCDADB&quot;这个例子：<ul><li>&quot;A&quot;前缀和后缀都为空，所以部分匹配值为0</li><li>“AB&quot;的前缀是&quot;A”，后缀是&quot;B&quot;，所以部分匹配值为0</li><li>“ABC&quot;的前缀是&quot;A”、“AB”，后缀是&quot;B&quot;、“BC”，所以部分匹配值为0</li><li>“ABCD&quot;的前缀是&quot;A”、“AB”、“ABC”，后缀是&quot;D&quot;、“CD”、“BCD”，所以部分匹配值为0</li><li>“ABCDA&quot;的前缀是&quot;<strong>A</strong>”、“AB”、“ABC”、“ABCD”，后缀是&quot;<strong>A</strong>&quot;、“DA”、“CDA”、“BCDA”，所以部分匹配值为1</li><li>“ABCDAB&quot;的前缀是&quot;A”、“<strong>AB</strong>”、“ABC”、“ABCD”、“ABCDA”，后缀是&quot;B&quot;、“<strong>AB</strong>”、“DAB”、“CDAB”、“BCDAB”，所以部分匹配值为2</li><li>同理，&quot;ABCDABD&quot;的部分匹配值为0</li></ul></li><li>这样就能从理论层面，知道如何得到部分匹配值表。（关键是看代码怎么实现——利用<code>next</code>数组）</li></ul></li><li><p>那么这个表怎么用呢？回到刚才str1中的空格与str2中的D不匹配的时刻，此时前六个字符&quot;ABCDAB&quot;是匹配的，最后一个字符&quot;B&quot;对应的&quot;部分匹配值&quot;为2，因此按照如下公式移动步数：<br>$$<br>移动位数=已匹配的字符数-部分匹配值<br>$$<br>因此此时移动的步数为：$6-2=4$步，如下所示：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184124459.png" alt="image-20241112131045712" style="zoom:80%;" /></li><li><p>下一次发现，空格与字符C又不匹配，同样根据公式计算，需移动$2(已匹配字符数)-0(第一个字符’B’所对应的部分匹配值)=2$步：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184134958.png" alt="image-20241112131333017" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184147716.png" alt="image-20241112131418061" style="zoom:80%;" /></li><li><p>后续步骤同理，不再说明，下图匹配成功。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/KMP算法/blog-20250501184158779.png" alt="image-20241112131807060" style="zoom:80%;" /></li><li><p>至此也理解了这个移动的公式的妙处，但是如何用代码实现？（利用<code>next</code>数组）</p></li></ol><p><strong>代码思路总结</strong>：</p><ol><li>获得子串的部分匹配值表<code>next</code></li><li>使用部分匹配值表完成kmp搜索</li></ol><h3 id="代码实现">代码实现</h3><p><code>KMP</code></p><p>ps：核心的就是两个方法——<code>kmpNext</code>求出子串的部分匹配表，<code>kmpSearch</code>kmp搜索。其中最最核心的，分别是这两个方法中的<code>while</code>语句，是如何处理<code>j</code>的更新的！两个方法中的<code>i</code>和<code>j</code>含义各有不同。至于为什么<code>j = next[j-1]</code>，则见博客底层原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.kmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = kmpNext(str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;部分匹配值表：&quot;</span>+Arrays.toString(next));</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配的第一个下标为：&quot;</span>+kmpSearch(str1,str2,next));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kmp搜索算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个匹配的位置，否则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String str1, String str2, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理str1.charAt(i)!=str2.charAt(j)的情况，去调整j的大小</span></span><br><span class="line">            <span class="comment">//KMP算法核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子串的部分匹配表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String str) &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//如果字符串长度为1，部分匹配值一定是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当str.charAt(i) != str.charAt(j)时，需要从next[j-1]获取新的j</span></span><br><span class="line">            <span class="comment">//直到我们发现有 str.charAt(i) == str.charAt(j) 成立时才退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心……</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) != str.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当str.charAt(i) == str.charAt(j)时，部分匹配值就是+1</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == str.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>背包问题</h1><p>在解决 <strong>0-1 背包问题</strong>时，我们的目标是选择若干物品放入背包，使得背包内物品的总价值最大，同时遵循背包容量的限制。具体来说，给定一组物品，每个物品都有一个 <strong>重量</strong> 和 <strong>价值</strong>，并且背包的容量也是有限的。我们需要从这些物品中选择一些，放入容量有限的背包中，要求背包内物品的 <strong>总重量不超过背包的容量</strong>，而 <strong>总价值最大</strong>。</p><p><strong>0-1 背包的动态规划解法</strong>：</p><ol><li>设有 $n$个物品，每个物品 $i $的 <strong>价值</strong> 为 $ v[i]$，<strong>重量</strong> 为 $w[i]$，背包的最大容量为 $C$。</li><li>定义一个二维数组 $ dp[i][j] $，表示考虑前 $ i $ 个物品，背包容量为 $j $ 时，能够获得的最大价值。即$ dp[i][j] $ 是当前背包容量 $j $ 和物品选择方案下的最大价值。</li></ol><p><strong>递推公式</strong>：</p><ul><li><p><strong>初始化</strong>：</p><ul><li>$dp[0][j] = 0  $（表示没有物品时，背包的最大价值为 0）</li><li>$dp[i][0] = 0 $（表示背包容量为 0 时，无论选择哪些物品，总价值也为 0）</li></ul></li><li><p><strong>状态转移</strong>：<br>对于每个物品 $ i $和每个容量 $j$：</p><ul><li><p><strong>如果当前物品的重量</strong> $w[i] &gt; j$（即当前背包容量不足以容纳这个物品），那么不能放入该物品，此时的最优解就是不放物品 $i$，即：<br>$dp[i][j] = dp[i-1][j]$</p></li><li><p><strong>如果当前物品的重量</strong> $w[i] \leq j$（即背包容量足够容纳当前物品），有两种选择：</p><ol><li>不选择物品 $i $，此时的最优解为 $dp[i-1][j] $（即与不放入该物品时的情况一样）。</li><li>选择物品 $ i $，此时的最优解为物品 $ i $ 的价值加上剩余容量 $j - w[i] $ 能容纳的最大价值，即 $dp[i-1][j - w[i]] + v[i] $。</li></ol><p>这时我们需要取两者中的最大值：<br>$$<br>dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])<br>$$</p></li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>$ dp[i][j] $ 表示在考虑前 $ i $ 个物品、容量为 $ j $ 的背包时，能够获得的最大价值。</li><li>对于每个物品 $ i $，如果它的重量 $ w[i] $ 超过当前背包容量 $ j $，就不能选它；否则，我们就要在 <strong>选择它</strong> 或 <strong>不选择它</strong> 之间做出最优决策，选择价值更大的方案。</li></ul><p><strong>完整算法</strong>：</p><ol><li>初始化 $ dp[0][j] = 0 $ 和 $ dp[i][0] = 0 $。</li><li>对每个物品 $ i $ 和每个背包容量 $ j $ 更新 $ dp[i][j] $。</li><li>最终答案就是 $ dp[n][C] $，表示在所有 $ n $ 个物品和容量为 $ C $ 的背包情况下，能够获得的最大价值。</li></ol><p><strong>图解</strong></p><ol><li><p><code>weights</code>物品重量、<code>values</code>物品价值、<code>dp</code>用于求解的数组（初始化如下）（黄色部分是未来求解区）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/背包问题/blog-20250501183319480.png" alt="image-20241114134226051" style="zoom:80%;" /></li><li><p>当考虑第一件物品时：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/背包问题/blog-20250501183330273.png" alt="image-20241114134455411" style="zoom:80%;" /></li><li><p>考虑第二件物品时：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/背包问题/blog-20250501183344517.png" alt="image-20241114134526878" style="zoom:80%;" /></li><li><p>考虑第三件物品：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/背包问题/blog-20250501183355229.png" alt="image-20241114135349739" style="zoom:80%;" /></li></ol><h2 id="代码实现">代码实现</h2><p><code>KnapsackProblem</code></p><blockquote><p><strong>空间优化</strong>：可以通过只使用一维数组来优化空间复杂度。因为每一行的状态仅依赖于前一行的状态。（拓展）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.dynamicProgramming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 物品的重量</span></span><br><span class="line">        <span class="type">int</span>[] weights = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 物品的价值</span></span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 物品数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numItems</span> <span class="operator">=</span> weights.length;</span><br><span class="line">        <span class="comment">// 背包容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示考虑前 i 个物品，背包容量为 j 时能够获得的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[numItems + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了记录被放入背包的商品，定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] path = <span class="keyword">new</span> <span class="title class_">int</span>[numItems + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划求解最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= numItems; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weights[i - <span class="number">1</span>] &gt; j) &#123; <span class="comment">// 当前背包容量不足以放入物品 i</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果放入当前物品 i 会得到更大的价值，更新 dp[i][j] 和 path</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt; dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>];</span><br><span class="line">                        path[i][j] = <span class="number">1</span>; <span class="comment">// 记录当前物品 i 被放入背包</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 dp 数组，查看每个容量下的最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(row));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最大能够装入的价值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最大能装的价值为：&quot;</span> + dp[numItems][capacity]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出放入背包的物品</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> numItems;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> capacity;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入背包\n&quot;</span>, i);</span><br><span class="line">                j -= weights[i - <span class="number">1</span>]; <span class="comment">// 剩余背包容量</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 遍历前一个物品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>汉诺塔问题</h1><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><strong>思路</strong>：</p><p>如果是有一个盘， A-&gt;C</p><p>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘——<strong>一是最下边的盘</strong>，<strong>二是上面的其余所有盘</strong></p><ol><li>先把 最上面的盘 A-&gt;B，中间需借助C盘，即<code>hanoiTower(num-1,a,c,b)</code></li><li>再把最下边的盘 A-&gt;C，<code>System.out.println(&quot;第&quot;+num+&quot;个盘从 &quot;+&quot;A-&gt;C&quot;)</code></li><li>最后把B塔的所有盘 从 B-&gt;C，中间需借助A盘，即<code>hanoiTower(num-1,b,a,c)</code></li></ol><h2 id="代码实现">代码实现</h2><p><code>HanoiTower</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.hanoitower;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiTower</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用分治算法解决汉诺塔问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoiTower</span><span class="params">(<span class="type">int</span> num,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果num &gt;= 2，我们总是可以看两个盘：1最下面的盘 和 上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把 上面的盘从A移动到B，移动过程会使用到C</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">            <span class="comment">//2. 再把 最下面的盘从A移动到C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+num+<span class="string">&quot;个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">            <span class="comment">//3. 把 B中所有盘移动到C，移动过程使用到A</span></span><br><span class="line">            hanoiTower(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度优先搜索</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1>广度优先搜索（BFS）</h1><p>图的广度优先搜索(Broad First Search) 。类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p><p><strong>广度优先遍历算法步骤</strong></p><ol><li>访问初始结点v并标记结点v为已访问。</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束。</li><li>出队列，取得队头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol><li>若结点w尚未被访问，则访问结点w并标记为已访问。</li><li>结点w入队列</li><li>查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol></li></ol><p><strong>广度优先搜索抽象图解</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/广度优先搜索/blog-20250501183430473.png" alt="image-20241114115852877" style="zoom: 80%;" /><h2 id="代码实现">代码实现</h2><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//记录某个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有节点（确保所有点都被访问）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                bfs(vis,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对一个结点进行广度优先遍历的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">boolean</span>[] vis, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> u;<span class="comment">//表示队列的头节点对应下标</span></span><br><span class="line">        <span class="type">int</span> w;<span class="comment">//邻接节点w</span></span><br><span class="line">        <span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="comment">//访问结点，输出结点信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//将这个结点加入队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列的头节点下标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接节点的下标</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">if</span> (!vis[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">                    vis[w] = <span class="literal">true</span>;</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱，找w后面的下一个邻接节点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （？存疑）根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 上一个节点的行号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 上一个节点的列号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点在vertexList的下标j，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个邻接节点的下标，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1>深度优先搜索（DFS）</h1><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)<strong>深度优先遍历</strong> (2)<strong>广度优先遍历</strong></p><p><strong>图的深度优先搜索</strong>（<strong>Depth First Search</strong>）</p><ol><li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li><li>显然，深度优先搜索是一个递归的过程</li></ol><p><strong>算法步骤</strong></p><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><p><strong>深度优先遍历抽象图解</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/深度优先搜索/blog-20250501183733242.png" alt="image-20241114115759159" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><p>以此为例：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/深度优先搜索/blog-20250501183745163.png" alt="image-20241111093246143" style="zoom:80%;" /><p>从A开始遍历，遍历所有节点</p><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//记录某个顶点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (String vertex : Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        graph.dfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对dfs重载，遍历所有节点，进行dfs（确保了所有点能被访问到）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++)&#123;</span><br><span class="line">            dfs(vis, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从某一个节点开始，进行深度优先搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] visited, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//查找节点i的第一个邻接节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">//说明有下一个邻接节点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;<span class="comment">//再加上没有被访问过</span></span><br><span class="line">                dfs(visited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w节点已经被访问过，得找下一个</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （？存疑）根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 上一个节点的行号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 上一个节点的列号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点在vertexList的下标j，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接节点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个邻接节点的下标，没有则-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契查找</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>斐波那契查找算法（黄金分割法）</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong>：</p><ol><li><strong>黄金分割</strong>点是指将一条线段分成两段，使其中一部分与全长的比例等于另一部分与这部分之比，近似值$0.618$。</li><li><strong>斐波那契数列</strong>${1,1,2,3,5,8,13,21,34,55}$，发现斐波那契数列两个相邻数的比例无限接近于黄金分割0.618。<ul><li>ps：$fibo[n]=fibo[n-1]+fibo[n-2],n&gt;2;fibo[1]=fibo[2]=1$</li></ul></li></ol><p><strong>原理</strong>：</p><p><strong>斐波那契查找</strong>和<strong>二分查找</strong>、<strong>插值查找</strong>很像，仅仅改变了中间结点<code>mid</code>，即$mid = low+F(k-1)-1$</p><p>对于$F(k-1)-1$的理解：(结合图进行理解！)</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/斐波那契查找/blog-20250501183252432.png" alt="image-20241102174615812" style="zoom:80%;" /><ol><li><p>由斐波那契数列$F[k]=F[k-1]+F[k-2]$的性质，可以得到$(F[k]-1) = (F[k-1]-1)+(F[k-2]-1)+1$，这里把<strong>每一个括号</strong>看成一个整体，对应上图的三个部分！可见等式右边的<code>+1</code>就是<code>mid</code>。即：<code>mid = low + F(k-1)-1</code></p></li><li><p>类似的，每一个子段也可以照此方式进行分割</p></li><li><p>但顺序表长度n不一定刚好等于$F[k]-1$，所以需要将原来的顺序表长度n增加至$F[k]-1$。这里的k值只要能使得$F[k]-1$大于等于n即可，由<code>while(n&gt;fib(k)-1) k++</code>得到k值。顺序表长度增加后，新增的位置<code>n+1到fib[k]-1</code>都赋值为n位置的值即可。</p></li></ol><blockquote><p>第三点相对不好理解，结合代码来看吧。</p></blockquote><h2 id="代码实现">代码实现</h2><blockquote><p>代码实现一定要多看多理解，不是那种光看理论就能立刻想出来对应代码的算法</p></blockquote><p><code>FibonacciSearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">520</span>, <span class="number">1000</span>, <span class="number">1234</span>,&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span>+fibSearch(arr,<span class="number">89</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归方式得到一个fibonacci数列数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib() &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契查找算法</span></span><br><span class="line"><span class="comment">     * 使用非递归方式编写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 需要查找的关键码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，没有则返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] f = fib();</span><br><span class="line">        <span class="comment">//获取到k值</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k]的值可能大于arr的长度，因此使用Arrays类，构造一个新的数组，指向arr[]</span></span><br><span class="line">        <span class="comment">//不足的部分用0补足</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">        <span class="comment">//新填充的部分用原数组的最后一个元素补齐</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">// 说明应该继续向左边查找</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//k--的说明：</span></span><br><span class="line">                <span class="comment">//全部元素 = 前面元素 + 后面元素</span></span><br><span class="line">                <span class="comment">//f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为前面有f[k-1]个元素</span></span><br><span class="line">                <span class="comment">//所以k--，相当于下次是对前面的、大小为f[k-1]的数组操作</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp[mid]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//k -=2的说明：</span></span><br><span class="line">                <span class="comment">//全部元素 = 前面元素 + 后面元素</span></span><br><span class="line">                <span class="comment">//f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为后面有f[k-2]个元素</span></span><br><span class="line">                <span class="comment">//所以k-=2，相当于下次是对后面的、大小为f[k-2]的数组操作</span></span><br><span class="line">                k -=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//但需要确定返回的是哪个</span></span><br><span class="line">                <span class="keyword">if</span>(mid&lt;=high)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值查找</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>插值查找</h1><h2 id="思路分析">思路分析</h2><p><strong>原理介绍</strong>：</p><ol><li>插值查找类似于二分查找，不同的是插值查找每次从<strong>自适应mid</strong>处开始查找。</li><li>将折半查找中的求mid的公式进行了改进如下：</li></ol><p>$$<br>mid = \frac{low+high}{2}=low+\frac{1}{2}(high-low) \quad =&gt; \quad mid=low+\frac{key-a[low]}{a[high]-a[low]}(high-low)<br>$$</p><ul><li>说明：low相当于left，high相当于right，key就是要找的值targetVal</li></ul><ol start="3"><li>插值查找求mid代码为：<code>int midIndex = low + (high - low)*(key - a[low])/(a[high] - a[low])</code></li><li>相当于之前的$\frac{1}{2}$变成了与要查找的值有关的系数。改进了二分查找的：<code>int mid = left + (right - left)</code></li></ol><p><strong>图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/插值查找/blog-20250501183142214.png" alt="image-20241102171312731" style="zoom:80%;" /><blockquote><p>最精髓的地方在于自适应的mid</p></blockquote><p><strong>注意事项</strong>：</p><ol><li>对于数据量较大，<strong>关键字分布较均匀</strong>的查找表来说，采用<strong>插值查找</strong>，<strong>速度较快</strong>。</li><li>关键字分布不均的情况下，该方法不一定比二分查找要好。</li></ol><h2 id="代码实现">代码实现</h2><p><code>InsertValueSearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> insertValueSearch(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,target);</span><br><span class="line">        System.out.println(<span class="string">&quot;查找的目标值&quot;</span>+target+<span class="string">&quot;的下标为：&quot;</span>+index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertValueSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//说明：target &lt; arr[0] || target &gt; arr[arr.length - 1]必须需要！</span></span><br><span class="line">        <span class="comment">//否则得到的mid值可能越界！(会导致某条语句出错……)</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || target &lt; arr[<span class="number">0</span>] || target &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求mid的公式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (target - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (target &gt; midVal) &#123;</span><br><span class="line">            res = insertValueSearch(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; midVal) &#123;</span><br><span class="line">            res = insertValueSearch(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1>二分查找(经典)</h1><h2 id="思路分析">思路分析</h2><ol><li>首先确定该数组中间元素的下标<code>mid = (l+r)/2</code></li><li>然后让要查找的目标值与中间值比对<ul><li>如果<code>targetVal &gt; arr[mid]</code>，则说明要查找的值在右边，需要<strong>递归</strong>向右查询</li><li>如果<code>targetVal &lt; arr[mid]</code>，则说明要查找的值在左边，需要<strong>递归</strong>向左查询</li><li>如果<code>targetVal == arr[mid]</code>，已找到目标值</li></ul></li><li>什么时候需要退出递归？<ul><li>找到就结束递归</li><li>遍历完整个数组都没找到，即<code>left&gt;right</code>时</li></ul></li></ol><p><strong>图解演示找不到的情况</strong>:</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/二分查找/blog-20250501183204927.png" alt="image-20241101205538157" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/二分查找/blog-20250501183215893.png" alt="image-20241101205646047" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/二分查找/blog-20250501183225564.png" alt="image-20241101205747596" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><h3 id="递归实现1">递归实现1</h3><blockquote><p>查找返回一个符合条件的值</p></blockquote><p><code>BinarySearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用二分的前提：数组有序(ASC or DESC)</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">53</span>, <span class="number">84</span>, <span class="number">190</span>, <span class="number">201</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (targetIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;目标值%d的下标为：%d\n&quot;</span>, target, targetIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到该值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">            targetIndex = binarySearch(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; arr[mid]) &#123;</span><br><span class="line">            targetIndex = binarySearch(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetIndex = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> targetIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归实现2">递归实现2</h3><blockquote><p>上述算法实现仅能返回一个符合条件的目标值的下标，下面进行修改</p></blockquote><p>修改思路为：</p><p>当二分查找内部进入<code>else</code>语句时，说明已经找了了某个值，后续就是return语句。</p><p>所以我们可以在else中：先将mid加入到list中，再向左、右邻近元素查询，若还有目标值就加入，方法返回类型也改为List。</p><p>下面是核心部分修改：</p><p><code>方法binarySearch2()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//说明左边已经没有target了</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt;= arr.length || arr[temp] != target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非递归实现">非递归实现</h3><p><code>BinarySearch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.binarySearchNoRecur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchNoRecur</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找下标为：&quot;</span>+binarySearch(arr,<span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>堆排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong></p><ol><li>堆排序是利用堆这种数据结构设计的一种算法，堆排序是一种选择排序，最坏、最好、平均时间复杂度为$0(n\log n)$，是不稳定排序。</li><li>堆是具有以下性质的<strong>完全二叉树</strong>：每个节点的值都大于等于其左右子节点的值，成为<strong>大顶堆</strong>；每个节点的值都小于等于其左右子节点的值，成为<strong>小顶堆</strong>。</li><li>大顶堆<strong>图解</strong>，以及其映射到数组的形式（前有讲<a href="###%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a>）。</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180722901.png" alt="image-20241104200655911" style="zoom:80%;" /><ol start="4"><li>一般升序用大顶堆，降序用小顶堆。</li></ol><blockquote><p>代码实现上：化为大顶堆形式后，通过将root<strong>沉底</strong>的方式，将最大元素放到数组末尾</p></blockquote><p><strong>基本思想</strong></p><p>若要完成升序排序，采用大顶堆：</p><ol><li>将待排序序列构成一个<strong>大顶堆</strong>（数组形式）。</li><li>此时，序列最大值就是堆顶的根节点。</li><li>将其与末尾元素进行<strong>交换</strong>，此时末尾就成为最大元素。</li><li>然后将剩余$n-1$个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</li></ol><blockquote><p>可见在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列。</p><blockquote><p>上述过程，初见，抽象。图解：</p></blockquote></blockquote><h3 id="思路分析（清晰版）">思路分析（清晰版）</h3><p><strong>构造大根堆图解</strong>：</p><blockquote><p>如果不能看懂，移步原文-&gt;菜鸟教程：<a href="https://www.runoob.com/data-structures/heap-storage.html">堆的基本存储</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-shift-up.html">堆的shift up</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-shift-down.html">堆的shift down</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-sort.html">基础堆排序</a>-&gt;<a href="https://www.runoob.com/data-structures/heap-sort-optimization.html">优化堆排序</a></p></blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180736783.png" alt="image-20241105185854553" style="zoom:80%;" /><ol><li>上图为初始状态，首先利用完全二叉树的性质，得到<strong>第一个非叶子节点</strong>的位置——<code>k = arr.length/2</code>，也就是下标为5，值为22的节点（二叉树只是为了便于理解，实际存储方式是顺序），上图可见：只要<code>1&lt;=i&lt;=5</code>这个范围内的，都需要进行调整。目前这一步先对5这棵子树进行<strong>调整</strong>。</li></ol><ul><li><blockquote><p>调整：对应<a href="https://www.runoob.com/data-structures/heap-shift-down.html">堆的shift up</a>，这里简单说明一下：</p><p>比较当前节点与其左右子节点的大小关系，找到最大的那个与当前节点交换（这里是5号与10号进行交换）</p></blockquote></li></ul><ol start="2"><li>第一步调整完结果如下。提示：节点标绿表示不需要再被操作的节点，标红表示当前要继续操作的节点：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180753119.png" alt="image-20241105190611082" style="zoom:80%;" /><ol start="3"><li>同样道理的，对4号节点进行同样的<strong>调整</strong>。需要将4号与9号交换位置。</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180805455.png" alt="image-20241105190918145" style="zoom:80%;" /><ol start="4"><li>对3号操作，需要将3号与7号交换：（原图没标绿……手动标一下……）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180819527.png" alt="image-20241105191115658" style="zoom:80%;" /><ol start="4"><li>对2号操作，将2号于5号交换：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180833603.png" alt="image-20241105191218231" style="zoom:80%;" /><ol start="5"><li>最后对1号，也就是根节点进行调整，实现了一个大顶堆：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180847848.png" alt="image-20241105191311699" style="zoom:80%;" /><p><strong>思路对应代码部分</strong>：</p><p>上述思路的<strong>调整</strong>，对应代码的<code>adjustHeap</code>方法，</p><p>而对于<strong>从第一个非叶子节点处理到根节点</strong>的代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="comment">//调整操作</span></span><br><span class="line">    adjustHeap(arr,i,arr,length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上述过程调整为一个大顶堆的操作应该能理解了，但最终目的还是为了实现对整个数组的<strong>升序排序</strong>，大顶堆只是这个过程用到的工具。</p><p>后续操作参考<a href="https://www.runoob.com/data-structures/heap-sort-optimization.html">优化堆排序</a>。将堆顶最大元素与末尾元素交换，但是此时破坏了大顶堆的结构，我们可以利用已写好的<code>adjustHeap</code>方法，从上至下，可以对照二叉树来看，也可以看数组：</p><p>注意：</p><p>代码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j= arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp = arr[j];<span class="comment">//将底部元素与顶部元素交换</span></span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们每交换一次首尾，仅使用一次<code>adjustHeap</code>就可以把整个结构重新调整回大顶堆，理由是：交换完最大元素和末尾元素后，整个结构本身就是很有序的，换句话说，除了根节点，其他的子树都符合&quot;大顶堆&quot;的结构（父节点大于其左右子节点）。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/堆排序/blog-20250501180901534.png" alt="image-20241105192344775" style="zoom:80%;" /><blockquote><p>至此，解释完了所有的代码，再不理解，就静下来慢慢看，或者看看别的文章（这些文章我还没看，虽然都找了，但是光看菜鸟就看懂了<a href="https://blog.csdn.net/u010452388/article/details/81283998">博客1</a>、<a href="https://zhuanlan.zhihu.com/p/124885051">博客2</a>、<a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">博客3</a>），或者代码debug看看，或者画图一步步走下去，或者……</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>1</td></tr><tr><td>50000</td><td>5</td></tr><tr><td>80000</td><td>8</td></tr><tr><td>140000</td><td>13</td></tr><tr><td>500000</td><td>46</td></tr><tr><td>900000</td><td>83</td></tr></tbody></table><p><code>HeapSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分步演示：</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,1,arr.length);</span></span><br><span class="line"><span class="comment">//        adjustHeap(arr,0,arr.length);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp = arr[j];<span class="comment">//将底部元素与顶部元素交换</span></span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将以i对应的非叶子节点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子节点在数组中索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素进行调整,length逐渐减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//k=2*i+1 是指节点i的左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//左子节点小于右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;<span class="comment">//子节点大于父节点</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;<span class="comment">//i变为k，继续循环比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环结束，已经将以i为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp放到调整后的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>基数排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>介绍</strong>：</p><p>基数排序是一种<strong>非比较型整数排序算法</strong>，其原理是将整数按位数<strong>切割</strong>成不同的数字，然后<strong>按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。–<a href="https://www.runoob.com/w3cnote/radix-sort.html">菜鸟教程</a></p><p><strong>基本思想</strong>:</p><p>将所有待比较数值统一为同样的数值长度，数位较短的前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成后，数据序列就变有序了。</p><blockquote><p>LSD(最低位优先)基数排序思想↑，另有MSD(最高位优先)实现方式。参考<a href="https://blog.csdn.net/m0_64003319/article/details/134540648">blog</a>。</p></blockquote><p><strong>图解</strong>（非常好の图）：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/基数排序/blog-20250501181308737.png" alt="image-20241101173253304" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/基数排序/blog-20250501181321623.png" alt="image-20241101173316664" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/基数排序/blog-20250501181332742.png" alt="image-20241101173347735" style="zoom:80%;" /><p><strong>代码思路</strong>：</p><ol><li>关于上面桶如何表示？用一个二维数组<code>int[][] bucket = new int[10][?]</code>，？处要填<code>arr.length</code>，防止数据溢出。</li><li>所以基数排序就是<strong>空间换时间</strong>的经典算法。</li><li>在某轮取数据时，我们怎么知道要从某个桶中取几个数？因此需要有一个方法，告诉我们<strong>每个桶中有几个数据</strong>。</li><li>因此定义一个一维数组``，表示每轮10个桶中的有效数据个数。</li></ol><blockquote><p>可以形象地表示为不断把元素<strong>放入桶中</strong>，再<strong>从桶中取出</strong>的过程。这样一放一取要执行<code>maxLength</code>轮（<code>maxLength</code>为最高位数长度）</p></blockquote><p><strong>小结</strong>：</p><p>速度快+稳定，但是空间耗费巨大。</p><blockquote><p>特别注意：基数排序只适用于正数的情况（问题出在去<code>maxLength</code>那里，不能有负数）。</p><p>额外的<strong>解决方案</strong>[^6]有两个：<a href="###%E5%81%8F%E7%A7%BB%E6%B3%95">偏移法</a>或<a href="###%E5%88%86%E5%BC%80%E5%A4%84%E7%90%86">分开处理</a>（正数与负数），可跳转见补充方案详解</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>2</td></tr><tr><td>50000</td><td>3</td></tr><tr><td>80000</td><td>10</td></tr><tr><td>140000</td><td>14</td></tr><tr><td>500000</td><td>35</td></tr><tr><td>900000</td><td>35</td></tr></tbody></table><p><code>RadixSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取最大位数!</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; arr[i]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();<span class="comment">//少女口阿！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//放入桶中的过程</span></span><br><span class="line">            <span class="comment">//对arr中每个元素遍历，取出其第i位数放入对应桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">                bucketCounts[digit]++;<span class="comment">//用于记录第digit个桶中元素的个数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从桶中取出的过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;<span class="comment">//从桶中取出的过程</span></span><br><span class="line">                <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;<span class="comment">//若第j个桶不为空</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                        arr[index++] = buckets[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//从这个桶中取出元素后，一定要清零!bucketCounts[j] = 0</span></span><br><span class="line">                    bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        radixSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>归并排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>归并排序是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的分治[^5]策略。</p><p><strong>图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/归并排序/blog-20250501181013324.png" alt="image-20241101153840659" style="zoom:80%;" /><p><strong>代码流程图</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/归并排序/blog-20250501181116118.jpeg" alt="image-20241101153840659" style="zoom:80%;" /><p><strong>提示+代码思路</strong>：</p><ol><li>归并排序执行次数为<code>N-1</code>次，N为数据量大小，即<code>merge</code>方法执行的次数。</li><li>由图解可知，我们需要完成“<strong>分</strong>”和“<strong>治</strong>”两个步骤：<ul><li>治，也就是合并<code>merge</code>的过程</li><li>merge需要参数为——int[] arr、left、right、mid、int[] temp</li><li><code>arr</code>为原数组</li><li><code>left</code>为待合并数据的左边位置、<code>right</code>为待合并数据的右边位置</li><li><code>mid=(left+right)/2</code></li><li><code>temp</code>为临时数组<ol><li>merge是是对两个有序数组合并的过程（见红色箭头），单个元素的数组无疑是有序的。</li><li>合并时，需要有一个i、j分别代表左数组和右数组，依次比较，将小的那个元素放入到临时数组temp中</li><li>然后将左（或右）数组中剩余元素放入到temp中</li><li>最后将temp中元素拷贝到arr中</li></ol></li><li>分，也就是不断将大问题化为小问题的过程：</li><li>如果传入参数<code>left&lt;right</code>，就不断向左、右递归，进行拆分。<ol><li>对<code>mergeSort</code>进行左右递归即可：</li><li><code>mergeSort(arr,left,mid,temp)</code></li><li><code>mergeSort(arr,mid+1,right,temp)</code></li><li><code>merge(left,right)</code></li></ol></li></ul></li></ol><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>2</td></tr><tr><td>50000</td><td>7</td></tr><tr><td>80000</td><td>18</td></tr><tr><td>140000</td><td>22</td></tr><tr><td>500000</td><td>57</td></tr><tr><td>900000</td><td>93</td></tr></tbody></table><p><code>MergeSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];<span class="comment">//需要一个额外的空间开销</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);<span class="comment">//向左递归--分</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//向右递归--分</span></span><br><span class="line">            merge(arr, left, right, mid, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;<span class="comment">//左边有序数组索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;<span class="comment">//右边有序数组索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//临时数组temp所指</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个有序数组比较、放入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将其中一个剩余的放入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将temp拷贝到arr</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= right) &#123;</span><br><span class="line">            arr[k++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">900000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>快速排序(经典)</h1><blockquote><p>实现1参考了<a href="https://blog.csdn.net/qq_39181839/article/details/109478094">博客</a>，快排讲得很清晰，看完思路代码容易自己写出来。(开头给出的<strong>各类排序算法的总结图</strong>真的很好！)</p><p>实现2参考了atguigu<a href="https://www.bilibili.com/video/BV1E4411H73v/?spm_id_from=333.788.videopod.episodes&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=67">视频</a>，代码部分稍难理解，if条件判断过多，重要的是，代码不美观。</p><p>另外还有一篇<a href="https://blog.csdn.net/justidle/article/details/104203963">博客</a>提到了<strong>原地排序</strong>和<strong>非原地排序</strong>的概念，涉及到空间复杂度，有空了解一下。</p></blockquote><h2 id="思路分析">思路分析</h2><p>快速排序是对冒泡排序的一种改进。有分治[^5]思想</p><p><strong>基本思想</strong>为：</p><p>通过一趟排序将待排序元素<strong>分割</strong>成独立的两个部分，其中<strong>一部分的所有数据要比另一部分的所有数据要小</strong>，然后再按此方法对这两部分分别进行快速排序，整个排序过程可以<strong>递归</strong>进行，以此使得所有数据变成有序序列。</p><blockquote><p>但是光凭这个基本思想还没法写出代码</p></blockquote><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>1</td></tr><tr><td>50000</td><td>6</td></tr><tr><td>80000</td><td>9</td></tr><tr><td>140000</td><td>12</td></tr><tr><td>500000</td><td>37</td></tr><tr><td>900000</td><td>64</td></tr></tbody></table><h3 id="实现1">实现1</h3><blockquote><p>个人感觉这种好理解</p></blockquote><p><code>QuickSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> start;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> end;</span><br><span class="line">            <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> arr[l];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="comment">//先从右向左，找到第一个小于base的数，将其移动到l的位置上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt;= base) &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[l] = arr[r];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//再从左向右，找到第一个大于base的数，将其移动到r的位置上</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt;= base) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[r] = arr[l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出时，l == r</span></span><br><span class="line">            arr[l] = base;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再分别对左、右的数组进行快排</span></span><br><span class="line">            quickSort(arr, start, l - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, r + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现1’">实现1’</h3><p><code>QuickSort</code></p><blockquote><p>仅对上述quickSort部分作了一定修改如下，只是形式不同罢了</p><blockquote><p>展示核心部分代码：</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> partition(arr,start,end);</span><br><span class="line">            <span class="comment">//再分别对左、右的数组进行快排</span></span><br><span class="line">            quickSort(arr, start, pos-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pos + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[r]&gt;=pivot)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[l]&lt;=pivot)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[r] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现2">实现2</h3><p><code>QuickSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(l + r) / <span class="number">2</span>];<span class="comment">//把中间元素定为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//临时的交换变量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，arr[l]==pivot，则需将 r-- （试想一下arr[l]和arr[r]同时==pivot的情况，会无限循环）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l==r必须l++,r--</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%80%92%E5%BD%92/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1>递归入门</h1><h2 id="简单迷宫问题">简单迷宫问题</h2><blockquote><p>判断能否找到出路即可</p></blockquote><p><code>MiGong</code></p><blockquote><p>为穷尽所有路线！仅选择了一种迷宫探索的策略（使用ifelse-if结构-》下右上左策略）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//1为墙</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;8;i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j=0;j&lt;7;j++)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(map[i][j]+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (findWay(map, <span class="number">1</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yes，可找到路：&quot;</span>);</span><br><span class="line">            <span class="comment">//输出路径</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                    System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若能走到map[6][5],说明通路找到</span></span><br><span class="line"><span class="comment">     * map[i][j]为0表示没做够，1表示为墙，2表示可以走，3表示已走过</span></span><br><span class="line"><span class="comment">     * 策略：下-&gt;右-&gt;上-&gt;左</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 传入的地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始走</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若能走通，true；反之为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> (findWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//改点走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//map[i][j]!=0 可能为1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="八皇后问题-经典">八皇后问题(经典)</h2><p>问题：在8×8的棋盘上放置8个皇后，任意两个皇后不能位于同一行、同一列、同一斜线，问有多少种摆法？</p><h3 id="思路分析">思路分析</h3><ol><li>第一个皇后先放第一行第一列</li><li>第二个皇后放第二行第一列、判断是否ok，不ok再判断第二列、第三列…直到找到一个位置合适</li><li>后续几个皇后的放置同理，直至最后一个皇后也放置成功，找到了一个成功解</li><li>当得到了一个正确解后，在栈回退到上一个栈时，开始回溯…即，将第一个皇后放在第一行第一列的所有正确解全部得到</li><li>然后再将第一个皇后放在第一行第二列，循环执行1234，直至第一个皇后八列均放置过。</li></ol><p>说明：理论上应该创建一个二维数组来表示棋盘，但是可以通过算法用一个一维数组解决问题——<code>arr[8]=&#123;0,4,7,5,2,6,1,3&#125;</code>，下标对应的是第几个皇后。故，<code>arr[i]=val</code>，表示第i+1个皇后放在第i+1行、第val+1列上</p><h3 id="代码实现">代码实现</h3><p><code>Queue8</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">//八皇后问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue8</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue8</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue8</span>();</span><br><span class="line">        q.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;解法一共有：%d种&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;<span class="comment">//说明已经放置了八个皇后（0-7）</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于第n个皇后，每一列依次去放到每一列j：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            array[n] = j;</span><br><span class="line">            <span class="keyword">if</span> (!isAttack(n)) &#123;</span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查摆放第n个皇后时位置是否冲突的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAttack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">//            if(array[i]==array[n] || array[i]+n-i==array[n] || array[i]-i+n==array[n])&#123;</span></span><br><span class="line"><span class="comment">//                return true;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//分别为判断是否在同一列、同一斜线的条件</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将8个皇后位置信息输出的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>希尔排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>首先是关于插入排序存在的问题：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/希尔排序/blog-20250501181431723.png" alt="image-20241031183208134" style="zoom:80%;" /><p>会发现当我们要插入的数据是较小的数时，后移的次数明显增多，对效率有影响</p><p><strong>希尔排序介绍</strong>：</p><p>也是一种插入排序，他是简单插入排序经过改进后的一个<strong>更高效版本</strong>，也成为<strong>缩小增量排序</strong></p><p><strong>基本思想</strong>：</p><p>希尔排序是把记录按下标的一定增量<strong>分组</strong>，对每组使用直接插入排序算法排序；随着<strong>增量</strong>减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法终止。</p><ol><li><strong>分组</strong>：希尔排序首先将整个待排序的数组按下标分成若干组。每组的元素之间的下标差为一个预先设定的<strong>增量</strong>（也称为“<strong>步长</strong>”）。例如，假设增量为 3，则数组中的元素会被分成多个子数组，<strong>每个子数组包含的元素是下标相差 3 的元素</strong>。</li><li><strong>直接插入排序</strong>：对每组中的元素使用直接插入排序算法进行排序。直接插入排序是将待排序元素逐个插入到已排序序列中的方法，<strong>适用于小规模数据的排序</strong>。</li><li><strong>减少增量</strong>：随着排序的进行，增量逐渐减少，通常会按照某种规则（如减半或减小固定值）来选择新的增量。每次减少增量后，分组的方式会发生变化，此时会有更多的元素被分到同一组中。</li><li><strong>最终排序</strong>：当增量减小到 1 时，所有元素就会被视为一组，此时使用插入排序对整个数组进行排序。<strong>由于之前的分组和局部排序，整体数据已经趋近于有序</strong>，因此最后的插入排序能够更高效地完成。</li></ol><ul><li><strong>总结</strong>：希尔排序通过<strong>先对远距离的元素进行排序</strong>，然后<strong>逐步缩小距离</strong>，使得数据<strong>逐渐接近有序</strong>，从而<strong>提高插入排序的效率</strong>。这种分组和逐步排序的方式使得希尔排序比直接插入排序<strong>在处理较大数组时效率更高</strong>。</li></ul><p><strong>图解</strong>：</p><ol><li><p><strong>初始数组</strong>：<br>假设我们有一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>选择增量</strong>：<br>假设我们选择初始增量为 4。数组被分为两组：</p><ul><li>第一组（下标 0, 4）：[8, 6]</li><li>第二组（下标 1, 5）：[5, 2]</li><li>第三组（下标 2, 6）：[3, 4]</li><li>第四组（下标 3, 7）：[7, 1]</li></ul></li><li><p><strong>对每组进行插入排序</strong>：<br>对每一组进行插入排序：</p><ul><li>第一组：[6, 8] → 变为 <code>[6, 8]</code></li><li>第二组：[2, 5] → 变为 <code>[2, 5]</code></li><li>第三组：[3, 4] → 变为 <code>[3, 4]</code></li><li>第四组：[1, 7] → 变为 <code>[1, 7]</code></li></ul><p>整体数组变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 2, 3, 1, 8, 5, 4, 7]</span><br></pre></td></tr></table></figure></li><li><p><strong>减小增量</strong>：<br>将增量减小到 2。新的分组：</p><ul><li>第一组（下标 0, 2, 4, 6）：[6, 3, 8, 4]</li><li>第二组（下标 1, 3, 5, 7）：[2, 1, 5, 7]</li></ul></li><li><p><strong>对新组进行插入排序</strong>：</p><ul><li>第一组：[3, 4, 6, 8] → 变为 <code>[3, 4, 6, 8]</code></li><li>第二组：[1, 2, 5, 7] → 变为 <code>[1, 2, 5, 7]</code></li></ul><p>整体数组变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 1, 4, 2, 6, 5, 8, 7]</span><br></pre></td></tr></table></figure></li><li><p><strong>再次减小增量</strong>：<br>将增量减小到 1。此时对整个数组进行插入排序：</p><ul><li>最终排序结果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure></li></ol><p>真-上述过程的图解：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/希尔排序/blog-20250501181444173.png" alt="image-20241031191106899" style="zoom:80%;" /><h2 id="代码实现">代码实现</h2><h3 id="实现1：希尔排序-交换式">实现1：希尔排序[交换式]</h3><blockquote><p>该种方法每次比较完采用了交换的方式移动数据，效率非常低:(比原生的插入排序还慢！)</p><p>（所以这种方式不能算是对插入排序的优化，只是用于演示思路比较清晰）</p></blockquote><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>71</td></tr><tr><td>50000</td><td>1419</td></tr><tr><td>80000</td><td>4179</td></tr><tr><td>140000</td><td>13005</td></tr></tbody></table><p><code>ShellSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序每轮过程：&quot;</span>);</span><br><span class="line">        shellDetailedSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------下面展示shellSort--------------------&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr2));</span><br><span class="line">        shellSort(arr2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-gap;j&gt;=<span class="number">0</span>;j-=gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                        arr[j] = arr[j+gap];</span><br><span class="line">                        arr[j+gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//详细演示了希尔排序每轮的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellDetailedSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//arr含8个数据：&#123;8, 5, 3, 7, 6, 2, 4, 1&#125;</span></span><br><span class="line">        <span class="comment">//第一轮：增量为4</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">4</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">4</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">4</span>];</span><br><span class="line">                    arr[j+<span class="number">4</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;6, 2, 3, 1, 8, 5, 4, 7&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二轮：增量为2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">2</span>];</span><br><span class="line">                    arr[j+<span class="number">2</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;3, 1, 4, 2, 6, 5, 8, 7&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三轮：增量为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j-=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三轮排序后：&quot;</span>+Arrays.toString(arr));<span class="comment">//&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        shellSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现2：希尔排序-移动式">实现2：希尔排序[移动式]</h3><blockquote><p>真-做到了对直接插入排序的究极优化！</p></blockquote><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>3</td></tr><tr><td>50000</td><td>6</td></tr><tr><td>80000</td><td>12</td></tr><tr><td>140000</td><td>17</td></tr></tbody></table><p><code>ShellSort</code>（对上述文件进行了覆盖并修改）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//对于第i个元素，采取直接插入的方法</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[insertIndex]) &#123; <span class="comment">//说明还没找到要插入的位置</span></span><br><span class="line">                    arr[insertIndex+gap]=arr[insertIndex];</span><br><span class="line">                    insertIndex-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[insertIndex+gap]=insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        shellSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>插入排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本思想</strong>为：</p><p>把n个待排序的元素看成为一个有序表和一个无序表，<strong>开始时有序表中只有一个元素</strong>，无序表中有n-1个元素，排序过程中<strong>每次从无序表中取出一个</strong>元素，将它与有序表中元素依次<strong>比较</strong>，<strong>插入到适当位置</strong>，使之成为新的有序表。</p><h2 id="代码实现">代码实现</h2><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>22</td></tr><tr><td>50000</td><td>431</td></tr><tr><td>80000</td><td>1074</td></tr><tr><td>140000</td><td>3214</td></tr></tbody></table><p><code>InsertSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];<span class="comment">//待插入有序表的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//该元素应该插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex]) &#123;</span><br><span class="line">                <span class="comment">//说明还没找到该插入的位置</span></span><br><span class="line">                arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[insertIndex+<span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        insertSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>选择排序(经典)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本思想</strong>为：</p><p>第一次从$arr[0]至arr[n-1]$中选取最小值，与$arr[0]$交换；第二次从$arr[1]至arr[n-1]$中选取最小值，与$arr[1]$交换；第三次从$arr[2]至arr[n-1]$中选取最小值，与$arr[2]$交换……</p><p><strong>图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/选择排序/blog-20250501181508676.png" alt="image-20241031164111535" style="zoom:67%;" /><p><strong>说明</strong>：</p><ol><li>选择排序有<code>arr.length-1</code>轮排序</li><li>每一轮循环，都是找出当前待排序元素的最小值(的索引<code>minIndex</code>)，放置到最前面(<code>swap(arr[minIndex],arr[i])</code>)。</li><li>时间复杂度为$O(n^2)$</li></ol><h2 id="代码实现">代码实现</h2><p><strong>算法性能测试</strong>：</p><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>26</td></tr><tr><td>50000</td><td>592</td></tr><tr><td>80000</td><td>1470</td></tr><tr><td>140000</td><td>4337</td></tr></tbody></table><p><code>SelectSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交换位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">80000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        selectSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>冒泡排序(经典)</h1><h2 id="思路分析">思路分析</h2><p>冒泡排序的<strong>基本思想</strong>是：</p><p>对待排序的元素依次从前往后遍历，比较相邻元素的值，若相邻元素逆序，则交换位置，最终会使得值较大的元素逐渐从前移动到后面，犹如水中气泡冒上来一样。</p><p><strong>优化</strong>：</p><p>因为在排序过程中，每个元素都会不断接近自己应在的位置，如果某一趟中没有进行交换，说明已排序完毕。（可新增<code>flag</code>来作为标志）</p><p><strong>图解</strong>：</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/blog-20250501181359884.png" alt="image-20241031124546183"></p><p>每一趟&quot;冒泡&quot;，就是将<strong>最大</strong>的那个元素放到<strong>待排序元素</strong>的最后，且每过一轮，待排序元素减一。</p><p>从上面例子明显可见，可以优化。</p><p><strong>小结</strong>：</p><ol><li>一共进行<code>arr.length()-1</code>次排序</li><li>每一趟排序的次数逐渐减少</li><li>如果发现某一次没有交换，就可以结束排序（优化）</li><li>时间复杂度为$O(n^2)$</li></ol><h2 id="代码实现">代码实现</h2><p><strong>算法性能测试</strong>：</p><table><thead><tr><th>测试数据大小</th><th>花费时间（单位：毫秒）</th></tr></thead><tbody><tr><td>10000</td><td>43</td></tr><tr><td>50000</td><td>1845</td></tr><tr><td>80000</td><td>5250</td></tr><tr><td>140000</td><td>18690</td></tr></tbody></table><p><code>BubbleSort</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后:&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>; <span class="comment">// 如果一次排序都没有，说明已经有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">80000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">100000</span>); <span class="comment">// 随机数范围可以根据需要调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        bubbleSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——并查集</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1>并查集</h1><blockquote><p>由于目录编排原因，好像并查集是图？并不是，它是一种独立的抽象的数据结构。可以看做是一棵树或森林。</p><p>并查集的定义以及算法实现参考了<a href="https://oi-wiki.org/ds/dsu/">OI WIKI并查集</a>以及<a href="https://blog.csdn.net/the_zed/article/details/105126583">blog</a>提供了形象生动的例子。</p><p>同时参考了GPT所提供应用、代码。</p></blockquote><p><strong>基本介绍</strong>：</p><p><strong>并查集(DSU)</strong>，全称为<strong>Disjoint Set Union</strong>。</p><ol><li><p>并查集是一种用于<strong>管理元素所属集合</strong>的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p></li><li><p>顾名思义，并查集支持两种操作：</p><ul><li><p><strong>合并（Union）</strong>：合并两个元素所属集合（合并对应的树）</p></li><li><p><strong>查询（Find）</strong>：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</p></li></ul><blockquote><p>删除、移动属于扩展的操作，需要将parent数组增加值两倍，还新增一个size[]来记录每个集合中元素个数，其大小也是两倍。</p></blockquote><ul><li>通常情况下并查集的标准实现只需要<code>find</code>和<code>unite</code>就行，如需扩展功能才将数组空间变为两倍，因此也给出两种代码。</li></ul></li></ol><p><strong>并查集的应用</strong>：</p><ol><li><strong>连通性问题</strong><ul><li>并查集最经典的应用之一是判断图中节点是否连通。假设你有一个无向图，需要动态地判断两个节点是否属于同一个连通块，或者在图中添加边并进行连通性判断。并查集通过“合并”和“查找”操作，能够在近乎常数时间内解决这一问题。</li><li>判断两个城市是否在同一条道路网络中。</li><li>判断两个计算机是否在同一个局域网中。</li></ul></li><li><strong>最小生成树</strong><ul><li>并查集是 <a href="##%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95">Kruskal 算法</a>的核心部分。Kruskal 算法通过对边进行排序并逐步合并节点，最终得到图的最小生成树。在这个过程中，使用并查集判断两个节点是否属于同一集合，防止产生环。</li><li>计算带权图的最小生成树，最小成本的通信网络布设。</li></ul></li><li><strong>动态连通性</strong><ul><li>在一些实时问题中，可能会动态地增加边或删除边。并查集可以高效地处理这种动态连通性的问题，例如：在某些社交网络中判断两个人是否处于同一网络中，或者当一条连接断开时判断网络是否仍然连通。</li><li>判断社交网络中两个用户是否在同一个群组。</li><li>判断计算机网络中两个节点是否能通信。</li></ul></li><li><strong>图的环形检测</strong><ul><li>在图的遍历过程中，环的检测是一个常见问题。利用并查集可以高效地检测图中是否有环。当你尝试合并两个已经在同一集合中的节点时，说明已经发现了一个环。</li><li>判断一个无向图中是否存在环。</li><li>判断一个任务依赖图中是否存在循环依赖。</li></ul></li><li><strong>分割问题</strong><ul><li>在图中，分割或切割的目标是将图分割成多个连通块。并查集可以帮助快速地找到哪些节点属于同一块，从而实现图的分割。</li><li>网络中的分区，找到某些节点之间的最大割集。</li><li>计算机科学中的图像分割问题。</li></ul></li><li><strong>动态连通性与并查集扩展</strong><ul><li>一些复杂的动态连通性问题，可以使用并查集的扩展版本进行处理。例如，在动态树形结构的查询和更新中，可以通过并查集进行高效操作。</li><li>在数据流中，快速查询和更新不同数据块之间的连接关系。</li></ul></li><li><strong>岛屿问题</strong><ul><li>给定一个二维矩阵，其中每个元素表示一个格子，格子值为 <code>1</code> 表示陆地，<code>0</code> 表示水域。通过并查集，可以快速求解岛屿的个数，即求连通的陆地块的个数。</li><li>在一个地图中，找到所有孤立的岛屿区域。</li></ul></li><li><strong>动态查询最小生成树</strong><ul><li>并查集也可以用于处理某些动态修改图的问题，如在某些图的边权改变时，需要动态查询和更新最小生成树。通过与其他算法结合，保持并查集的结构可以高效更新图中的连通信息。</li></ul></li></ol><p><strong>算法实现思路</strong>：</p><ol><li><p><strong>初始化</strong></p></li><li><p><strong>查询</strong><code>find</code></p><ol><li><p>我们需要沿着树向上移动，直至找到根节点。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/并查集/blog-20250501181537510.png" alt="image-20241113105235769" style="zoom:80%;" /></li><li><p>路径压缩，可以加快后续的查找速度。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/并查集/blog-20250501181548998.png" alt="image-20241113105250975" style="zoom:80%;" /></li></ol></li><li><p><strong>合并</strong></p><p>要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/并查集/blog-20250501181602623.png" alt="image-20241113105355926" style="zoom:80%;" /><p>补充：<strong>启发式合并</strong></p><p>合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p></li><li><p><strong>删除</strong><code>erase</code></p><p>要删除一个叶子节点，我们可以将其父亲设为自己。为了保证要删除的元素都是叶子，我们可以预先为每个节点制作副本，并将其副本作为父亲。</p><p>实际上，这里的删除操作，只是将该元素的parent指向他自己。</p><ul><li><p>该操作的效果是 <strong>“断开”</strong> 元素 <code>x</code> 与它原来集合的联系，使 <code>x</code> 成为一个新的单元素集合，但并没有真正删除 <code>x</code> 本身，也没有改变其它集合的结构。</p></li><li><p>这意味着，<code>x</code> 会从原集合中“移除”，但其索引仍然存在于数据结构中。换句话说，<code>erase</code> 操作并没有修改 <code>parent</code> 数组的大小，也没有真正从数据结构中“删除”元素，只是把 <code>x</code> 从原来的集合中分离出来。</p></li><li><p><strong>为什么？</strong></p><ul><li><p>这样的设计通常用于 <strong>懒惰删除</strong>（lazy deletion）或者当需要在集合中分割元素时。这种方式避免了删除元素时可能出现的性能开销，特别是在处理大数据结构时。</p></li><li><p>另外，<code>erase</code> 操作本身可能用于某些特定场景，比如让元素独立出来，变成一个单独的集合，供后续操作使用。</p></li></ul></li><li><p><strong>进一步改进</strong>：</p><ul><li>如果需要完全删除某个元素并从集合中移除，可以考虑设计一个额外的机制来真正删除元素，可能会涉及到管理集合中实际元素的列表或数组。</li></ul></li></ul></li><li><p><strong>移动</strong></p><p>与删除类似，通过以副本作为父亲，保证要移动的元素都是叶子。</p></li></ol><p><strong>带权并查集</strong>：</p><p>我们还可以在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算，从而解决更多的问题。</p><p>比如对于经典的<a href="https://www.luogu.com.cn/problem/P2024">「NOI2001」食物链</a>，我们可以在边权上维护模 3 意义下的加法群。</p><h2 id="标准并查集实现">标准并查集实现</h2><p><code>DSUDemo</code></p><blockquote><p>感谢GPT</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.dsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DSUDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含 5 个元素的并查集</span></span><br><span class="line">        <span class="type">DSU</span> <span class="variable">dsu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DSU</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印初始状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Initial state:&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并集合</span></span><br><span class="line">        dsu.unite(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 将 0 和 1 合并</span></span><br><span class="line">        dsu.unite(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 将 1 和 2 合并</span></span><br><span class="line">        dsu.unite(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 将 3 和 4 合并</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印合并后的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After uniting (0,1), (1,2), (3,4):&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 0: &quot;</span> + dsu.find(<span class="number">0</span>));  <span class="comment">// 输出 0 或 2，因为 0 和 2 在同一个集合中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 4: &quot;</span> + dsu.find(<span class="number">4</span>));  <span class="comment">// 输出 4 或 3，因为 3 和 4 在同一个集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次合并 2 和 3</span></span><br><span class="line">        dsu.unite(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 将 2 和 3 合并</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印合并后的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After uniting (2,3):&quot;</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 0: &quot;</span> + dsu.find(<span class="number">0</span>));  <span class="comment">// 输出 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Find root of 4: &quot;</span> + dsu.find(<span class="number">4</span>));  <span class="comment">// 输出 2，因为 4 通过 3 和 2 连接到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;  <span class="comment">// 用于存储每个元素的父节点</span></span><br><span class="line">    <span class="type">int</span>[] size;    <span class="comment">// 用于存储每个集合的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：初始化并查集，设置每个元素的父节点为自己，集合大小为 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DSU</span><span class="params">(<span class="type">int</span> size_)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size_];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[size_];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化，父节点指向自己，集合大小为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">            parent[i] = i;    <span class="comment">// 每个元素的父节点初始化为它自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>;      <span class="comment">// 每个集合的初始大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找操作：返回元素 x 所在集合的根节点，同时使用路径压缩优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 的父节点是它自己，说明它是根节点，直接返回</span></span><br><span class="line">        <span class="comment">// 否则递归查找其父节点并进行路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并操作：将元素 x 和 y 所在的集合合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找元素 x 和 y 的根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 x 和 y 已经在同一个集合中，则不需要合并</span></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 根据集合大小来决定将哪个集合合并到另一个集合</span></span><br><span class="line">            <span class="keyword">if</span> (size[rootX] &lt; size[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;  <span class="comment">// 将 x 所在的集合合并到 y 所在的集合</span></span><br><span class="line">                size[rootY] += size[rootX];  <span class="comment">// 更新 y 所在集合的大小</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;  <span class="comment">// 将 y 所在的集合合并到 x 所在的集合</span></span><br><span class="line">                size[rootX] += size[rootY];  <span class="comment">// 更新 x 所在集合的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前并查集的父节点数组和集合大小数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent: &quot;</span> + Arrays.toString(parent));  <span class="comment">// 打印每个元素的父节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Size: &quot;</span> + Arrays.toString(size));      <span class="comment">// 打印每个集合的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展并查集实现">扩展并查集实现</h2><p><code>ExtendedDSUDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.extendedDsu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedDSUDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DSU</span> <span class="variable">dsu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DSU</span>(<span class="number">5</span>);</span><br><span class="line">        dsu.print();</span><br><span class="line">        dsu.unite(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        dsu.unite(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//        dsu.find(2);</span></span><br><span class="line">        dsu.print();<span class="comment">//此时输出parent[5,5,7,8,9,5,5,5,8,9]为什么呢？</span></span><br><span class="line">                    <span class="comment">//发现第2个元素和7号元素的父节点都应该是5才对？</span></span><br><span class="line">                    <span class="comment">//因为此时刚完成合并，没有进行过find，所以路径没压缩，只要加上那句注释掉的find，此时的parent[2]也会变成5</span></span><br><span class="line">        dsu.move(<span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 将元素 0 移动到元素 3 所在的集合</span></span><br><span class="line">        dsu.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DSU</span><span class="params">(<span class="type">int</span> size_)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[size_ * <span class="number">2</span>];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[size_ * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化前半部分，元素属于不同的集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">            parent[i] = i + size_;  <span class="comment">// 初始化 parent 数组，前 size_ 个元素依次为 size_ 到 2*size_-1</span></span><br><span class="line">            size[i] = <span class="number">1</span>;            <span class="comment">// 每个集合的初始大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化后半部分，元素是自己的父节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size_; i &lt; size_ * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;          <span class="comment">// 后半部分，pa[i] = i，表示每个元素自己是根</span></span><br><span class="line">            size[i] = <span class="number">1</span>;            <span class="comment">// 初始集合大小为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并进行路径压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两棵树，按大小合并</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个元素已经在同一个集合中，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 按大小合并：将小树合并到大树下</span></span><br><span class="line">            <span class="keyword">if</span> (size[rootX] &lt; size[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">                size[rootY] += size[rootX];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                size[rootX] += size[rootY];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素 x 移动到元素 y 所在的集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);  <span class="comment">// 查找元素 x 所在的集合的根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);  <span class="comment">// 查找元素 y 所在的集合的根</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 x 和 y 已经在同一个集合中，不需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 x 移动到 y 所在的集合</span></span><br><span class="line">        parent[x] = fy;  <span class="comment">// 让 x 的父节点指向 y 所在的集合</span></span><br><span class="line">        size[fx]--;      <span class="comment">// 原集合的大小减 1</span></span><br><span class="line">        size[fy]++;      <span class="comment">// 目标集合的大小加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 parent 和 size 数组的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent: &quot;</span> + Arrays.toString(parent));</span><br><span class="line">        System.out.println(<span class="string">&quot;Size: &quot;</span> + Arrays.toString(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——图</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1>图</h1><p>为什幺要有图？</p><ol><li>线性表局限于一个直接前驱和一个直接后继。</li><li>树也只能有一个直接前驱。</li><li>当我们需要<strong>多对多</strong>的关系时，就需要使用<strong>图</strong>。</li></ol><p><strong>图的常用概念</strong></p><ol><li><p><strong>顶点</strong>（<strong>vertex</strong>）</p></li><li><p><strong>边</strong>（<strong>edge</strong>）</p></li><li><p><strong>路径</strong></p></li><li><p><strong>无向图</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/图/blog-20250501183034390.png" alt="image-20241110210336286" style="zoom:80%;" /></li><li><p><strong>有向图</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/图/blog-20250501183045875.png" alt="image-20241110210634499" style="zoom:80%;" /></li><li><p><strong>带权图</strong>（这种边带权值的图也叫<strong>网</strong>）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/图/blog-20250501183055477.png" alt="image-20241110210837126" style="zoom:80%;" /></li></ol><p>图的表示方式：二维数组表示（<strong>邻接矩阵</strong>）；链表表示（<strong>邻接表</strong>）</p><ol><li><p><strong>邻接矩阵</strong></p><ul><li>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1…n个点。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/图/blog-20250501183106288.png" alt="image-20241113213029646" style="zoom:80%;" /></li><li><p><strong>邻接表</strong></p><ul><li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失。</li><li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/图/blog-20250501183117013.png" alt="image-20241114115322312" style="zoom:80%;" /></li></ol><p><strong>创建一个无向图-简单案例</strong></p><p><code>Graph</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numOfEdges; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String Vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(String vertex: Vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// A-B</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfVertex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] link : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取边的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfEdges</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取顶点的值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取权值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertVertex</span><span class="params">(String vertex)</span> &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——树</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>树</h1><p><strong>为什么需要树这种存储结构?</strong></p><ol><li>数组：<ul><li>优点：通过下标方式查找元素，查找速度快，况且还可以通过排序+查找算法进一步提高查找速度，<strong>随机存取</strong>是其最大优势。</li><li>缺点：插入删除元素复杂，涉及到整体移动的问题，耗费大量时间。</li></ul></li><li>链式存储：<ul><li>优点：插入删除方便。</li><li>缺点：查找效率不高，需要从头开始遍历查找。</li></ul><blockquote><p>提一嘴哈希表（数组+链表版），一定程度上集数组和链表之长，既提高查找效率，又简化了插入删除操作。</p></blockquote></li><li>树：能提高数据的<strong>存储、读取</strong>效率，比如<strong>二叉排序树</strong>，即保证了查询效率，插入删除操作也方便。</li></ol><p><strong>树的常用术语</strong>(不必纠结)：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181746016.png" alt="image-20241103104817501" style="zoom:80%;" /><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>节点</td><td>A、B、C……都是节点</td></tr><tr><td>根节点root</td><td>A</td></tr><tr><td>父节点</td><td>C是F和G的父节点</td></tr><tr><td>子节点</td><td>C是A的子节点</td></tr><tr><td>叶子节点</td><td>没有子节点的节点</td></tr><tr><td>节点的权</td><td>节点值</td></tr><tr><td>路径</td><td>从root找到当前节点的路线</td></tr><tr><td>层</td><td>如图</td></tr><tr><td>子树</td><td>D、H为B的子树</td></tr><tr><td>树的高度</td><td>4</td></tr><tr><td>森林</td><td>多棵树构成</td></tr></tbody></table><p>注意事项：</p><p>树分为有序树和无序树，有序树分左右，无序树不分左右。</p><h1>二叉树</h1><h2 id="基本概念">基本概念</h2><ol><li>每个节点都<strong>至多</strong>有两个子节点。</li><li>二叉树的子节点分为<strong>左节点</strong>和<strong>右节点</strong>。</li><li><strong>满二叉树</strong>：如果<strong>所有叶子节点都在最后一层</strong>，且节点总数为$2^n-1$个，其中n为层数，则称<strong>满二叉树</strong>。</li><li><strong>完全二叉树</strong>：若二叉树的<strong>所有叶子节点都在最后一层或倒数第二层</strong>，且最后一层的叶子节点<strong>左连续</strong>，倒数第二层的叶子节点<strong>右连续</strong>，则称<strong>完全二叉树</strong>。</li></ol><h2 id="性质">性质</h2><blockquote><p>参考《数据结构（C语言版）》–清华大学出版社</p><p>有助于加深对<a href="###%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a>中“<strong>为什么有这样的特点</strong>”的理解，使之成为严谨的数学推导。（当然不看也行，直接找规律也能推出来）</p></blockquote><ol><li>在二叉树的第$i$层至多有$2^{i-1}$个节点（$i\geq1$）</li><li>深度为$k$的二叉树至多有$2^k-1$个节点（$k\geq1$）</li><li>对任意一棵二叉树，如果其终端节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$</li></ol><blockquote><p>关于第三点的推导：</p><p>已知$n=n_0+n_1+n_2$，其中$n$为<strong>节点总数</strong>（这个式子是基于节点数列出来的）</p><p>又因为$n=n_1+2n_2+1$，这个式子的原因为<strong>节点数等于分支数+1</strong>，只有$n_1$有1个分支，$n_2$有2个分支，$n_0$没有分支。</p><p>两式消去$n_1$即可</p></blockquote><ol start="4"><li>具有n个节点的完全二叉树的深度 $\lfloor \log_2 n \rfloor + 1$。</li></ol><blockquote><p>Proof：</p><p>设深度为k，则根据完全二叉树定义以及性质2可知：</p><p>$2^{k-1}-1&lt;n\leq 2^k-1$或$2^{k-1}\leq n &lt; 2^k$，选则其一可解得……</p></blockquote><ol start="5"><li>对于一个有n个节点的完全二叉树，对于任一节点$i$（$1 \leq i \leq n$），有：<ul><li>若$i=1$，则为root节点；若$i&gt;1$，则其<strong>父节点</strong>为$\lfloor i/2 \rfloor$</li><li>若$2i&gt;n$，则节点$i$无左子节点，否则其<strong>左子节点</strong>为$2i$</li><li>若$2i+1&gt;n$，则节点$i$无右节点，否则其<strong>右子节点</strong>为$2i+1$</li></ul></li></ol><h2 id="链式存储二叉树">链式存储二叉树</h2><p>需要创建一个结点类，应包括数据本身的数据、左节点<code>left</code>、右节点<code>right</code>、[父节点<code>root</code>可选]</p><p>连式存储很常见，所以不做代码演示，因为后续的很多都用到了链式存储……</p><p>而且遍历、查找方法在节点类中均有写，但是最终我们是通过调用<code>BinaryTree</code>这个类里面的方法，所以节点类里面写的方法一般情况是给二叉树用的（如遍历、查找[后续代码可见其用意]）</p><h2 id="前序-中序-后续遍历">前序/中序/后续遍历</h2><h3 id="思路分析">思路分析</h3><blockquote><p>区分前/中/后序，看父节点什么时候输出。</p></blockquote><p><strong>概念</strong>：</p><ol><li>前序遍历：先输出<strong>父节点</strong>，再遍历左子树和右子树。</li><li>中序遍历：先遍历左子树，再输出<strong>父节点</strong>，再遍历右子树。</li><li>后续遍历：先遍历左子树，再遍历右子树，最后输出<strong>父节点</strong>。</li></ol><p><strong>流程</strong>：</p><ol><li>创建二叉树</li><li>遍历<ul><li><p>前序遍历</p><ul><li>先<strong>输出当前节点</strong>(初始时为root节点)</li><li>如果左子节点不为空，则向左递归执行前序遍历</li><li>如果右子节点不为空，则向右递归执行前序遍历</li></ul></li><li><p>中序遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行中序遍历</li><li><strong>输出当前节点</strong></li><li>如果当前节点的右子节点不为空，则向右递归执行中序遍历</li></ul></li><li><p>后续遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行后序遍历</li><li>如果当前节点的右子节点不为空，则向右递归执行后序遍历</li><li><strong>输出当前节点</strong></li></ul></li></ul></li></ol><p><strong>小技巧</strong>：</p><blockquote><p>无论何种技巧，画图永远不会错</p></blockquote><p>前序遍历就是走到哪输出到哪（<strong>从根先往左下，再回溯尝试往右</strong>）；中序遍历，某个节点没有左节点了（<strong>优先输出左叶子，没有左叶子后就从根往下，输出一次掉一片叶子</strong>），就输出；后序遍历，某个节点同时没有左右了，输出（<strong>优先左叶子，再右叶子，每次输出一次就相当于掉一片叶子</strong>）。</p><h3 id="代码实现">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrder</code>、<code>infixOrder</code>、<code>postOrder</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>,<span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>,<span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>,<span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;后续遍历：&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前序-中序-后续查找">前序/中序/后续查找</h2><h3 id="思路分析-2">思路分析</h3><p><strong>流程</strong>：</p><ol><li>存在一颗二叉树</li><li>查找<ul><li><strong>前序查找</strong><ul><li>先判断<strong>当前节点</strong>的id是否等于要查找的</li><li>如果相等，则返回当前节点</li><li>如果不等，则判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果左递归找到节点，则返回；否则，判断判断当前节点的<strong>右子节点</strong>是否为空，若不为空，则继续向右递归。</li></ul></li><li><strong>中序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，则判断<strong>当前节点</strong>是否是要找的绩点，如果是，则返回。</li><li>不是，判断<strong>右子节点</strong>是否为空，不为空，则向右递归，找到则返回，否则返回null。</li></ul></li><li><strong>后序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，判断<strong>右子节点</strong>是否为空，不为空，则向左递归，找到则返回。</li><li>若没找到，判断<strong>当前节点</strong>是否是想要找的节点，如果是返回，不是则返回null。</li></ul></li></ul></li></ol><blockquote><p>tips1：无论怎样，凡是遇到需要访问左、右节点的操作，均需要先判断是否为空。</p><p>tips2：前序–&gt;当前，左，右；中序–&gt;左，当前，右；后序–&gt;左，右，当前。</p></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrderSearch</code>、<code>infixOrderSearch</code>、<code>postOrderSearch</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.preOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.infixOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.postOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除节点">删除节点</h2><h3 id="思路分析-3">思路分析</h3><p><strong>删除操作</strong>：</p><ol><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除子树</li></ol><blockquote><p>如果不想把整棵子树删除，</p><p>可以考虑将第二点改为：(放于实现2)</p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……(我这边暂时用一种简单实现：还是让B替代A，但是在B向左while循环，找到最左边的那个位置，然后把C插入(这样子代码实现简单，但是树的层数会变高……))</li></ul><blockquote><p>后续的二叉排序树更有另一套规则</p></blockquote></blockquote><p><strong>思路</strong>：</p><ol start="0"><li><p>若树只有一个root节点，则判断root是否要要删的，若是，置null。然后进行下面操作：(第0步写在<code>BinaryTree</code>的删除方法里[最先判断]，后续5步写在<code>HumanNode</code>的删除方法里)</p></li><li><p>因为二叉排序树是单向的，所以我们判断的是当前节点的子节点是否需要删除，而不是判断当前节点是否需要被删除（除非节点设计上带有父节点、或者查找时带有父节点信息）。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.left != null)</code>，且为要删除的节点，则删除<code>this.left = null</code>(简单粗暴法)，结束递归。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.right != null)</code>，且为要删除的节点，则删除<code>this.right = null</code>(简单粗暴法)，结束递归。</p></li><li><p>若第2、3步都没删除成功，则向左递归（当然要判断是否为空）。</p></li><li><p>若第4步没删除成功，则向右递归（当然要判断是否为空）。</p></li></ol><h3 id="代码实现-3">代码实现</h3><h4 id="实现1-直接把子树删掉">实现1(直接把子树删掉)</h4><p><code>BinaryTreeDemo</code></p><p>核心为：<code>delNodeById</code>inclass <code>BinaryTree</code>和<code>HumanNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现2-仅删节点-清晰">实现2(仅删节点)+清晰</h4><p><code>BinaryTree.delNodeById</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HumanNode.delNodeById</code></p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……<ul><li>我这边暂时用一种简单实现：还是让B替代A，但是<strong>不断在B向左while循环</strong>，找到<strong>最左边的那个位置</strong>，然后把C插入</li><li>这样子代码实现简单，但是树的层数会变高……</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.left))&#123;<span class="comment">//如果是叶子节点</span></span><br><span class="line">                <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是叶子</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.left.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.left.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.left.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.left;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.right))&#123;</span><br><span class="line">                <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.right.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.right.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.right.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.right;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.right.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码1：结果为1 4 6 8 7 3 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode4.setLeft(humanNode6);</span><br><span class="line">        humanNode4.setRight(humanNode7);</span><br><span class="line">        humanNode2.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码2：结果为1 2 4 6 7 8 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode3.setLeft(humanNode6);</span><br><span class="line">        humanNode6.setLeft(humanNode7);</span><br><span class="line">        humanNode6.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="顺序存储二叉树">顺序存储二叉树</h2><h3 id="思路分析-4">思路分析</h3><p><strong>说明</strong>：</p><p>从数据存储来看，数组存储方式和树存储方式可以相互转换（如下：）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181758051.png" alt="image-20241103185227543" /><p><strong>要求</strong>：</p><ol><li>二叉树中的数据用数组的形式存放，如上</li><li>在遍历数组时，仍能实现树的<strong>前序/中序/后序遍历</strong>。</li></ol><p><strong>特点</strong>：</p><ol><li>顺序存储二叉树，通常只考虑<strong>完全二叉树</strong>。</li><li>第n个元素的左子节点为$2*n+1$</li><li>第n个元素的右子节点为$2*n+2$</li><li>第n个元素的父节点为$(n-1)/2$<blockquote><p>n表示二叉树中第几个元素（从0开始），且编号顺序为——<strong>低层优先、左节点优先</strong></p></blockquote></li></ol><blockquote><p>ps：八大排序算法之<strong>堆排序</strong>，就会使用顺序存储二叉树。</p></blockquote><h3 id="代码实现-4">代码实现</h3><p><code>ArrayBinaryTreeDemo</code></p><blockquote><p>实现了数组的前序/中序/后序查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">ArrayBinaryTree</span> <span class="variable">arrayBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBinaryTree</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.preOrder();<span class="comment">//1 2 4 5 3 6 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.infixOrder();<span class="comment">//4 2 5 1 6 3 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.postOrder();<span class="comment">//4 5 2 6 7 3 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现顺序存储二叉树的遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，使得不写参数就是代表从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">线索化二叉树</h2><h3 id="思路分析-5">思路分析</h3><p><strong>问题</strong>：</p><p>将${ 1,3,6,8,10,14 }$构建成一颗二叉树，如下图</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181813911.png" alt="image-20241103201821509" style="zoom:80%;" /><ol><li>当对上述中序遍历时：8，3，10，1，14，6</li><li>但是对于8，10，14，6这几个节点的左右指针没有充分利用</li><li>如果有个新需求——充分利用各个节点的指针，<strong>让每个节点可以指向自己的前后节点</strong></li><li>解决方案：<strong>线索化二叉树</strong></li></ol><p><strong>介绍</strong>：</p><ol><li>$n$个节点的二叉链表中含有$n+1$个空指针域（推导：$2n-(n-1)=n+1$）。利用二叉链表中的空指针域，存放指向该节点在<strong>某种遍历次序</strong>下的<strong>前驱节点</strong>和<strong>后驱节点</strong>，这种附加的指针称为“线索”。</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为<strong>线索二叉树</strong>。分为<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>、<strong>后序线索二叉树</strong>。</li><li>一个节点的前一个节点，称<strong>前驱节点</strong>。</li><li>一个节点的后一个节点，称<strong>后继节点</strong>。</li></ol><p><strong>图解——将上述二叉树按中序遍历线索化</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181827267.png" alt="image-20241104094103323" /><p>8号左指针指向较为特殊，通过代码运行逻辑可以得出。（特地标出来，是为了说明8的<code>leftType = =1</code>，为后续遍历中序线索化二叉树做铺垫）</p><p>但是有些问题：线索化后的二叉树，其<code>left</code>既可能指向左子树（如1），也可能指向其前驱节点（如10）；其<code>right</code>既可能指向后继节点（如8），也可能指向其右子树（如1、3）。</p><ul><li>[x] 进一步简化、讲清楚找<strong>红色线索</strong>的方法！！！参考<a href="https://blog.csdn.net/m0_56494923/article/details/130457392">blog</a>画出线索的方法，很简单，易于记忆！</li></ul><p><em><strong>画出线索的方法（重要！这是分析の方法）</strong></em>:</p><ol><li>中序线索找法<ul><li>根据特定的遍历方式，写出最终的输出。例如上述想实现中序线索化，则先用中序遍历的思路看看——<strong>8，3，10，1，14，6</strong></li><li>根据这个输出顺序，给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li><strong>由于是中序，8号左边null</strong>。其余的：<strong>8右为3</strong>；<strong>10左为3</strong>，<strong>10右为1</strong>；1左右？不需要；<strong>14左1</strong>，<strong>14右6</strong>；6不需要左，最终6右不需要。</li></ul></li><li>前序线索找法<ul><li>先用前序遍历得到输出：<strong>1，3，8，10，6，14</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li>1不需要；3不需要；<strong>8左3</strong>，<strong>8右10</strong>；<strong>10左8</strong>，<strong>10右6</strong>；<strong>6右14</strong>；<strong>14左6</strong>，<strong>14右仍为null</strong>(经测：14的<code>rightType==0</code>)；</li></ul></li><li>后序线索找法<ul><li>先用后序遍历得到输出：<strong>8，10，3，14，6，1</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点、后继节点</strong></li><li><strong>8左为null</strong>，<strong>8右为10</strong>；<strong>10左为8</strong>，<strong>10右为3</strong>；3不需要；<strong>14左为3</strong>，<strong>14右为1</strong>；<strong>6右为1</strong>；1不需要。</li></ul></li></ol><p><strong>线索化代码流程</strong>：（步骤执行顺序的不同）</p><ol><li><p>前序线索化：</p><ul><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>如果左节点的<code>leftType == 0</code> ，再线索化左子树（左递归）</li><li>如果右节点的<code>rightType == 0</code>，再线索化右子树（右递归）</li><li><blockquote><p>进入前序线索化，在进入左、右递归前！一定要判断<code>某某Type == 0</code>！不然会进入死递归！坐等<code>StackOverflowError</code>吧！</p></blockquote></li></ul></li><li><p>中序线索化：</p><ul><li>线索化左子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>线索化右子树</li></ul></li><li><p>后序线索化：</p><ul><li>线索化左子树</li><li>线索化右子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li></ul></li></ol><blockquote><p>神奇吧，只有前序线索化在进入递归前需要判断……</p></blockquote><ul><li>[x] 必须要给<code>threadedNode(HumanNode node)</code>方法画一个图解！（这玩意的设置前驱节点和设置后继节点的代码部分并不是很直观、。而且，画图这一过程可以加深我的印象以及理解。）</li></ul><p><strong>图解–设置前驱结点、后继节点</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181840162.png" alt="image-20241104090654992" /><h3 id="代码实现-5">代码实现</h3><h4 id="中序线索化">中序线索化</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>要点在于：在<code>HumanNode</code>中新增了<code>leftType</code>和<code>rightType</code>两个字段及对应getter、setter方法。</p><p>在<code>ThreadedBinaryTree</code>中使用了<code>threadedNode</code>方法用于(<strong>中序</strong>)线索化二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>,<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>,<span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>,<span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>,<span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d&quot;</span>,node5.getLeft().getId(),node5.getRight().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;8号节点的右指针类型：&quot;</span>+node4.getRightType());</span><br><span class="line"><span class="comment">//        System.out.println(node4.getLeft().getId());//注意，8号节点的left为null，因为此时prev == null。（调试发现）</span></span><br><span class="line">        <span class="comment">//虽然8号节点的leftType已经被设置为1，但是left指向为null。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="前序线索化">前序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索化">后序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序线索化二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">    threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">    threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">    <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.setLeft(prev);</span><br><span class="line">        node.setLeftType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.setRight(node);</span><br><span class="line">        prev.setRightType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;理应新增的线索测试：&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;8号右边为：%d号节点\n&quot;</span>, node4.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号左边为：%d号节点\n&quot;</span>, node5.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号右边为：%d号节点\n&quot;</span>, node5.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号左边为：%d号节点\n&quot;</span>, node6.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号右边为：%d号节点\n&quot;</span>, node6.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;6号右边为：%d号节点\n&quot;</span>, node3.getRight().getId());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树">遍历线索化二叉树</h2><h3 id="思路分析-6">思路分析</h3><p>要求：对已经(中序)线索化的二叉树采取相同策略(中序)的遍历方式。</p><p>问题：因为线索化后，各个节点的指向以发生变化，因此原先的遍历方式不能再使用，需要用新的遍历方式遍历线索化二叉树。</p><p>优点：由于各个节点可以通过线型方式遍历，所以无需使用递归，提高了遍历的效率。</p><h3 id="代码实现-6">代码实现</h3><h4 id="遍历中序线索化二叉树">遍历中序线索化二叉树</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>新增<code>threadedList</code><strong>遍历中序线索化二叉树</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">        <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">        <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.getRight();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历中序线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.threadedList();<span class="comment">// 8 3 10 1 14 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">            <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历前序线索化二叉树">遍历前序线索化二叉树</h4><p><code>threadedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">            System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line"><span class="comment">//        System.out.printf(&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d \n&quot;, node5.getLeft().getId(), node5.getRight().getId());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;14号节点的左指针类型：&quot; + node6.getLeftType());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历前序线索化二叉树是否成功：</span></span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">                System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历后序线索化二叉树">遍历后序线索化二叉树</h4><p><code>threadedList</code></p><p>这个代码很复杂，已经需要使用<strong>三叉链表</strong>了。</p><blockquote><p>引用自<a href="https://blog.csdn.net/m0_56494923/article/details/130457392">博客</a>，暂时不深入思考、以及实现。</p><ul><li>[ ] 有空再说。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181854902.png" alt="image-20241104193040292" style="zoom:80%;" /></blockquote><h1>赫夫曼树</h1><blockquote><p>Huffman，赫夫曼，哈夫曼，霍夫曼。</p></blockquote><h2 id="基本概念介绍">基本概念介绍</h2><ol><li><strong>路径和路径长度</strong>：从一个节点往下可以到达的孩子或孙子节点的通路，成为<strong>路径</strong>；通路中分支的数目称为<strong>路径长度</strong>。若根节点为第L层，则第L层的节点的路径长度为$L-1$</li><li><strong>结点的权、带权路径长度</strong>：节点中含有一个有某种含义的数值，称为<strong>节点的权</strong>；路径长度*节点的权 = <strong>带权路径长度</strong></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181905706.png" alt="image-20241105200517736" style="zoom:80%;" /><ol start="3"><li><strong>树的带权路径长度</strong>：<strong>所有叶子节点的带权路径长度之和</strong>，称为<strong>树的带权路径长度</strong>，记为<strong>WPL（weighted path length）</strong>，赫夫曼树的特点就是<em><strong>带权路径长度最短</strong></em>，也就是要让权值越大的节点离根节点越近。</li><li><em><strong>WPL最小的就是赫夫曼树</strong></em>，<strong>图解</strong>(e.g.中间的是赫夫曼树)：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181916896.png" alt="image-20241105201026809" style="zoom:80%;" /><h2 id="创建赫夫曼树">创建赫夫曼树</h2><h3 id="思路分析-7">思路分析</h3><p>构成赫夫曼树的<strong>步骤</strong>：</p><ol><li>将数据从小到大排序(首次，将每个数据都看作根节点) / 或根据每棵树的根节点进行排序(非首次–or通用讲法)。</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小再次排序（也就是回到第一步）。不断重复 ，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><p><strong>简单理解</strong>：一，排序；二，取出最小两颗，组成新树，根节点为；三，回到第一步。（也就是图解中，三张图片为一轮）</p><p><strong>图解</strong>：</p><p>以${ 15,8,6,1,20,10 }$为例</p><ul><li>执行第一步排序，得到${ 1,6,8,10,15,20 }$，相当于有6棵树，每棵树都是一个单独的节点：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181928786.png" alt="image-20241105204913658" style="zoom:80%;" /><ul><li>第二步，取出最小的两颗二叉树；第三步，新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181940799.png" alt="image-20241105205229638" style="zoom:80%;" /><ul><li>第四步（也可以说是回到），再以新的这些树的<strong>根节点</strong>进行从小到大排序：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181953985.png" alt="image-20241105205419103" style="zoom:80%;" /><ul><li>开始重复：再次执行第一步（上面已经排有序了）。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182006239.png" alt="image-20241105210527613" style="zoom:80%;" /><ul><li>再排序：(注意！实际代码运行此处有差异！)</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182018290.png" alt="image-20241105210700873" style="zoom:80%;" /><ul><li>再取、再排：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182030635.png" alt="image-20241105211006627" style="zoom:80%;" /><ul><li>再取、再排：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182041472.png" alt="image-20241105211150432" style="zoom:80%;" /><ul><li>最后一步——赫夫曼树的降临：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182052046.png" alt="image-20241105211319376" style="zoom:80%;" /><blockquote><p>（上述仅能展示思路！！但是最终的二叉树视代码实现而定！！）</p><blockquote><p>我的实现代码中，最终得到的huffmanTree就不是上面这个形状的，原因在于有一步的排序过程——出现了两个根节点为15的树。</p><p>我的代码中，采取的策略是——新生成的树都是在ArrayList末尾进行add，然后再排序，所以新生成、根节点为15的树应该在旧的那个之后……下面给出修改后过程（中间有所不同）</p><blockquote><p>为什么前序遍历后怎么和预期不一样……问题就出在这里……</p></blockquote></blockquote></blockquote><p>小结：赫夫曼树根据排序方式的不同，最终形成的赫夫曼树的结构也不同。但是WPL一致、最小。这里的&quot;排序方法&quot;语义较小，是指遇到相同元素的情况下，该如何排序。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182102706.png" alt="image-20241106113028048" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182112861.png" alt="image-20241106113522437" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182126042.png" alt="image-20241106113642780" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182137600.png" alt="image-20241106113746002" style="zoom:80%;" /><p>所以代码的前序遍历应该为：</p><p>$60 \quad 25 \quad 10 \quad 15 \quad 35 \quad 15 \quad 7 \quad 1 \quad 6 \quad 8 \quad 20$</p><h3 id="代码实现-7">代码实现</h3><p><code>HuffmanTree</code></p><p>主要代码：<code>createHuffmanTree</code>创建赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;13, 7, 8, 3, 29, 6,1&#125;;</span></span><br><span class="line"><span class="comment">//        int [] arr = &#123;&#125;;</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;huffman tree is empty&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出次小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//构建新子树：</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.weight+ rightNode.weight,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//删除已处理的，加入新的树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回这棵树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> weight) &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> weight, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">//表示从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历：(用于测试)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼编码">赫夫曼编码</h2><h3 id="思路分析-8">思路分析</h3><blockquote><p>直接采用atguigu的介绍：<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=115">视频链接</a>。</p></blockquote><p><strong>基本介绍</strong></p><p>赫夫曼编码也翻译为<strong>哈夫曼编码(Huffman Coding)</strong>，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p><p>赫夫曼编码广泛地用于<strong>数据文件压缩</strong>。其压缩率通常在20%～90%之间</p><p>赫夫曼码是**可变字长编码(VLC)**的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p><p><strong>原理</strong>：</p><ol><li><p>通信领域中信息的处理方式1-定长编码</p><ul><li><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</li><li><code>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97</code>//对应Ascii码</li><li><code>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001</code>//对应的二进制</li><li>按照二进制来传递信息，总的长度是  359   (包括空格)</li><li><a href="https://www.mokuge.com/tool/asciito16/">在线转码工具</a></li></ul></li><li><p>通信领域中信息的处理方式2-变长编码</p><ul><li><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</li><li><code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5  空格:9</code>// 各个字符对应的个数</li><li><code>0=空格 ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</code> 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.</li><li>按照上面给各个字符规定的编码，则我们在传输  “i like like like java do you like a java” 数据时，编码就是10010110100…</li></ul></li></ol><ul><li><blockquote><p>但是这种编码方式不是<strong>前缀编码</strong>[^9]，会出现二义性。</p></blockquote></li></ul><ol start="3"><li><p>通信领域中信息的处理方式3-赫夫曼编码</p><ul><li><p><code>i like like like java do you like a java</code>       // 共40个字符(包括空格)</p></li><li><p><code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</code>  // 各个字符对应的个数</p></li><li><p>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值。</p></li></ul></li></ol><p><strong>赫夫曼编码详解</strong>：</p><p>传输的字符串为：<code>i like like like java do you like a java</code></p><ol><li>统计各个字符对应的个数<code>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</code></li><li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值（字符也要传入）</li></ol><blockquote><p>也就是传入$arr=[1,1,1,2,2,2,4,4,4,5,5,9]$去<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>：</p><p>构成赫夫曼树的步骤：</p><ol><li><p>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p></li><li><p>取出根节点权值最小的两颗二叉树</p></li><li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p></li><li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182149929.png" alt="image-20241106133401235" style="zoom:80%;" /></blockquote><ol start="3"><li>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下：<code>o:000u: 10010d: 100110  y: 100111  i: 101a : 110  k: 1110  e: 1111  j: 0000  v: 0001l: 001   : 01</code></li><li>按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot;   字符串对应的编码为 (注意这里我们使用的无损压缩)<code>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</code>通过赫夫曼编码处理  长度为  133</li><li>长度为:133 说明:原来长度是  359 , 压缩了  (359-133) / 359 = 62.9%。此编码满足前缀编码,，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。赫夫曼编码是无损处理方案。</li></ol><h3 id="数据压缩">数据压缩</h3><p><strong>思路</strong>：</p><ol><li>Node { data (存放数据)， weight (权值)， left  和 right }</li><li>得到  “i like like like java do you like a java”   对应的 byte[] 数组</li><li>编写一个方法，将准备构建赫夫曼树的Node 节点放到 List  , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]…],  体现 d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9</li><li>可以通过List 创建对应的赫夫曼树</li></ol><p><strong>代码解释</strong>：</p><p>这个代码过程较多，但是每一部分并不难。<br>简单归纳下：总体的目标是把原始数据对应的<code>byte[]</code> 压缩为更小的<code>byte[]</code></p><ol><li><p>获取原始数据的byte[]</p></li><li><p>将这个根据这个byte[]构建赫夫曼树，规则详见<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>，这里简单回顾：</p><ul><li>排序-》取出两个最小的节点，构成新节点-》删除两个最小节点，将新的节点加入到数组-》只要数组长度大于1，就循环整个操作-》最后通过nodesArray.get(0)就获取到了赫夫曼树的根节点。</li></ul><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182204232.png" alt="image-20241106163538269" style="zoom:67%;" /></blockquote></li><li><p>创建<strong>赫夫曼树</strong>后，就要利用赫夫曼树，得到对应的<strong>赫夫曼编码</strong>，规则为——为每一个叶子节点的值data编一个&quot;码&quot;，这个码就是从根节点到叶子节点的路径，每向左拼接一个&quot;0&quot;，每向右拼接一个&quot;1&quot;。最终得到赫夫曼编码，存放在Map&lt;key,value&gt;中，key就是数据，比如97('a’的ASCII)，value就是对应的码，比如01</p></li></ol><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182216330.png" alt="image-20241106163609031" /></blockquote><ol start="4"><li>根据这个赫夫曼编码，可以将原始数据压缩，压缩过程又细分两步：<ol><li>由于光是通过赫夫曼编码处理后，得到的只是&quot;0100110101010…&quot;这样的<strong>字符串</strong>，甚至比原先的字符串还长，所以要将这个字符串转换为8位一个的byte</li><li>第二步就是转换，不足8位就截断。<code>huffmanCodeBytes[k] = (byte) Integer.parseInt(strByte, 2);</code>其中，strByte是每次取了8位（不足就截断）。</li></ol></li><li>最后得到的<code>huffmanCodeBytes</code>就是最终结果（类型为<code>byte[]</code>，且长度比<code>str.getBytes()</code>要短，就做到了压缩）</li></ol><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182226996.png" alt="image-20241106164313508" style="zoom: 80%;" /></blockquote><p>可能需要补充的知识？</p><p>原码、反码、补码的转换。（也就是在压缩过程，为什么从&quot;10101000&quot;变成huffmanCodeBytes中的-88）</p><p>10101000(补码)-&gt;10100111(反码)-&gt;11011000(原码)</p><p>补码-1 = 反码；符号位不变，反码取反=原码。原码对应值计算为-88。</p><h4 id="实现1">实现1</h4><p><code>HuffmanCode</code></p><blockquote><p>若对此代码不懂，再看一遍：<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=117">p117</a>至<a href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=120">p120</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();</span><br><span class="line">        System.out.println(<span class="string">&quot;还未压缩前的长度：&quot;</span> + contentBytes.length);</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;nodes：&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建赫夫曼树为：&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        huffmanTreeRoot.preOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot);</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); <span class="comment">//(其实不新生成也行，如上)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;生成的赫夫曼编码为：&quot;</span> + HuffmanCode.huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(<span class="string">&quot;huffmanCodeBytes：&quot;</span>+Arrays.toString(huffmanCodeBytes));</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩率为:&quot;</span>+(contentBytes.length-huffmanCodeBytes.length * <span class="number">1.0</span>) / contentBytes.length * <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="封装后实现2">封装后实现2</h4><p><code>HuffmanCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输入的原始数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span>+Arrays.toString(huffmanBytes));</span><br><span class="line"><span class="comment">//        对此部分进行封装：</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;还未压缩前的长度：&quot; + contentBytes.length);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //通过getNodes方法得到byte[]数组对应的节点（）</span></span><br><span class="line"><span class="comment">//        List&lt;Node&gt; nodes = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;nodes：&quot; + nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;创建赫夫曼树为：&quot;);</span></span><br><span class="line"><span class="comment">//        Node huffmanTreeRoot = createHuffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        huffmanTreeRoot.preOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot);</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); //(其实不新生成也行，如上)</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生成的赫夫曼编码为：&quot; + HuffmanCode.huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeBytes：&quot;+Arrays.toString(huffmanCodeBytes));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩率为:&quot;+(contentBytes.length-huffmanCodeBytes.length * 1.0) / contentBytes.length * 1.0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes,huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据解压">数据解压</h3><p><strong>思路</strong>：</p><ol><li>将赫夫曼压缩后的字节数组转换为  二进制字符串。使用<code>byteToBitString</code>方法</li><li>再将这个二进制字符串 对照 赫夫曼编码 转换为原始字符串。使用<code>decode</code>方法</li></ol><p><code>HuffmanCode</code></p><blockquote><p>注意：此代码有bug（没修）——如果最后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span> + Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(sourceBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件的压缩和解压">文件的压缩和解压</h3><p><code>zipFile</code>方法和<code>unZipFile</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//        String srcFile = &quot;C:\\Users\\26423\\Desktop\\ceshi22.bmp&quot;;</span></span><br><span class="line"><span class="comment">//        String dstFile =&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;;</span></span><br><span class="line"><span class="comment">//        zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩文件成功&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi2333.bmp&quot;</span>;</span><br><span class="line">        unZipFile(zipFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压文件成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对文件的解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义文件输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和 is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组 huffmanCodes</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//写数据到dstFile文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 希望压缩的文件的完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 压缩后的文件放到哪个目录下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//这里以对象流的形式写入 赫夫曼编码（是为了以后恢复源文件时使用）</span></span><br><span class="line">            <span class="comment">//注意一定要把赫夫曼编码写入压缩文件（不然恢复不了）</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件压缩注意事项">文件压缩注意事项</h3><ol><li>如果文件本身就是经过压缩的，那么使用赫夫曼编码压缩后大小不会有明显变化，比如视频、ppt、png。</li><li>赫夫曼编码是按字节来处理的，因此可以处理所有文件（二进制文件、文本文件）(.xml)</li><li>如果一个文件中的内容重复数据不多，压缩效果也不会很明显。</li></ol><h1>二叉搜索树</h1><h2 id="基本介绍">基本介绍</h2><p><strong>二叉搜索树</strong>，<strong>BST(Binary Search Tree)</strong>，对于二叉搜索树的任何一个<strong>非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。如果有相同的值，可以放在左子节点或右子节点。</p><h2 id="二叉搜索树的创建和遍历">二叉搜索树的创建和遍历</h2><p>新加入节点时：</p><ol><li>若新加入节点为空，直接返回。</li><li>比较插入值和当前节点值大小，若小于当前节点值，判断左节点是否为空，若为空，直接插入到左节点，否则向左递归地插入</li><li>否则（大于等于），判断右节点是否为空，若为空则直接插入到右节点，否则向右递归地插入</li></ol><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试二叉搜索树的中序遍历：&quot;</span>);</span><br><span class="line">        bst.inOrder();<span class="comment">//发现刚好是升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树节点的删除">二叉搜索树节点的删除</h2><h3 id="思路分析-9">思路分析</h3><blockquote><p>由于删除时情况较多（但是不难），所以还是需要理一下所有可能的情况</p></blockquote><p>分以下三种情况：</p><ol><li>删除叶子节点</li><li>删除只有1颗子树的节点</li><li>删除有2颗子树的节点</li></ol><p><strong>具体思路</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182238374.png" alt="image-20241108193248201" style="zoom:80%;" /><ol><li><p>若删除叶子节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，再删除。</li></ul></li><li><p>删除只有一颗子树的节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，以及确定<code>targetNode</code>是有左子树还是右子树</li><li>因此有四种情况：<ul><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有左子树——<code>parent.left = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有右子树——<code>parent.left = targetNode.right</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有左子树——<code>parent.right = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有右子树——<code>parent.right = targetNode.right</code></li></ul></li><li>删除5为例：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182250598.png" alt="image-20241108193304227" style="zoom:80%;" /></li></ul></li><li><p>删除有两颗子树的节点</p><ul><li><p>先要找到目标节点<code>targetNode</code></p></li><li><p>在找的同时，要用<code>parentNode</code>标记其父节点</p></li><li><p>从<code>targetNode</code>的右子树里找到最小的节点    （或从<code>targetNode</code>的左子树里找最大的节点（同样的流程））</p></li><li><p>如图找到：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182303500.png" alt="image-20241108193645936" style="zoom:80%;" /></p></li><li><p>用<code>temp</code>临时存储最小节点<code>minNode</code>的值，删除<code>minNode</code>，这一步删除有点特殊：<code>targetNode.left = minNode.right</code>。这是一句通用的写法，可以适应不同情况：因为既然是在<code>targetNode</code>的右子树里找的<code>minNode</code>，所以其左边必定无节点，且无论其右节点是否为空，都可以这样子写。</p></li><li><p>如图删除：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182315889.png" alt="image-20241108194225832" style="zoom:80%;" /></p></li><li><p>删除<code>targetNode</code>，即<code>targetNode.value = temp</code></p></li><li><p>如图：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182333482.png" alt="image-20241108194625603" style="zoom:80%;" /></p></li></ul></li><li><p>特别注意！上述找到的<code>parentNode</code>可能为null，说明要删除的节点是root节点。</p></li></ol><blockquote><p>思考：上述思路可能有可以改进的地方——也就是&quot;<strong>找到要删除的节点的父节点</strong>&quot;，为了这个父节点，代码实现中还特地写了一个独立的方法去查找。好处是清晰，坏处是可能效率略降低？（原路多找一次）。</p><p>可能的改进思路：可以把<code>search</code>待删除节点的方法作一定修改：可以返回一个集合，里面装两个节点（被删除节点和父节点）；可以直接返回父节点，后续删除时只是需要多判断一下其左右节点哪个是要被删除的，如何保证被删除的节点的稳定——通过<code>if(this.left.value == val)</code>来判断？那么左右节点值都一样呢？（以及万一是根节点要被删除，那么如何返回这个父节点的问题）</p><p>代码暂时不作优化。</p></blockquote><h3 id="代码实现-8">代码实现</h3><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试delNode方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除前：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">        bst.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">        <span class="keyword">if</span>(targetNode == <span class="literal">null</span>) <span class="keyword">return</span>;<span class="comment">//找不到待删除节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">        <span class="keyword">if</span>(parentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明要删除的节点就是root节点（也要分三种……）</span></span><br><span class="line">            <span class="comment">//如果左右为空，直接删</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左右都有子树，选取右子树中最小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//temp 为 找到的root的右子树的最小节点</span></span><br><span class="line">                <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentOfTemp = temp;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                parentOfTemp.left = temp.right;</span><br><span class="line">                root.value = temp.value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有左或右，直接更新root</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>) root = root.left;</span><br><span class="line">                <span class="keyword">else</span> root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的节点不是root（保证了操作parentNode时不出错）</span></span><br><span class="line">        <span class="comment">//1.待删除节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(parentNode.left!=<span class="literal">null</span> &amp;&amp; parentNode.left.value == value) parentNode.left =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> parentNode.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.待删除节点有左子树和右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//temp 为 找到的targetNode的右子树的最小节点</span></span><br><span class="line">            <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> targetNode.right;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> targetNode;</span><br><span class="line">            <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parentOfTemp = temp;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            parentOfTemp.left = temp.right;</span><br><span class="line">            targetNode.value = temp.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.待删除节点只有左子树或右子树</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//目标节点在parentNode的左边</span></span><br><span class="line">            <span class="keyword">if</span>(parentNode.left != <span class="literal">null</span> &amp;&amp; parentNode.left.value == value)&#123;</span><br><span class="line">                <span class="comment">//目标节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.left = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.left = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//目标节点在parentNode的右边</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.right = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.right = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//我总是忘记--这种判断自身是否为空的操作……但其实很必要加，不然就会报空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找待删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) || (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不好的写法，是暴力查找！</span></span><br><span class="line"><span class="comment">//            if(this.left != null) return this.left.searchParent(value);</span></span><br><span class="line"><span class="comment">//            if(this.right != null) return this.right.searchParent(value);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//效率高的写法：</span></span><br><span class="line">            <span class="comment">//如果要查找的值小于当前的值，且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找为value的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明找不到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);<span class="comment">//递归地继续找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>后记：代码中有一部分可以拿出来作为一个方法<code>int delRightTreeMin(Node node)&#123;&#125;</code></p><p>说明：<code>node</code>为传入的结点，方法作用是删除以node为根节点这棵二叉排序树的最小根节点，最后返回最小节点<code>minNode</code>的值。</p><p>ps：该方法可用于替换代码中的两部分——一是待删除结点有左右子树且待删除结点就是root，二是待删除结点有左右子树且待删除结点不是root。</p></blockquote><h1>平衡二叉树</h1><p><strong>问题</strong>：</p><p>如下图可见<strong>二叉搜索树</strong>可能存在的问题:</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182346268.png" alt="image-20241109195852364" style="zoom:80%;" /><p>有以下问题：1.左子树都为空，更像单链表；2.插入速度没有影响，但查询速度大幅减低(每次向下一层前还需要和左比较，比链表还慢)，不能发挥BST（BinarySearchTree）的查询优势。</p><p>解决方案：<strong>平衡二叉树（AVL）</strong></p><p><strong>基本介绍</strong></p><ol><li><strong>平衡二叉树</strong>也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）<strong>又被称</strong>AVL树</strong>，可以保证<strong>查询效率较高</strong>。</li><li>特点：<ul><li>是一颗<strong>空树</strong>或它的<strong>左右子树的高度差的绝对值不超过1</strong>。</li><li><strong>左右子树都是一棵平衡二叉树</strong>。</li></ul></li><li>常用实现算法有：红黑树、AVL、替罪羊树、Treap、伸展树等</li></ol><p>为了使得一棵普通的二叉搜索树变成平衡二叉树，也就是让左右子树的高度差降低，我们引出一些方法——e.g.<strong>左旋转</strong>、<strong>右旋转</strong>、<strong>双旋转</strong></p><h2 id="左旋转">左旋转</h2><p>适用于右子树高度大于左子树的情况</p><p><strong>左旋转步骤</strong>：</p><ol><li>保存当前节点的值，已该值创建<code>newNode</code></li><li>将<code>newNode</code>的left设置为当前节点的左子树</li><li>将<code>newNode</code>的right设置为当前节点的右子树的左子树</li><li>将当前节点的值更新为右子树的值</li><li>将当前节点的right设置为右子树的右子树</li><li>将当前节点的left设置为<code>newNode</code></li></ol><p><strong>左旋转图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182400936.png" alt="image-20241110094040328" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182412965.png" alt="image-20241110094207819" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182432522.png" alt="image-20241110094235038" style="zoom:80%;" /><p>至此，这棵树就符合平衡二叉树的定义。</p><p>可以看出：左旋转用于当一棵树的左子树的高度小于右子树的高度时。（记忆，想象一个旋钮，把它往左边旋转，那么右边就&quot;旋上去&quot;，右边高度就降低了）</p><h3 id="代码实现-9">代码实现</h3><ol><li>新增三个方法<code>height</code>、<code>leftHeight</code>、<code>rightHeight</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回右子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回左子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以当前结点为根节点的树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>左旋转方法<code>leftRotate</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建新节点，记录当前节点的值</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="comment">//2. 将newNode的left设置为当前节点的左子树</span></span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">    <span class="comment">//3. 将newNode的right设置为当前节点的右子树的左子树</span></span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right.left;<span class="comment">//****这里不用判断有没有右子树，因为如果this.right为空的话，也不可能会导致右子树比左子树高，更不会执行左旋转*****</span></span><br><span class="line">    <span class="comment">//4. 将当前节点的值更新为右子树的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">    <span class="comment">//5. 将当前节点的right设置为右子树的右子树</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">    <span class="comment">//6. 将当前节点的left设置为newNode</span></span><br><span class="line">    <span class="built_in">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋转">右旋转</h2><p>适用于左子树高度大于右子树的情况</p><p><strong>右旋转步骤</strong>：</p><ol><li>保存当前结点的值，以该值创建<code>newNode</code></li><li>将<code>newNode</code>的right设置为当前节点的右子树</li><li>将<code>newNode</code>的left设置为当前结点的左子树的右子树</li><li>将当前结点的值更新为左子树的值</li><li>将当前结点的left设置为左子树的左子树</li><li>将当前结点的right设置为<code>newNode</code></li></ol><p><strong>右旋转图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182504801.png" alt="image-20241110133603478" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182514707.png" alt="image-20241110133631995" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182524611.png" alt="image-20241110133707683" style="zoom:80%;" /><h3 id="代码实现-10">代码实现</h3><p><code>rightRotate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">    <span class="built_in">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加节点时使用左旋转和右旋转方法：</p><p><code>Node.add</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归地添加节点的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span>(rightHeight()-leftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">if</span>(leftHeight()-rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双旋转">双旋转</h2><p>有情况下，仅凭一次左旋转或右旋转是无法使的二叉搜索树转换为平衡二叉树的。</p><p>e.g.<code>int[] arr=&#123;10,11,7,6,8,9&#125;;</code>此时发现，经过一次右旋转后，反而使得右子树的高度比左子树的高度大1。</p><p><strong>图示</strong>：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182537421.png" alt="image-20241110141336862" style="zoom:80%;" /></p><p><strong>解决方法——双旋转思路+图解</strong>：</p><ol><li><p>当<strong>符合右旋转</strong>的条件时（<code>this.leftHeight() - this.rightHeight() &gt; 1</code>）<br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182549008.png" alt="image-20241110141635728" style="zoom:80%;" /></p></li><li><p>且如果它的 <strong>左子树的右子树的高度 大于 左子树的左子树的高度</strong>，即<code>this.left.rightHeight() &gt; this.left.leftHeight()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182559575.png" alt="image-20241110142528639" style="zoom:80%;" /></p></li><li><p>先需<strong>对当前节点的左子树进行左旋转</strong>，即<code>this.left.leftRotate()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182610683.png" alt="image-20241110142933085" style="zoom:80%;" /></p></li><li><p>再对当前节点进行右旋转，即<code>this.rightRotate()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182622396.png" alt="image-20241110143304696" style="zoom:80%;" /></p></li></ol><blockquote><p>如果是“<strong>当符合左旋转</strong>”的条件时，且“它的 <strong>右子树的左子树的高度 大于 右子树的右子树的高度</strong>”</p></blockquote><h3 id="代码实现-11">代码实现</h3><p><code>Node.add</code>方法的修改，使其能够进行双旋转（可以对比<a href="####%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">右旋转代码实现</a>里面的add方法，有什么区别）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的右子树的左子树的高度 大于 它的右子树的右子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.leftHeight() &gt; <span class="built_in">this</span>.right.rightHeight()) &#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的右结点 进行右旋转</span></span><br><span class="line">            <span class="built_in">this</span>.right.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的左子树的右子树的高度 大于 它的左子树的左子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.rightHeight() &gt; <span class="built_in">this</span>.left.leftHeight())&#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的左结点 进行左旋转</span></span><br><span class="line">            <span class="built_in">this</span>.left.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>多叉树</h1><p><strong>二叉树存在问题</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182634337.png" alt="image-20241110144142213" style="zoom:80%;" /><ol><li>二叉树加载到内存时，如果节点数量过多，会存在问题：</li><li>构建二叉树时，需进行多次i/o操作（海量数据一般在文件或数据库中），对构建效率有影响。</li><li>海量数据也会造成树的高度过大（谁告诉你一定是满二叉树?）</li></ol><p><strong>多叉树基本介绍</strong></p><ol><li>在二叉树中，每个结点有数据项，最多有两个子节点。如果允许每个结点可以有更多的数据项和子结点，就是<strong>多叉树（Multiway Tree）</strong></li><li>2-3树、2-3-4树就是多叉树，多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化</li><li>举例图：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182644649.png" alt="image-20241110144751794" style="zoom:80%;" /><p><strong>B树基本介绍</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182654628.png" alt="image-20241110115227975" style="zoom:80%;" /><ol><li>B树通过重新组织结点，降低树的高度，减少了i/o读写次数来提升效率</li><li><strong>文件系统及数据库系统的设计者利用了磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页</strong>(页得大小通常为4k)，这样<strong>每个节点只需要一次I/O</strong>就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中</li></ol><p><strong>2-3树基本介绍</strong></p><p>2-3树是最简单的B树结构，具有如下特点:</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>（B树都满足）</li><li>有两个子节点的节点叫<strong>二节点</strong>，二节点<strong>要么没有子节点</strong>，<strong>要么有两个</strong>子节点</li><li>有三个子节点的节点叫<strong>三节点</strong>，三节点<strong>要么没有子节点</strong>，<strong>要么有三个</strong>子节点</li><li>2-3树是由<strong>二节点和三节点</strong>构成的树。</li></ol><h2 id="2-3树">2-3树</h2><p><strong>关于三节点的说明</strong>：</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182708712.png" alt="image-20241110144908830" style="zoom:80%;" />7号节点在8号左边，10号介于8和12中间，14在12右边。</p><p><strong>构建2-3树</strong>：</p><p><strong>插入规则</strong>：</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>。（B树都满足这个条件）</li><li>二节点要么没有子节点，要么有两个子节点。</li><li>三节点要么没有子节点，要么有三个子节点。</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆</strong>，<strong>如果上层满，则拆本层</strong>，拆后仍然需要满足上面3个条件。</li><li>对于三节点的子树的值大小仍然遵守（BST 二叉搜索树）的规则</li></ol><p><strong>图解</strong>：</p><p>以数列${ 16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20 } $为例</p><ol><li>插入16，24，12，32。十分自然：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182719769.png" alt="image-20241110164703683" style="zoom:80%;" /><ol start="2"><li>插入14（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182735098.png" alt="image-20241110164746993" style="zoom:80%;" /><ol start="3"><li>插入26（需拆上一层）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182746622.png" alt="image-20241110164905390" style="zoom:80%;" /><ol start="4"><li>插入34（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182756249.png" alt="image-20241110165036078" style="zoom:80%;" /><ol start="5"><li>插入10（复杂）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182805896.png" alt="image-20241110165746037" style="zoom:150%;" /><ol start="6"><li>插入8（自然）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182817198.png" alt="image-20241110170229138" style="zoom:80%;" /><ol start="7"><li>插入28（中间过程演示）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182829094.png" alt="image-20241110170605919" style="zoom:80%;" /><ol start="8"><li>插入38（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182839077.png" alt="image-20241110170903042" style="zoom:80%;" /><ol start="9"><li>插入20（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182848306.png" alt="image-20241110170950636" style="zoom:80%;" /><h2 id="2-3-4树">2-3-4树</h2><p>2-3-4树概念和2-3树类似，多了一个四节点，也是一种B树</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182858787.png" alt="image-20241110121240298" style="zoom:80%;" /><h2 id="B树">B树</h2><p><strong>B-tree树</strong>即<strong>B树</strong>，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，<strong>B-tree就是指的B树</strong>。（还有写成<strong>B-树</strong>的，实际上没有&quot;B减树&quot;，就是B树）</p><ol><li><strong>B树的阶</strong>：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li><li><strong>B树的搜索</strong>：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong></li><li>搜索<strong>有可能在非叶子结点结束</strong>（已找到）</li><li>其搜索性能<strong>等价于在关键字全集内做一次二分查找</strong></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182939663.png" alt="image-20241110171831364" style="zoom:80%;" /><h2 id="B-树">B+树</h2><p>B+树是B树的变体，也是一种多路搜索树。</p><ol><li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li><li>不可能在非叶子结点命中</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li><li>更适合文件索引系统</li><li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182950012.png" alt="image-20241110172528554" style="zoom:80%;" /><h2 id="B-树-2">B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p><ol><li>B* 树定义了非叶子结点关键字个数至少为$\frac{2}{3}M$，即块的最低使用率为$\frac{2}{3}$，而B+树的块的最低使用率为B+树的$\frac{1}{2}$。</li><li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——哈希表</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>哈希表(散列)</h1><h2 id="思路分析">思路分析</h2><p><strong>基本介绍</strong>：</p><p>散列表（也叫哈希表），是根据关键码值而直接进行访问的数据结构。</p><p>它通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><strong>哈希表的价值</strong>：</p><p>对于经常要使用的数据，放在缓存层使用，减少了数据库的压力。哈希表相当于起到了一个缓存层的作用。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/哈希表/blog-20250501181628969.png" alt="image-20241103095217216" style="zoom:80%;" /><p><strong>图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/哈希表/blog-20250501181641675.png" alt="image-20241102202555264" style="zoom:80%;" /><p>此处用一个实际题目来使用哈希表：</p><p>（google公司上机题:）有一个公司，当有新员工来报到时，要求将该员工的信息加入(id，性别，年龄，住址……)，当输入该员工的id时，要求查找到该员工的所有信息。要求不适用数据库，尽量节省内存，速度越快越好=》哈希表（散列）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/哈希表/blog-20250501181655290.png" alt="image-20241102203438163" style="zoom:80%;" /><p><strong>思路分析</strong>：</p><ol><li>使用Emp类管理每个员工的信息。</li><li>使用EmpLinkedList表示一条链表。</li><li>HashTable就是真正的哈希表，里面包含了增加、遍历、查找、删除操作。但是必须有<strong>散列函数</strong>，其作用是指示id对应的链表。</li></ol><h2 id="代码实现">代码实现</h2><p><code>HashTabDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.hashTab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a：增加员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;l：显示员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;f：查找员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d：删除员工&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入id:&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入名字:&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    hashTab.add(<span class="keyword">new</span> <span class="title class_">Emp</span>(id, name));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span> -&gt; &#123;</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要查找的员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入你要删除的员工id：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    hashTab.deleteByEmpId(id);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Emp</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//默认为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Emp</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//此处的head就是第一个员工</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    假定添加员工时，id自增长（从小到大），则将员工添加到最后即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = emp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;List:&quot;</span> + no + <span class="string">&quot; is empty&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;=&gt; id:&quot;</span> + p.id + <span class="string">&quot; name:&quot;</span> + p.name);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.id == id) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByEmpId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法删除，未找到该员工&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">Emp</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.id == id)&#123;</span><br><span class="line">                    prev.next = p.next;<span class="comment">//删除p节点</span></span><br><span class="line">                    System.out.printf(<span class="string">&quot;员工%d：%s已成功删除\n&quot;</span>,p.id,p.name);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;无法删除，未找到该员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashTab用于管理多条链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//表示有几条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//不要忘了分别初始化！！！！！上述只是得到了一个数组Array，里面全为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//根据员工id得到该员工应该添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(emp.id);</span><br><span class="line">        empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有链表，遍历hashTab（数组+链表才是hashTab）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据输入的id查找员工</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//使用散列函数，确定到哪条链表查找（提高查找速度的关键所在！）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        emp = empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在第&quot;</span>+empLinkedListNo+<span class="string">&quot;条链表中找到员工：&quot;</span>+<span class="string">&quot;id:&quot;</span> + emp.id + <span class="string">&quot; name:&quot;</span> + emp.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到该员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByEmpId</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNo</span> <span class="operator">=</span> hashFun(id);<span class="comment">//根据散列函数，定位该id所在链表</span></span><br><span class="line">        empLinkedListArray[empLinkedListNo].deleteByEmpId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数（写法很多，此处用%）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——栈</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1>栈</h1><h2 id="数组模拟栈实现">数组模拟栈实现</h2><h3 id="思路分析">思路分析</h3><ol><li><p>栈(stack)是一个<strong>后进先出</strong>的有序列表。</p></li><li><p>栈是限制线性表中元素的插入和删除操作只能在线性表的同一端进行的特殊线性表。允许<strong>插入和删除</strong>的一端，为<strong>变化的一端</strong>，称为<strong>栈顶</strong>；另一端为<strong>固定的一端</strong>，称为<strong>栈底</strong>。</p></li><li><p>常用方法：</p><ul><li><code>pop</code>出栈，先判断<code>isEmpty</code>，<code>return arr[top--]</code>先返回数据，后将top指针向下移动。</li><li><code>push</code>入栈，先判断<code>isFull</code>是否已满，若无，再<code>arr[++top]</code>，先指向下一个位置，再入栈。</li><li><code>isFull</code>判断是否为空，<code>top == -1</code></li><li><code>isEmpty</code>判断是否已满，<code>top == maxSize-1</code></li></ul></li><li><p>应用场景：</p><ul><li>子程序的调用：在跳往子程序前，先将下个指令的地址存到堆栈中，等子程序执行完了，再将地址取出，继续执行源程序。</li><li>递归调用：和子程序的调用类似，不过除了存储下一个指令的地址外，还将参数、区域变量等数据存入堆栈。</li><li>表达式的转换[<strong>中缀表达式转后缀表达式</strong>]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图的深度优先搜索法。</li></ul></li></ol><h3 id="代码实现">代码实现</h3><p><code>ArrayStack</code></p><blockquote><p>后续的<a href="##%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8">栈实现简易计算器</a>也基于下方代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is empty，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is full，无法入栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++top] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Stack is empty，无法获取栈顶元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法仅为自己查看方便</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;栈arr[%d]=%d \n&quot;</span>, i, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ArrayStackDemo</code></p><blockquote><p>就不写一个简易的用户界面了（与前类似）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stack.push(<span class="number">5</span>);</span><br><span class="line">            stack.push(<span class="number">6</span>);</span><br><span class="line">            stack.push(<span class="number">7</span>);</span><br><span class="line">            stack.push(<span class="number">8</span>);</span><br><span class="line">            stack.push(<span class="number">9</span>);</span><br><span class="line"><span class="comment">//            stack.push(10);</span></span><br><span class="line"></span><br><span class="line">            stack.traverse();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;出栈：&quot;</span>+stack.pop());</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.pop();</span><br><span class="line">            System.out.println(<span class="string">&quot;栈顶元素为：&quot;</span>+stack.top());</span><br><span class="line"></span><br><span class="line">            stack.traverse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈实现简易计算器">栈实现简易计算器</h2><h3 id="思路分析-2">思路分析</h3><p>例如要使用栈完成$2 * 50 - 2 + 8 \div 2 = ?$  $2+3*4 - 1$</p><blockquote><p>使用<strong>中缀表达式</strong>[^1]</p></blockquote><blockquote><p>数字可能不仅仅是个位，运算符号包括加+减-乘*除/，其他符号包括小括号、等号。（这一版代码先不考虑实现小括号）</p></blockquote><ol><li>使用一个索引<code>index</code>来遍历表达式</li><li>使用一个数栈<code>numStack</code>和一个符号栈<code>opStack</code>分别存放数字和运算符</li><li>使用一个<code>isNum</code>记录上一个输入的元素<ul><li>可用作判断输入数字是否为多位数，也可用作判断表达式输入是否有误(比如$1 + - 2$)</li></ul></li><li>当index遍历时，遇到：</li></ol><ul><li>数字。<ul><li>判断上一个入栈的元素，若也为数字，则说明是个多位数；</li><li>若上个入栈的不是数字，则直接入栈。</li></ul></li><li>运算符。<ul><li>如果符号栈为空，直接入栈</li><li>只要符号栈不为空，判断当前读取的符号和栈内符号的优先级。若当前符号的<strong>优先级小于等于</strong>栈内符号，则从数栈中<strong>不断</strong>出栈两个数字、符号栈中出栈一个符号进行运算，将结果入数栈；若当前符号<strong>优先级大于</strong>栈内符号，则继续入栈。</li></ul></li><li>小括号。<ul><li>若为左括号，则直接入符号栈；</li><li>若为右括号，判断栈顶符号——栈顶若为左括号，则说明当前表达式输入有误，若不是，则继续出栈，继续进行出栈时的符号判断，直至将左括号出栈，最后将运算结果入数栈。（小括号就相当于一个弱化版的等号，只是将括号范围内做运算）</li></ul></li><li>等号。每次从数栈取两个、符号栈取一个出栈，得到最终计算结果。</li></ul><blockquote><p>基于<a href="##%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%E5%AE%9E%E7%8E%B0">数组模拟栈实现</a>所使用的<code>ArraryStack</code>类（由于这个栈内存储元素仅为int类型，为了建立int与char类型符号的关联，还增加了一个枚举类）</p><blockquote><p><code>CV</code>前请注意文件目录结构</p></blockquote></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>Calculator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">100</span>);<span class="comment">//数栈</span></span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">opStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">100</span>);<span class="comment">//符号栈</span></span><br><span class="line">    <span class="type">boolean</span> isNum;<span class="comment">//记录上一个入栈的元素是否为数字</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">endCalculate</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasNoneUseChar</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//仅作为最终提示输出的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">caculate</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(String.valueOf(ch).matches(<span class="string">&quot;\\d&quot;</span>))&#123;</span><br><span class="line">                pushNum(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pushOp(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endCalculate)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNoneUseChar)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入了无关符号,仅支持0-9以及+-*/=,运算时已忽略无关符号&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numStack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算出错,是否是遗漏了&#x27;=&#x27;?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushNum</span><span class="params">(<span class="type">char</span> number)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(number));</span><br><span class="line">        <span class="keyword">if</span>(!isNum) &#123;<span class="comment">//上一个 是符号入栈</span></span><br><span class="line">            numStack.push(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp_num</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">            numStack.push(temp_num*<span class="number">10</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">        isNum = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushOp</span><span class="params">(<span class="type">char</span> operator)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOtherChar</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//排除输入其他符号的干扰</span></span><br><span class="line">        <span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(OperateEnum.PLUS.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(OperateEnum.MINUS.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span>  <span class="string">&#x27;*&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="comment">//一定要先判断是否为空，否则当第一个操作符为*时，会出现抛出异常</span></span><br><span class="line">                <span class="comment">//虽然下面的写法有部分代码重合，但是这样子写逻辑清晰：</span></span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty()) &#123;</span><br><span class="line">                    opStack.push(OperateEnum.TIMES.getCode());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opStack.isEmpty() &amp;&amp; (opStack.top()==<span class="number">3</span> || opStack.top()==<span class="number">4</span>)) &#123;</span><br><span class="line">                        <span class="comment">//第一个条件判断必须加，因为在operate后，可能使得opStack中为空！(例如1*1*1...)然后导致top()方法抛出异常</span></span><br><span class="line">                        operate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    opStack.push(OperateEnum.TIMES.getCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(opStack.isEmpty()) &#123;</span><br><span class="line">                    opStack.push(OperateEnum.DIVIDE.getCode());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!opStack.isEmpty() &amp;&amp; (opStack.top()==<span class="number">3</span> || opStack.top()==<span class="number">4</span>))&#123;</span><br><span class="line">                        operate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    opStack.push(OperateEnum.DIVIDE.getCode());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">while</span>(opStack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    operate();</span><br><span class="line">                &#125;</span><br><span class="line">                endCalculate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="built_in">this</span>.hasNoneUseChar = <span class="literal">true</span>;</span><br><span class="line">                isOtherChar = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isOtherChar)&#123;</span><br><span class="line">            isNum = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行一次运算：</span></span><br><span class="line">    <span class="comment">//从numStack取出两个数、从opStack取出一个符号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> opStack.pop();</span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1+num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1-num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>-&gt;&#123;</span><br><span class="line">                numStack.push(num1*num2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(num2==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;被除数不能为0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(num1/num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>OperateEnum</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;</span><br><span class="line">    PLUS(<span class="number">1</span>),</span><br><span class="line">    MINUS(<span class="number">2</span>),</span><br><span class="line">    TIMES(<span class="number">3</span>),</span><br><span class="line">    DIVIDE(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    OperateEnum(<span class="type">int</span> code) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>TestCalculator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukino.caculator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        String input = &quot;1*1*1-1*1*2+3*4-4/2-1+100-10*1=&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;1+1 0  )(&#123;&#125;= &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculator.caculate(input);</span><br><span class="line">            System.out.printf(<span class="string">&quot;计算结果为：%d&quot;</span>, res);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>后期留言：一点都不是“简易”计算器，实现过程会有很多小错误……Debug了很久</p></blockquote><h2 id="逆波兰计算器-经典">逆波兰计算器(经典)</h2><h3 id="思路分析-3">思路分析</h3><h4 id="中缀表达式转后缀表达式">中缀表达式转后缀表达式</h4><p><strong>思路步骤</strong>分析：</p><ol><li>初始化两个栈运算符栈<code>s1</code>和存储中间结果栈<code>s2</code></li><li>从左到右扫描<em>中缀表达式</em>[^1]</li><li>遇到操作数时，将其压入<code>s2</code></li><li>遇到运算符时，比较其与<code>s1</code>栈顶运算符的优先级：<ol><li>如果<code>s1</code>为空，或栈顶元素为<code>(</code>，则直接将该运算符入栈</li><li>否则，若优先级比栈顶元素高，也将该符号压入<code>s1</code></li><li>否则，将<code>s1</code>栈顶的运算符弹出压入<code>s2</code>中，再次转到4.1.与<code>s1</code>中新的栈顶元素比较</li></ol></li><li>遇到括号时：<ol><li>如果是左括号<code>(</code>，则直接压入<code>s1</code></li><li>如果是右括号<code>)</code>，则依次弹出<code>s1</code>中运算符并压入<code>s2</code>，直到遇到左括号<code>)</code>为止，此时就将这一对括号丢弃</li></ol></li><li>重复2.—5.步骤，直到表达式最右边</li><li>将<code>s1</code>中剩余的符号弹出压入<code>s2</code></li><li>依次弹出<code>s2</code>中元素并输出，<strong>结果的逆序</strong>即为中缀表达式所对应的后缀表达式</li></ol><blockquote><p><code>s2</code>可用队列优化（省去了取逆序）</p></blockquote><blockquote><p>代码实现均在<code>PolandNotation</code>中</p></blockquote><h4 id="利用后缀表达式计算">利用后缀表达式计算</h4><p>要求：</p><ol><li>输入一个<em>后缀表达式</em>[^1]（逆波兰表达式），利用栈（Stack）计算结果</li><li>支持小括号和多位整数</li></ol><h3 id="代码实现-3">代码实现</h3><p><code>PolandNotation</code></p><blockquote><p>输入后缀表达式，计算结果</p><p>计算很简单：遍历表达式(存到ArrayList中)遇到数就入栈遇到符号就取出两个数、计算、结果入栈最后栈中剩余的就是结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">        <span class="comment">//为了处理方便，逆波兰表达式的数字和符号间用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 * 6 - &quot;</span>;</span><br><span class="line">        <span class="comment">//1. 先将&quot;3 4 + 5 * 6 - &quot;放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2. 将ArrayList传递给一个方法，遍历ArrayList 配合栈，完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;计算结果为：%d&quot;</span>, calculate(rpnList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String ele: split)&#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; rpnList)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈（一个即可）</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历list</span></span><br><span class="line">        <span class="keyword">for</span>(String item:rpnList)&#123;</span><br><span class="line">            <span class="comment">//使用正则表达式取出数（正则表达式为多位数）</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//pop出两个数，运算，再将结果入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算法有问题&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line"><span class="comment">//                stack.push(&quot;&quot;+res);</span></span><br><span class="line">                stack.push(Integer.toString(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的就是结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——队列</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1>队列</h1><h2 id="数组模拟队列实现">数组模拟队列实现</h2><h3 id="思路分析">思路分析</h3><p>核心：<strong>先进先出</strong>，这也是队列应用场景的核心思路。</p><p>从代码的角度考虑</p><ol><li>我们需要一个arr[]数组来存储每一个元素</li><li>规定front指向<strong>第一个元素的前一个位置</strong>，front会随着数据的输出而改变。</li><li>规定rear指向<strong>最后一个元素的前一个位置</strong>，rear会随着数据的输入而改变。</li><li>当<code>rear == MAXSIZE - 1</code>时，队列满</li><li>当<code>rear == front</code>时，队列为空</li><li><code>enQueue</code>入队操作时<ul><li>先判断队列是否已满（使用isFull方法）</li><li>将尾指针后移<code>++rear</code>, 再入队列</li></ul></li><li><code>deQueue</code>出队操作时<ul><li>先判断队列是否为空（使用isEmpty方法）</li><li>将头指针后移<code>++front</code>，再出队列</li></ul></li><li><code>headQueue</code>查看队首元素，不能将使用<code>front+1</code>，不能移动front</li></ol><blockquote><p>最后注意一下可能会抛出异常的方法在调用时，要用trycatch包围。</p></blockquote><h3 id="代码实现">代码实现</h3><p><code>ArrayQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.ArrayQueueDemo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MAXSIZE;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队首的前一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//指向队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.MAXSIZE = size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == MAXSIZE - <span class="number">1</span>;<span class="comment">//是队列尾到达MAXSIZE-1,才说明满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++rear] = data;</span><br><span class="line">        System.out.printf(<span class="string">&quot;元素%d已入队\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[++front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但其实这个方法不应该有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front + <span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ArrayQueueDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.ArrayQueueDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(enQueue)入队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d(deQueue)出队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(showQueue)展示队列：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(headQueue)展示队列头部：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入你要入队的元素：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    arrayQueue.enQueue(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;元素%d已出队\n&quot;</span>, arrayQueue.deQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列中已有元素为:&quot;</span>);</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队首元素为%d\n&quot;</span>, arrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述代码基本实现了一个队列，但是存在问题：数组只能使用一次，不能复用！</p></blockquote><h2 id="数组模拟环形-循环队列实现">数组模拟环形/循环队列实现</h2><h3 id="思路分析-2">思路分析</h3><p>需充分利用数组空间，则可用<strong>取模</strong>来实现</p><ol><li>规定front为<strong>队首元素</strong>，初始值为0</li><li>规定rear为<strong>队尾的后一个元素</strong>，初始值为0</li><li>采取空余一个空间的方式，当<code>(rear+1)%MAXSIZE == front</code>时，说明队列已满。</li><li>当<code>fornt == rear</code>时，说明队列为空。</li><li><code>enQueue</code>入队列操作<ul><li>先判断队列是否已满<code>isFull</code></li><li>再插入元素：<code>arr[rear] = data</code>，更新rear：<code>rear = (rear+1)%MAXSIZE</code></li></ul></li><li><code>deQueue</code>出队列操作<ul><li>先判断队列是否为空<code>isEmpty</code></li><li>在出队列：<code>return arr[front]</code>，更新front：<code>front = (front+1)%MAXSIZE</code></li></ul></li><li>故，队列中有效数据的个数为：<code>(rear+MAXSIZE-front)%MAXSIZE</code>，不妨增加一个判断有效数据个数的方法</li></ol><blockquote><p>预留一个空间的目的是，方便区分判断队列为空、队列已满的条件。否则，需新增一个变量来辅助判断队列为空还是满。(因为此时rear == front，你不能判断队列是空还是满。)</p></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>CircleArrayQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.CircleArrayQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> MAXSIZE;<span class="comment">//本代码实现时，空余的一个空间，所以实际有效数据个数为MAXSIZE-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//指向队首</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//指向队尾的后一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.MAXSIZE = size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXSIZE];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % MAXSIZE == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = data;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        System.out.printf(<span class="string">&quot;元素%d已入队\n&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但其实这个方法不应该有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + <span class="built_in">this</span>.size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[i % MAXSIZE]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + MAXSIZE - front) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>CircleArrayQueueDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.CircleArrayQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircleArrayQueue</span> <span class="variable">circleArrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(enQueue)入队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d(deQueue)出队：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s(showQueue)展示队列：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(headQueue)展示队列头部：&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;输入你要入队的元素：&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    circleArrayQueue.enQueue(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;元素%d已出队\n&quot;</span>, circleArrayQueue.deQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列中已有元素为:&quot;</span>);</span><br><span class="line">                    circleArrayQueue.showQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队首元素为%d\n&quot;</span>, circleArrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStructure基础——数组与链表</title>
      <link href="/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>线性表</h1><p>无论是一维数组也好，二维、三维数组也好，本质都是一张表：都是一堆数据元素的排列，只不过二维的每一个元素都是一个一维数组（三维以此类推），那么如何运用好数组呢？也是一门学问——见稀疏数组，就是<strong>数组压缩</strong>的例子之一。</p><p><strong>链表</strong>也是线性表，只不过存储方式是链式的，即在计算机中不是连续存储的。</p><p><strong>队列</strong>和<strong>栈</strong>，都是操作受限的线性表，可以有顺序存储结构和链式存储结构。队列强调<strong>先进先出</strong>，只允许队首元素deQueue、队尾元素enQueue（双向除外）；栈强调<strong>后进先出</strong>，只允许在栈顶push和pop，不允许操作、访问栈底元素（双向除外）。</p><p><strong>哈希表</strong>融<strong>数组+链表</strong> 或 未来的 <strong>数组+二叉树</strong> 于一体，严格意义上应该不能在这个概论里说吧……不过数组+链表的结合还是可以放在这里说，它通过<strong>键值对</strong>的形式存放和<strong>快速查找</strong>某元素，主要体现了查询的迅速。</p><h1>稀疏数组</h1><h2 id="思路分析">思路分析:</h2><p>当一个数组中大部分元素都为0或者为同一个值时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方式是：</p><p>记录数组的<strong>行数</strong>、<strong>列数</strong>、<strong>有多少个不同的值</strong>(或称:<strong>非零值</strong>(仅大部分元素为0的稀疏数组可称))。</p><p>把这些不同值的元素的<strong>行、列、值</strong>三个为一组记录下来。</p><h2 id="代码实现">代码实现</h2><p><code>SparseArray</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.sparseArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个原始的二维数组   11*11</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] chessArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                System.out.print(chessArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j] != <span class="number">0</span>) sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] spareArray = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        spareArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArray[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    spareArray[k][<span class="number">0</span>] = i;</span><br><span class="line">                    spareArray[k][<span class="number">1</span>] = j;</span><br><span class="line">                    spareArray[k][<span class="number">2</span>] = chessArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; spareArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; spareArray[i].length; j++) &#123;</span><br><span class="line">                System.out.print(spareArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;还原为二维数组：&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[spareArray[<span class="number">0</span>][<span class="number">0</span>]][spareArray[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= spareArray[<span class="number">0</span>][<span class="number">2</span>]; i++) &#123;</span><br><span class="line">            array[spareArray[i][<span class="number">0</span>]][spareArray[i][<span class="number">1</span>]] = spareArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                System.out.print(array[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>链表</h1><h2 id="单向链表">单向链表</h2><h3 id="思路分析-2">思路分析</h3><ol><li>链表是以<strong>节点</strong>的形式<strong>链式存储</strong></li><li>每个节点包含<strong>data域</strong>、<strong>next域</strong></li><li>链表分<strong>带头节点的链表</strong>和<strong>不带头节点的链表</strong></li><li><code>initList</code>初始化一个空的单链表</li><li><code>insertList</code>插入操作有<strong>头插法</strong>和<strong>尾插法</strong>，还可以根据需求在插入时<strong>是否按照顺序</strong>进行插入<ul><li>先给新节点连接好他的尾部<code>newNode.setNext(head.getNext())</code></li><li>再把新节点插入<code>head.setNext(newNode)</code></li></ul></li><li><code>deleteList</code>删除操作，要注意判断能否删，可选择传入参数，来对删除元素作限制（例如根据index删、根据data域来删）</li><li><code>traveseList</code>遍历操作，<code>while(p!=null)</code>作为条件，<code>p=p-&gt;next;</code>作为迭代条件实现遍历操作。</li><li><code>reverseList</code><a href="####%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC">单链表的反转-面试题</a>，使用<code>p,next,prev</code>三个指针可实现反转操作。关键步骤为：<ul><li>初始化<code>p=head</code>或者<code>p=head-&gt;next(带头节点写法)</code>，总之p为第一个有值的节点；<code>prev=NULL</code>；</li><li>循环条件<code>while(p!=NULL)</code><ul><li>保存下一个节点位置信息<code>next=p-&gt;next</code></li><li>反转当前节点指向<code>p-&gt;next=prev</code></li><li>将前一节点更新，为下次反转做准备<code>prev=p</code>。并且更新<code>p=next</code>否则死循环。</li></ul></li><li>退出循环时，将头节点位置更新<code>head=prev</code>或者<code>head-&gt;next=prev(带头节点的写法)</code></li></ul></li></ol><h3 id="代码实现-2">代码实现</h3><p><code>SingleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.linkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//带头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，在使用SingleLinkedList类前，必须执行init操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示头插法</span></span><br><span class="line"><span class="comment">     * 注意头插法和尾插法的唯一区别是，执行遍历打印操作时，元素顺序会不同</span></span><br><span class="line"><span class="comment">     * 实际开发中，传入参数为Node类型更加合理(因为以后这个Node中的data域可能会存放很多数据！)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode 要往链表中新增的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(Node newNode)</span> &#123;</span><br><span class="line">        newNode.setNext(head.getNext());</span><br><span class="line">        head.setNext(newNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, p.getData());</span><br><span class="line">            p = p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认删除最后插入的那个元素（作为演示）</span></span><br><span class="line">        <span class="keyword">if</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> p.getNext();</span><br><span class="line">            p.setNext(prev);</span><br><span class="line">            prev = p;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.setNext(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.getNext() == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示：以后可以考虑重写toString()方法，以便了解节点内数据。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 虽然本次演示不涉及到toString方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data=&quot;</span> + data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleLinkedListDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.linkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">operate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    0：退出程序</span></span><br><span class="line"><span class="string">                    1：initList初始化链表操作</span></span><br><span class="line"><span class="string">                    2：traverseList遍历并打印链表操作</span></span><br><span class="line"><span class="string">                    3：insertList插入链表新节点</span></span><br><span class="line"><span class="string">                    4：deleteList删除节点</span></span><br><span class="line"><span class="string">                    5：reverseList反转链表</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter your choice: &quot;</span>);</span><br><span class="line">            operate = scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;链表初始化&quot;</span>);</span><br><span class="line">                    list.initList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;链表元素为:&quot;</span>);</span><br><span class="line">                        list.traverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;建立节点(先输入data):&quot;</span>);</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(scanner.nextInt());</span><br><span class="line">                        list.insertList(newNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除节点:&quot;</span>);</span><br><span class="line">                        list.deleteList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;反转链表:&quot;</span>);</span><br><span class="line">                        list.reverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双向链表">双向链表</h2><h3 id="思路分析-3">思路分析</h3><p>对比单向链表：</p><ol><li>查找更自由，可以从头或尾找起</li><li>删除更自由，可以实现<strong>自我删除</strong>，而单链表必须是找到待删除节点的前一个节点。</li><li>双向链表的节点中除了data域、next域，还有prev域</li><li><code>traverseList</code>遍历操作与单向链表一致，只是更加自由（可以额外接受参数，实现从前OR后查找）</li><li><code>insertList</code>无非是新增了prev域，但是具体实现还是要仔细！</li><li><code>deleteList</code>无非是新涉及了prev域的操作，并且删除时可以自我删除。</li></ol><blockquote><p>总体来说双向链表的实现很简单，在单向的基础上多考虑一个prev域就行。</p></blockquote><h3 id="代码实现-3">代码实现</h3><p><code>DoubleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.doubleLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义为首个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到最后面（可以进一步修改为添加到第k个位置）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newNode 新节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(Node newNode)</span> &#123;</span><br><span class="line">        newNode.setNext(tail.getNext());</span><br><span class="line">        newNode.setPrev(tail);</span><br><span class="line">        tail.setNext(newNode);</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, p.getData());</span><br><span class="line">            p = p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头开始删除元素（此处可以进一步改为删除第k个元素）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">            head.getNext().setPrev(<span class="literal">null</span>);</span><br><span class="line">            head = head.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;<span class="comment">//因为此时规定head是首个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">    <span class="keyword">private</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getPrev</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrev</span><span class="params">(Node prev)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoubleLinkedListDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.doubleLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">operate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    0：退出程序</span></span><br><span class="line"><span class="string">                    1：initList初始化链表操作</span></span><br><span class="line"><span class="string">                    2：traverseList遍历并打印链表操作</span></span><br><span class="line"><span class="string">                    3：insertList插入链表新节点</span></span><br><span class="line"><span class="string">                    4：deleteList删除节点</span></span><br><span class="line"><span class="string">                    -------------------------------------</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter your choice: &quot;</span>);</span><br><span class="line">            operate = scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;链表初始化&quot;</span>);</span><br><span class="line">                    list.initList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;链表元素为:&quot;</span>);</span><br><span class="line">                        list.traverseList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;建立节点(先输入data):&quot;</span>);</span><br><span class="line">                        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(scanner.nextInt());</span><br><span class="line">                        list.insertList(newNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前链表为空，请先初始化&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;删除节点:&quot;</span>);</span><br><span class="line">                        list.deleteList();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单向环形-循环链表">单向环形/循环链表</h2><h3 id="思路分析-4">思路分析</h3><blockquote><p>有助于解决<strong>约瑟夫问题</strong></p></blockquote><p>构建一个单向环形链表的思路：</p><ol><li>先创建第一个节点，让first指向该节点，并形成环形。</li><li>后面每创建一个新的节点，就加入到已有的环形链表（画图理解）</li><li><code>traverseList</code>当<code>p.getNext() == first</code>说明已完成遍历</li></ol><h3 id="代码实现-4">代码实现</h3><blockquote><p>这里的单向环形链表的部分方法(<code>deleteList</code>操作)是针对于<strong>约瑟夫问题</strong>特化的</p></blockquote><p><code>JosephuSolved</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.singleCircleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JosephuSolved</span> &#123;</span><br><span class="line">    <span class="comment">//Josephu:有5个人，编号从1-5，从第一个人开始报数，每次报到3的人出圈，直到所有人出圈</span></span><br><span class="line">    <span class="comment">//按照出圈顺序打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleCircleLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleCircleLinkedList</span>();</span><br><span class="line">        list.initList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            list.insertList(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.traverseList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在约瑟夫问题中，出去一个后，从下一个接着开始报数</span></span><br><span class="line">        <span class="comment">//也就意味着要修改数据结构中的first、last以适应该问题</span></span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>,list.deleteList(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SingleCircleLinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.singleCircleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleCircleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initList</span><span class="params">()</span>&#123;</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertList</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            first = <span class="keyword">new</span> <span class="title class_">Node</span>(data,first);<span class="comment">//自己与自己构成环形</span></span><br><span class="line">            last = first;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data,first);</span><br><span class="line">        last.setNext(newNode);</span><br><span class="line">        last = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从p节点开始，删除第index个节点，但是针对JosePose问题做了特化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引(大于等于1！)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回被删除节点的编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteList</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> last;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">if</span>(first.getNext() == first)&#123;</span><br><span class="line">            first = <span class="literal">null</span>;</span><br><span class="line">            last = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> p.getNum();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p=p.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行删除</span></span><br><span class="line">        prev.setNext(p.getNext());</span><br><span class="line">        last = prev;</span><br><span class="line">        first = p.getNext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.getNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverseList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>,p.getNum());</span><br><span class="line">            p=p.getNext();</span><br><span class="line">        &#125;<span class="keyword">while</span>(p!=first);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> num,Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表题目">链表题目</h2><h3 id="查找单链表的倒数第k个节点">查找单链表的倒数第k个节点</h3><ol><li>编写一个方法，接收head节点，同时接收一个index</li><li>index表示倒数第index个节点</li><li>若<code>index&lt;0</code>或者<code>index&gt;length</code>，则查找不到。</li><li>如果在设计单链表时，携带length属性（insert时++、delete时–、有get方法），直接获取总长度，遍历后即可到达第<code>length-index+1</code>个节点，即到时第k个节点。若没有length，则需要先遍历一遍获得<strong>单链表</strong>总长度。(毕竟是单链表，只能从前往后遍历，所以需要预先知道总长才能查询到倒数第k个)</li></ol><h3 id="单链表的反转">单链表的反转</h3><p>见单向链表的<a href="###%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">思路分析</a>部分<code>reverseList</code>。</p><h3 id="从尾到头打印单链表">从尾到头打印单链表</h3><ol><li>方式一：先reverse，再打印，但是破坏了原来的结构（不推荐）</li><li>方式二：把节点压入栈中，利用栈后进先出的的特点，实现逆序打印</li></ol><h3 id="合并两个有序的单链表，合并后仍保持有序">合并两个有序的单链表，合并后仍保持有序</h3><ol><li>两个单链表都还没遍历完，就比大小后再插入</li><li>有一个为空了，剩下的那个直接接入到最后即可</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2025/03/22/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/03/22/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2025/03/22/Java/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/03/22/Java/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2025/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>数据结构</h1><blockquote><p>前言：数据结构，好比是一类基本工具，每一类数据结构被抽象出来，必定有其广泛的用途。用好数据结构，就相当于用好了这类基本工具。——工欲善其事必先利其器。</p></blockquote><ul><li>TODO:数学渲染有问题……后续改一下</li></ul><h1>算法</h1><blockquote><p>前言：算法是属于编程功底性的东西，要求有，多不多无所谓。</p></blockquote><h2 id="排序算法-概论">排序算法-概论</h2><h3 id="分类">分类</h3><p>分为<strong>内部排序</strong>和<strong>外部排序</strong>，</p><ol><li>内部排序，是指将要处理的数据都加载到内部存储器（内存）完成排序</li><li>外部排序，当数据量过大，无法全部加载到内存中时，需要借助外部存储进行排序</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/数据结构与算法/blog-20250501180644727.png" alt="image-20241030211412362" style="zoom:67%;" /><h3 id="算法对比">算法对比</h3><table><thead><tr><th><strong>排序算法</strong></th><th><strong>平均时间复杂度</strong></th><th><strong>最好情况</strong></th><th><strong>最坏情况</strong></th><th><strong>空间复杂度</strong></th><th><strong>排序方式</strong></th><th><strong>稳定性</strong></th></tr></thead><tbody><tr><td><strong>冒泡排序</strong></td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td><strong>选择排序</strong></td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>插入排序</strong></td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>In-place</td><td>稳定</td></tr><tr><td><strong>希尔排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log^2 n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>归并排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>快速排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>堆排序</strong></td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td>In-place</td><td>不稳定</td></tr><tr><td><strong>计数排序</strong></td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>桶排序</strong></td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr><tr><td><strong>基数排序</strong></td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>Out-place</td><td>稳定</td></tr></tbody></table><p><strong>术语解释</strong>：</p><ol><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序后a仍在b前面</li><li><strong>不稳定</strong>：如果a原本在b前面，而a=b，排序后a有可能在b后面</li><li><strong>内排序</strong>：所有排序操作都在内存中完成</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li><li><strong>时间复杂度</strong>： 一个算法执行所耗费的时间</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小</li><li><strong>n</strong>：数据规模</li><li><strong>k</strong>：计数排序、桶排序等中桶的数量；基数排序中，数字的位数</li><li><strong>In-place</strong>：不占用额外内存</li><li><strong>Out-place</strong>：占用额外内存</li></ol><h3 id="实际测试的性能">实际测试的性能</h3><blockquote><p>不同算法对于不同测试数据大小的排序所用时间</p></blockquote><table><thead><tr><th>数据量</th><th><a href="##1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">冒泡排序</a></th><th><a href="##2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">选择排序</a></th><th><a href="##3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">插入排序</a></th><th><a href="##4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">希尔排序</a></th><th><a href="##5%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">快速排序</a></th><th><a href="##6%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">归并排序</a></th><th><a href="##7%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">基数排序</a></th><th><a href="##8%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F(%E7%BB%8F%E5%85%B8)">堆排序</a></th></tr></thead><tbody><tr><td>10000</td><td>43</td><td>26</td><td>22</td><td>3</td><td>1</td><td>2</td><td>2</td><td>1</td></tr><tr><td>50000</td><td>1845</td><td>592</td><td>431</td><td>6</td><td>6</td><td>7</td><td>3</td><td>5</td></tr><tr><td>80000</td><td>5250</td><td>1470</td><td>1074</td><td>12</td><td>9</td><td>18</td><td>10</td><td>8</td></tr><tr><td>140000</td><td>18690</td><td>4337</td><td>3214</td><td>17</td><td>12</td><td>22</td><td>14</td><td>13</td></tr><tr><td>500000</td><td></td><td></td><td></td><td>52</td><td>37</td><td>57</td><td>35</td><td>46</td></tr><tr><td>900000</td><td></td><td></td><td></td><td>104</td><td>64</td><td>93</td><td>35</td><td>83</td></tr></tbody></table><h2 id="查找算法-概论">查找算法-概论</h2><h3 id="分类-2">分类</h3><ol><li>顺序(线性)查找</li><li>二分查找/折半查找</li><li>插值查找</li><li>斐波那契查找</li></ol><h3 id="简单介绍">简单介绍</h3><ol><li>顺序查找操作的数据可以是无序的（就是遍历……）</li><li>二分查找、插值查找、斐波那契查找要求在一个<strong>有序数组</strong>中</li></ol><h1>附录：其他补充</h1><table><thead><tr><th>脚注</th><th>对应解释</th><th>脚注</th><th>对应解释</th></tr></thead><tbody><tr><td><a href="%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">^1</a></td><td><a href="##%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">中缀表达式</a></td><td><a href="%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">^2</a></td><td><a href="##%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">前缀表达式</a></td></tr><tr><td><a href="%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">^3</a></td><td><a href="##%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">后缀表达式</a></td><td><a href="%E9%80%92%E5%BD%92">^4</a></td><td><a href="##%E9%80%92%E5%BD%92">递归</a></td></tr><tr><td><a href="%E5%88%86%E6%B2%BB">^5</a></td><td><a href="##%E5%88%86%E6%B2%BB">分治</a></td><td><a href="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%A4%84%E7%90%86%E8%B4%9F%E6%95%B0">^6</a></td><td><a href="##%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%A4%84%E7%90%86%E8%B4%9F%E6%95%B0">基数排序处理负数</a></td></tr><tr><td><a href="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8?">^7</a></td><td><a href="##%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8?">斐波那契查找的意义何在?</a></td><td><a href="%E8%87%AA%E7%94%A8%E3%81%AE%E7%95%8C%E9%9D%A2%E8%8F%9C%E5%8D%95">^8</a></td><td><a href="##%E8%87%AA%E7%94%A8%E3%81%AE%E7%95%8C%E9%9D%A2%E8%8F%9C%E5%8D%95">自用の界面菜单</a></td></tr><tr><td><a href="%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81">^9</a></td><td><a href="##%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81">前缀编码</a></td><td><a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">^10</a></td><td><a href="##%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></td></tr><tr><td><a href="%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">^11</a></td><td><a href="##%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></td><td></td><td></td></tr></tbody></table><h2 id="中缀表达式">中缀表达式</h2><p>中缀表达式，就是我们常见的表达式，如$(3+4) \times 5-6$，但是对于计算机来说操作较为复杂。</p><p>因此，在计算结果时，一般需要转换为其他表达式来计算（一般是后缀表达式）</p><h2 id="前缀表达式">前缀表达式</h2><p>前缀表达式，又称<strong>波兰式</strong>。前缀表达式的运算符位于操作数之前</p><p>e.g.$(3+4)\times5-6$对应的前缀表达式为$-*+3456$ （关键在于将原先表达式转换为前缀表达式）</p><ul><li>前缀表达式的求值：<ul><li><strong>从右至左</strong>扫描前缀表达式，遇到数字时，压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们进行运算，并将结果入栈。重复该过程直至表达式最左端。</li><li>e.g.$-*+3456$</li><li>将6、5、4、3压入堆栈（<code>numStack=[6,5,4,3]</code>）</li><li>遇到+，弹出3、4，运算$3+4=7$，将7入栈。（<code>numStack=[6,5,7]</code>）</li><li>遇到*，弹出7、5，运算$7 \times 5=35$，将35入栈（<code>numStack=[6,35]</code>）</li><li>遇到-，弹出35、6，运算$35-6=29$，将29入栈（<code>numStack=[29]</code>）</li></ul></li></ul><h2 id="后缀表达式">后缀表达式</h2><p>后缀表达式，又称<strong>逆波兰表达式</strong>，与前缀表达式类似，只是运算符放在操作数之后。</p><ul><li><p>例如$(3+4)\times 5 -6$的后缀式为：$3 \quad 4 + 5 \times 6 - $</p></li><li><p>$a+b$为$a \quad b +$</p></li><li><p>$a+(b-c)$为$a \quad b \quad c - +$</p></li><li><p>$a+(b-c)\times d$为$a \quad b \quad c - d \times +$</p></li><li><p>$a+d \times (b-c)$为$a \quad d \quad b \quad c - \times +$</p></li><li><p>$a=1+3$为$a \quad 1 \quad 3 +=$</p></li></ul><p>后缀表达式的求值：</p><p><strong>从左至右</strong>表达式，遇到数字时，压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们进行运算，并将结果入栈。重复该过程直至表达式最右端。(演示过程和前缀表达式一致)</p><blockquote><p>关键在于如何将中缀表达式转换为后缀表达式</p></blockquote><h2 id="递归">递归</h2><h3 id="递归介绍">递归介绍</h3><p>简单来说，递归就是<strong>自己调用自己</strong>，每次调用时<strong>传入不同的变量</strong>。</p><p>递归调用机制：</p><ol><li>当程序每次调用一个方法时，就会开辟一个独立的空间（栈）</li><li>每个空间的数据（局部变量），都是独立的</li></ol><p>递归能解决的问题：</p><ol><li>数学类：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子问题</li><li>算法中：快排、归并排序、二分查找、分治算法</li><li>将用栈解决的问题-&gt;使用递归，代码简洁</li></ol><h3 id="递归需遵守的规则">递归需遵守的规则</h3><ol><li>执行一个方法，就创建一个独立空间</li><li>局部变量独立</li><li>引用类型变量是共享的（例如数组）</li><li>递归必须设计<strong>递归出口</strong>，<strong>必须向退出递归的条件逼近</strong></li><li>当一个方法执行完毕，谁调用，谁接收返回结果，并且继续执行调用者后面的代码</li></ol><h2 id="分治">分治</h2><blockquote><p>先见<a href="https://blog.csdn.net/daaikuaichuan/article/details/80765604?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%88%86%E6%B2%BB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-80765604.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">博客1</a>与<a href="https://www.cnblogs.com/leishitou/p/5436201.html">博客2</a>的解释</p></blockquote><ol><li>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</li><li>分治算法可以求解的一些经典问题<ol><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li><a href="##%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔</a></li></ol></li></ol><p><strong>分治算法的基本步骤</strong></p><p>分治法在每一层递归上都有三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解。</li></ol><p><strong>分治(Divide-and-Conquer(P))算法设计模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> |P|≤n0</span><br><span class="line">   then <span class="title function_">return</span><span class="params">(ADHOC(P)</span>)</span><br><span class="line"><span class="comment">//将P分解为较小的子问题 P1 ,P2 ,…,Pk</span></span><br><span class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</span><br><span class="line"><span class="keyword">do</span> yi ← Divide-and-Conquer(Pi)   递归解决Pi</span><br><span class="line">T ← MERGE(y1,y2,…,yk)   合并子问题</span><br><span class="line"><span class="keyword">return</span>(T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中$|P|$表示问题P的规模；$n_0$为一阈值，表示当问题P的规模不超过$n_0$时，问题已容易直接解出，不必再继续分解。<code>ADHOC(P)</code>是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过$n_0$时直接用算法<code>ADHOC(P)</code>求解。算法<code>MERGE(y1,y2,…,yk)</code>是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h2 id="基数排序处理负数">基数排序处理负数</h2><h3 id="偏移法">偏移法</h3><h4 id="介绍">介绍</h4><ol><li><strong>找出最小值</strong>：首先遍历数组，找出最小值。</li><li><strong>偏移所有数</strong>：将数组中的所有元素都加上一个正数，使得数组中的所有元素都变为非负数。这个正数可以是绝对值最小值加一。例如，如果最小值是 -10，可以将所有元素加 11，使得最小值变为 1。</li><li><strong>进行基数排序</strong>：对偏移后的数组进行基数排序。</li><li><strong>恢复原值</strong>：排序完成后，再将每个元素减去之前加的正数，恢复到原始值。</li></ol><h4 id="代码实现">代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; min) &#123;</span><br><span class="line">            min = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> Math.abs(min);</span><br><span class="line">    <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>] + offset; <span class="comment">// 加上偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] += offset; <span class="comment">// 偏移</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 放入桶中的过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">            bucketCounts[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从桶中取出的过程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] -= offset; <span class="comment">// 恢复</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释">解释</h4><ol><li><strong>偏移处理</strong>：在进行排序前，将所有数加上偏移量（绝对值最小值），确保数组中所有元素为非负数。</li><li><strong>基数排序</strong>：对偏移后的数组进行基数排序。</li><li><strong>恢复值</strong>：排序完成后，减去偏移量以恢复到原始值。</li></ol><p>这种方法较为简单，且在排序完成后，时间复杂度仍然保持在 $(O(d \cdot (n + k)))$，其中 d 是数字的位数，n 是元素个数，k 是基数的大小。</p><h3 id="分开处理">分开处理</h3><h4 id="介绍-2">介绍</h4><ol><li><strong>分为正负数组</strong>：创建两个数组，分别存放正数和负数。</li><li><strong>对正数进行基数排序</strong>：对正数数组进行基数排序。</li><li><strong>对负数进行基数排序</strong>：对负数数组的绝对值进行基数排序，然后将结果反转。</li><li><strong>合并结果</strong>：将负数数组（排序后）和正数数组（排序后）合并。</li></ol><h4 id="代码实现-2">代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">53</span>, -<span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, -<span class="number">214</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试算法性能</span></span><br><span class="line">        testPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 分为正负数组</span></span><br><span class="line">        <span class="type">int</span>[] positive = Arrays.stream(arr).filter(x -&gt; x &gt;= <span class="number">0</span>).toArray();</span><br><span class="line">        <span class="type">int</span>[] negative = Arrays.stream(arr).filter(x -&gt; x &lt; <span class="number">0</span>).map(Math::abs).toArray(); <span class="comment">// 取绝对值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对正数进行基数排序</span></span><br><span class="line">        <span class="keyword">if</span> (positive.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            radixSortPositive(positive);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对负数进行基数排序</span></span><br><span class="line">        <span class="keyword">if</span> (negative.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            radixSortPositive(negative);</span><br><span class="line">            <span class="comment">// 反转负数排序后的结果</span></span><br><span class="line">            reverseArray(negative);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先填充负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : negative) &#123;</span><br><span class="line">            arr[index++] = -num; <span class="comment">// 恢复负号</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后填充正数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : positive) &#123;</span><br><span class="line">            arr[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSortPositive</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="type">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(arr).max().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 放入桶中的过程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                buckets[digit][bucketCounts[digit]] = arr[j];</span><br><span class="line">                bucketCounts[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从桶中取出的过程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketCounts[j]; k++) &#123;</span><br><span class="line">                        arr[index++] = buckets[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    bucketCounts[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试算法性能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPerformance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">140000</span>; <span class="comment">// 数组大小</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成无序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">200000</span>) - <span class="number">100000</span>; <span class="comment">// 生成范围为 -100000 到 100000 的随机数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录开始时间</span></span><br><span class="line">        radixSort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序大小: &quot;</span> + size);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释-2">解释</h4><ol><li><p><strong>分开处理</strong>：</p><ul><li>使用 <code>Arrays.stream</code> 分别创建正数数组 <code>positive</code> 和负数数组 <code>negative</code>（取绝对值）。</li></ul></li><li><p><strong>基数排序</strong>：</p><ul><li>对正数数组调用 <code>radixSortPositive</code> 方法进行排序。</li><li>对负数数组同样调用 <code>radixSortPositive</code>，但处理时将元素取绝对值。</li></ul></li><li><p><strong>反转负数数组</strong>：</p><ul><li>对负数排序后的结果进行反转，以确保负数按正确顺序排列。</li></ul></li><li><p><strong>合并结果</strong>：</p><ul><li>先将负数（带负号）放入最终数组，再将正数放入，得到完整的排序结果。</li></ul></li></ol><h3 id="两者比较、总结">两者比较、总结</h3><h4 id="偏移法-2">偏移法</h4><ul><li><p><strong>优点</strong>：</p><ul><li>实现相对简单，不需要额外的空间来存储正数和负数数组。</li><li>对于负数和正数的排序都是在同一个数组中进行的，合并结果的步骤被省略。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>需要对整个数组进行遍历以找出最小值并计算偏移量，这在数据量很大时会增加时间开销。</li><li>需要额外的空间用于桶（假设桶大小为常数，空间复杂度为 $O(n)$），但实际上，空间利用率可能受到偏移量影响。</li></ul></li></ul><h4 id="分开处理法">分开处理法</h4><ul><li><p><strong>优点</strong>：</p><ul><li>明确分开了负数和正数的排序，逻辑更清晰。</li><li>在处理负数时，直接对绝对值排序，可以有效避免负数带来的问题。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>需要额外的数组来存储正数和负数，空间复杂度更高（需要 $O(n)$ 的额外空间）。</li><li>合并结果时需要再次遍历数组，增加了额外的时间开销。</li></ul></li></ul><h4 id="性能比较">性能比较</h4><ul><li><strong>时间复杂度</strong>：两种方法的时间复杂度均为 $O(d \cdot (n + k))$，其中 $d$ 是数字的位数，$n$ 是元素个数，$k$ 是基数的大小。因此，从理论上讲，时间复杂度相同。</li><li><strong>实际性能</strong>：<ul><li>对于大多数情况，偏移法在空间上更高效，适合数据范围较小的情况。</li><li>分开处理法在逻辑上更易于理解，且能更好地处理极端情况（例如全是负数或全是正数）。</li></ul></li></ul><h4 id="结论">结论</h4><p>在性能上，两种方法在大多数情况下相似，但具体的选择可以根据实际需求和数据特性来决定。</p><p>如果需要处理的数组范围较大且包含负数，分开处理法可能会更加灵活；如果希望简化实现，偏移法是一个不错的选择。</p><h2 id="斐波那契查找的意义何在">斐波那契查找的意义何在?</h2><p>这个问题，我浅浅看了几篇文章，但都没有满意的答案。</p><p>可能的原因千奇百怪：</p><ol><li>斐波那契查找在计算<code>mid</code>值时，只使用了加减法——<code>mid = low + f[k-1] - 1</code>，而二分查找使用了除法，除法是极耗费时间的。但是吧，也没那么耗时间，很多编辑器都优化成&gt;&gt;1了，也没比加减法慢。</li><li>斐波那契查找将mid点设置在0.618处，如果所以元素落在$[low,mid-1]$区间的概率较大，判断一次的可能更高；而二分查找两个区间长度都为一半，所以仅需判断一次的概率相比更小。貌似很有道理，但是为什么是0.618？我没看到一篇文章有过详细的数学证明……所以还是觉得这两者查找效率半斤八两。</li></ol><h2 id="自用の界面菜单">自用の界面菜单</h2><blockquote><p>测试用咯~</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">operate</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;q：退出程序&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;Enter operation: &quot;</span>);</span><br><span class="line">            operate = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Character.toLowerCase(operate)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span> -&gt; &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Invalid operation&quot;</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="前缀编码">前缀编码</h2><p>简单理解：10010110100是编码结果，但是在解读时，a编码为1，b编码为10，那么在解读这个编码时，开头的1究竟是1？还是说10是b？</p><p>如果在一个编码方案中，任何一个编码都不是其他任何编码的前缀（最左子串），则称该编码是前缀编码。</p><p>补充资料：<a href="https://blog.csdn.net/qq_30787727/article/details/112210023">blog1</a>、<a href="https://blog.csdn.net/ak201605050122/article/details/100169591">blog2</a>。</p><h2 id="动态规划">动态规划</h2><p><strong>动态规划介绍</strong>：</p><ol><li><strong>动态规划(Dynamic Programming)<strong>算法的核心思想是：将</strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong>。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过<strong>填表</strong>的方式来逐步推进，得到最优解</li></ol><h2 id="贪心算法">贪心算法</h2><p><strong>贪心算法介绍</strong>：</p><ol><li>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</li><li>贪婪算法所得到的结果<strong>不一定是最优的结果(有时候会是最优解)</strong>，但是都是相对近似(接近)最优解的结果</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2025/03/08/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/03/08/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>测试测试测试-3</p><blockquote><p>标题写法：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure><h1>一级标题</h1><h2 id="二级标题">二级标题</h2><blockquote><p>注释内容</p></blockquote><p>注释写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面是注释</span><br><span class="line"><span class="quote">&gt; 注释内容</span></span><br><span class="line">ps：&#x27;&gt;&#x27;+空格</span><br></pre></td></tr></table></figure><h1>代码</h1><blockquote><p>代码块</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="code">```[语言类型]+Enter</span></span><br><span class="line"><span class="code">写代码语言</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>着重号</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="code">`被着重号包围的内容`</span></span><br></pre></td></tr></table></figure><p><code>被着重号包围的内容</code></p><blockquote><p>内联HTML代码:<br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/Markdown%E8%AF%AD%E6%B3%95/blog-20250429230431735.png" alt=""></p></blockquote><div style="text-align:center">    <font style="color:red">目前已能看懂HTML</font></div><center>简单的文字居中</center><h1>列表</h1><blockquote><p>无序列表，使用<code>-</code>或<code>*</code>或<code>+</code>都可以</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 一个雪乃</span><br><span class="line"><span class="bullet">-</span> 两个雪乃</span><br><span class="line"><span class="bullet">  -</span> (再按个Tab)-&gt;变成子集</span><br><span class="line"><span class="bullet">    -</span> 子子集</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 雪乃我爱你</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 我爱你雪乃！</span><br></pre></td></tr></table></figure><ul><li>一个雪乃</li><li>两个雪乃<ul><li>(再按个Tab)-&gt;变成子集<ul><li>子子集</li></ul></li></ul></li></ul><ul><li>雪乃我爱你</li></ul><ul><li>我爱你雪乃！</li></ul><blockquote><p>有序列表，<code>数字.空格 内容</code></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 打开冰箱</span><br><span class="line"><span class="bullet">2.</span> 把大象塞进去</span><br><span class="line"><span class="bullet">3.</span> 关上冰箱</span><br></pre></td></tr></table></figure><p>如何把大象放进冰箱？(数字.空格)</p><ol><li>打开冰箱</li><li>把大象塞进去</li><li>关上冰箱</li></ol><blockquote><p>任务列表，<code>- [ ] 内容</code></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 敲代码</span><br><span class="line"><span class="bullet">-</span> [x] 雪乃爱我</span><br><span class="line"><span class="bullet">-</span> [x] 我爱雪乃</span><br></pre></td></tr></table></figure><ul><li>[ ] 敲代码</li><li>[x] 雪乃爱我</li><li>[x] 我爱雪乃</li></ul><h1>文字</h1><blockquote><p>一般文字样式</p></blockquote><p><code>*斜体*</code>，<em>斜体</em>（Ctrl+I）</p><p><code>**加粗**</code>，<strong>加粗</strong>（Ctrl+B）</p><p><code>***斜体加加粗***</code>，<em><strong>斜体加加粗</strong></em>（先Ctrl+I再Ctrl+B）</p><p><code>~~删除线~~</code>，<s>删除线</s></p><p><code>&lt;u&gt;下划线&lt;/u&gt;</code>，<u>下划线</u>（Ctrl+U）</p><blockquote><p>特殊化文字(Emoji可能不支持)</p></blockquote><p>Emoji表情 :smile: :sweat_smile: :drooling_face:<br>:clown_face:<br><a href="https://emojipedia.org/apple/">Emoji表情大全</a></p><blockquote><p>表格</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|姓名|年龄|国文成绩|数学成绩|</span><br><span class="line">|:---|---:|:---:|:---|</span><br><span class="line">|比企谷八幡|19|98|100|</span><br><span class="line">|雪之下雪乃|19|100|100|</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:right">年龄</th><th style="text-align:center">国文成绩</th><th style="text-align:left">数学成绩</th></tr></thead><tbody><tr><td style="text-align:left">比企谷八幡</td><td style="text-align:right">19</td><td style="text-align:center">98</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">雪之下雪乃</td><td style="text-align:right">19</td><td style="text-align:center">100</td><td style="text-align:left">100</td></tr></tbody></table><blockquote><p>分割线</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">+++</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">ps：并不一定支持所有的分割线语法</span></span><br></pre></td></tr></table></figure><hr><hr><h1>数学公式</h1><ul><li><p>行间数学公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\lambda</span> l&#125;&#123;4 <span class="keyword">\pi</span> <span class="keyword">\varepsilon</span><span class="built_in">_</span>0 d&#125; <span class="keyword">\frac</span>&#123;l&#125;&#123;(d<span class="built_in">^</span>2+<span class="keyword">\frac</span>&#123;l<span class="built_in">^</span>2&#125;&#123;4&#125;)<span class="built_in">^</span><span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125;&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li></ul><p>$$<br>\frac{\lambda l}{4 \pi \varepsilon_0 d} \frac{l}{(d^2+\frac{l^2}{4})^\frac{1}{2}}<br>$$</p><ul><li><p>行内数学公式：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内公式展示——$x \div y$</span><br></pre></td></tr></table></figure></li></ul><p>行内公式展示——$x \div y$</p><h1>HTML</h1><blockquote><p>ps：理论上完全可以，不过不建议用html写Markdown。</p></blockquote><h1>扩展语法</h1><blockquote><p><em>可能不适用其它地方</em></p></blockquote><ol><li><p>下标H~2~O</p></li><li><p>上标x^2^</p></li><li><p>==这是一段高亮文字==</p></li><li><p>注释<a href="%E6%B3%A8%E9%87%8A%E5%93%9F">^1</a> YukinoshitaYukino<a href="%E9%9B%AA%E4%B9%8B%E4%B8%8B%E9%9B%AA%E4%B9%83%E7%9A%84%E7%BD%97%E9%A9%AC%E5%90%8D">^雪之下雪乃</a>Avidity<a href="%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E8%80%81%E5%B8%88%EF%BC%81%E5%A4%A7%E8%80%81%E5%B8%88%E5%B0%B1%E6%98%AF%E6%88%91%EF%BC%81">^比企谷八幡</a></p></li><li><p>数学公式:</p></li></ol><p>$$<br>\frac{partial f}{\partial x}=2\sqrt{a}x<br>$$</p><p>行内数学公式:$2\sqrt{a}x$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
