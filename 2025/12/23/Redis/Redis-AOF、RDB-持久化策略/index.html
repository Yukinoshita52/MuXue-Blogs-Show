<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis AOF、RDB 持久化策略 | 暮雪Avid的博客</title><meta name="author" content="暮雪Avid"><meta name="copyright" content="暮雪Avid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis 持久化策略Redis 为什么需要持久化？Redis 是基于内存的数据库，内存访问速度快，但内存数据在进程退出或机器宕机后必然丢失。因此，Redis 提供持久化机制，将内存中的数据以一定策略写入磁盘，用于服务重启后的数据恢复。 需要明确一个前提结论：  Redis 持久化只能降低数据丢失风险，并不能保证强一致性或绝对不丢数据。实际丢失多少数据，取决于持久化策略、刷盘频率以及宕机发生的时间">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis AOF、RDB 持久化策略">
<meta property="og:url" content="https://blogs.muxueavid.top/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="暮雪Avid的博客">
<meta property="og:description" content="Redis 持久化策略Redis 为什么需要持久化？Redis 是基于内存的数据库，内存访问速度快，但内存数据在进程退出或机器宕机后必然丢失。因此，Redis 提供持久化机制，将内存中的数据以一定策略写入磁盘，用于服务重启后的数据恢复。 需要明确一个前提结论：  Redis 持久化只能降低数据丢失风险，并不能保证强一致性或绝对不丢数据。实际丢失多少数据，取决于持久化策略、刷盘频率以及宕机发生的时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani1.png">
<meta property="article:published_time" content="2025-12-23T06:08:04.000Z">
<meta property="article:modified_time" content="2025-12-23T09:54:33.000Z">
<meta property="article:author" content="暮雪Avid">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis AOF、RDB 持久化策略",
  "url": "https://blogs.muxueavid.top/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/",
  "image": "https://blogs.muxueavid.top/blogs/common/blog-ani1.png",
  "datePublished": "2025-12-23T06:08:04.000Z",
  "dateModified": "2025-12-23T09:54:33.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "暮雪Avid",
      "url": "https://blogs.muxueavid.top/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blogs.muxueavid.top/blogs/common/avator.jpg"><link rel="canonical" href="https://blogs.muxueavid.top/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis AOF、RDB 持久化策略',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/js/cursor-right.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://blogs.muxueavid.top/blogs/common/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://blogs.muxueavid.top/blogs/common/blog-ani1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">暮雪Avid的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis AOF、RDB 持久化策略</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis AOF、RDB 持久化策略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-23T06:08:04.000Z" title="发表于 2025-12-23 14:08:04">2025-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-23T09:54:33.000Z" title="更新于 2025-12-23 17:54:33">2025-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>4分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h1><h2 id="Redis-为什么需要持久化？"><a href="#Redis-为什么需要持久化？" class="headerlink" title="Redis 为什么需要持久化？"></a>Redis 为什么需要持久化？</h2><p>Redis 是基于内存的数据库，内存访问速度快，但<strong>内存数据在进程退出或机器宕机后必然丢失</strong>。因此，Redis 提供持久化机制，将内存中的数据以一定策略写入磁盘，用于服务重启后的数据恢复。</p>
<p>需要明确一个前提结论：</p>
<blockquote>
<p>Redis 持久化只能<strong>降低数据丢失风险</strong>，并不能保证强一致性或绝对不丢数据。<br>实际丢失多少数据，取决于持久化策略、刷盘频率以及宕机发生的时间点。</p>
</blockquote>
<p>Redis 提供两种核心持久化机制：</p>
<ul>
<li><strong>AOF（Append Only File）日志</strong></li>
<li><strong>RDB（Redis DataBase）快照</strong></li>
</ul>
<h2 id="AOF-日志持久化"><a href="#AOF-日志持久化" class="headerlink" title="AOF 日志持久化"></a>AOF 日志持久化</h2><h3 id="AOF-是什么"><a href="#AOF-是什么" class="headerlink" title="AOF 是什么"></a>AOF 是什么</h3><p>AOF（Append Only File）通过<strong>记录写命令</strong>的方式持久化数据。Redis 会将所有会修改数据的命令，按执行顺序追加写入日志文件。</p>
<p>AOF 默认是关闭的，可通过配置开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>
<p>AOF 只记录<strong>写操作命令</strong>，不记录读操作，因为读命令无法用于数据恢复。</p>
<h3 id="AOF-的写入流程"><a href="#AOF-的写入流程" class="headerlink" title="AOF 的写入流程"></a>AOF 的写入流程</h3><p>一次写命令的大致流程如下：</p>
<ol>
<li>Redis 执行写命令，修改内存数据</li>
<li>将写命令追加到 <strong>AOF buffer</strong></li>
<li>根据 <code>appendfsync</code> 策略，决定是否调用 <code>fsync()</code> 将数据刷入磁盘</li>
</ol>
<p>注意：<br>AOF 持久化写入的是<strong>命令本身，而不是数据结果</strong>。</p>
<h3 id="AOF-的刷盘策略"><a href="#AOF-的刷盘策略" class="headerlink" title="AOF 的刷盘策略"></a>AOF 的刷盘策略</h3><p>Redis 提供三种 AOF 刷盘策略：</p>
<ul>
<li><code>appendfsync always</code><ul>
<li>每条写命令都调用 <code>fsync()</code></li>
<li>数据安全性最高</li>
<li>性能最差</li>
</ul>
</li>
<li><code>appendfsync everysec</code>（默认）<ul>
<li>每秒刷盘一次</li>
<li>宕机时最多丢失 1 秒的数据</li>
<li>性能和安全性较为平衡</li>
</ul>
</li>
<li><code>appendfsync no</code><ul>
<li>不主动刷盘，由操作系统决定</li>
<li>宕机时可能丢失操作系统缓冲区中的<strong>全部数据</strong></li>
<li>数据丢失量不可控</li>
</ul>
</li>
</ul>
<h3 id="AOF-文件膨胀与重写机制"><a href="#AOF-文件膨胀与重写机制" class="headerlink" title="AOF 文件膨胀与重写机制"></a>AOF 文件膨胀与重写机制</h3><p>由于 AOF 会持续追加写命令，文件体积会不断增大。为此，Redis 提供 <strong>AOF 重写（rewrite）机制</strong>。</p>
<p>需要强调的是：</p>
<blockquote>
<p>AOF 重写并不是简单地“压缩旧 AOF 文件”，<br>而是<strong>根据当前内存中的数据状态，重新生成一份等价的最小命令集</strong>。</p>
</blockquote>
<h4 id="AOF-重写过程"><a href="#AOF-重写过程" class="headerlink" title="AOF 重写过程"></a>AOF 重写过程</h4><ol>
<li>Redis fork 出一个子进程</li>
<li>子进程根据当前内存数据生成新的 AOF 文件</li>
<li>重写期间，主进程的新写命令写入：<ul>
<li>原 AOF 文件</li>
<li>AOF 重写缓冲区</li>
</ul>
</li>
<li>重写完成后：<ul>
<li>将重写缓冲区中的命令追加到新 AOF 文件</li>
<li>原子性替换旧 AOF 文件</li>
</ul>
</li>
</ol>
<h4 id="fork-与写时复制（Copy-On-Write）"><a href="#fork-与写时复制（Copy-On-Write）" class="headerlink" title="fork 与写时复制（Copy-On-Write）"></a>fork 与写时复制（Copy-On-Write）</h4><ul>
<li>fork 时子进程共享父进程的内存页</li>
<li>主进程发生写操作时，通过写时复制保证子进程的数据一致性</li>
<li>重写过程不会阻塞正常的写请求</li>
</ul>
<h2 id="RDB-快照持久化"><a href="#RDB-快照持久化" class="headerlink" title="RDB 快照持久化"></a>RDB 快照持久化</h2><h3 id="RDB-是什么"><a href="#RDB-是什么" class="headerlink" title="RDB 是什么"></a>RDB 是什么</h3><p>RDB 通过<strong>生成某一时刻内存数据的完整快照</strong>来持久化数据，类似于给 Redis 的数据拍一张“照片”。</p>
<p>RDB 默认开启。</p>
<h3 id="RDB-的生成方式"><a href="#RDB-的生成方式" class="headerlink" title="RDB 的生成方式"></a>RDB 的生成方式</h3><p>Redis 提供两个命令生成 RDB 文件：</p>
<ul>
<li><code>save</code><ul>
<li>在主线程执行</li>
<li><strong>完全阻塞 Redis</strong></li>
</ul>
</li>
<li><code>bgsave</code><ul>
<li>fork 子进程生成快照</li>
<li>fork 时存在短暂阻塞</li>
<li>是生产环境常用方式</li>
</ul>
</li>
</ul>
<p>RDB 通常通过配置自动触发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>含义为：</p>
<ul>
<li>900 秒内至少 1 次修改</li>
<li>300 秒内至少 10 次修改</li>
<li>60 秒内至少 10000 次修改</li>
</ul>
<p>满足任意条件，Redis 就会执行 <code>bgsave</code>。</p>
<h3 id="RDB-的特点与风险"><a href="#RDB-的特点与风险" class="headerlink" title="RDB 的特点与风险"></a>RDB 的特点与风险</h3><ul>
<li>RDB 是<strong>全量快照</strong></li>
<li>每次生成都会遍历并序列化所有数据</li>
<li>快照操作相对较重</li>
</ul>
<p>因此：</p>
<ul>
<li>执行频率高 → 性能开销大</li>
<li>执行间隔长 → 宕机时数据丢失多</li>
</ul>
<p>RDB 本质上是一个：<br><strong>重操作 + 恢复快 + 丢数据多</strong> 的方案。</p>
<h2 id="Redis-启动时的数据恢复流程"><a href="#Redis-启动时的数据恢复流程" class="headerlink" title="Redis 启动时的数据恢复流程"></a>Redis 启动时的数据恢复流程</h2><p>Redis 重启后，持久化文件的加载顺序为：</p>
<ol>
<li>如果开启了 AOF，且 AOF 文件存在<br>→ <strong>优先使用 AOF 文件恢复数据</strong></li>
<li>否则使用 RDB 文件恢复数据</li>
<li>若两者都不存在<br>→ 数据为空</li>
</ol>
<p>注意：<br>“同时开启 AOF 和 RDB”并不意味着“同时恢复”，<br>而是 <strong>AOF 在恢复阶段具有更高优先级</strong>。</p>
<h2 id="AOF-与-RDB-的对比"><a href="#AOF-与-RDB-的对比" class="headerlink" title="AOF 与 RDB 的对比"></a>AOF 与 RDB 的对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th>对比维度</th>
<th>AOF</th>
<th>RDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据安全性</td>
<td>较高（可配置）</td>
<td>较低</td>
</tr>
<tr>
<td>数据丢失量</td>
<td>秒级或可控</td>
<td>取决于快照周期</td>
</tr>
<tr>
<td>持久化开销</td>
<td>较轻</td>
<td>较重</td>
</tr>
<tr>
<td>文件体积</td>
<td>较大</td>
<td>较小</td>
</tr>
<tr>
<td>恢复速度</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>适用场景</td>
<td>对数据可靠性要求较高</td>
<td>缓存、允许丢数据</td>
</tr>
</tbody>
</table>
</div>
<h2 id="混合持久化（Hybrid-Persistence）"><a href="#混合持久化（Hybrid-Persistence）" class="headerlink" title="混合持久化（Hybrid Persistence）"></a>混合持久化（Hybrid Persistence）</h2><p>Redis 4.0 引入混合持久化机制，本质上是 <strong>AOF 重写的优化</strong>：</p>
<ul>
<li>AOF 重写时：<ul>
<li>文件前半部分是 <strong>RDB 格式的全量数据</strong></li>
<li>后半部分是 <strong>AOF 格式的增量命令</strong></li>
</ul>
</li>
<li>兼顾：<ul>
<li>RDB 恢复速度快</li>
<li>AOF 数据丢失少</li>
</ul>
</li>
</ul>
<p>混合持久化在 Redis 4.0+ 且开启 AOF 的情况下默认启用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis 持久化的目标是<strong>降低数据丢失风险，而不是保证零丢失</strong></li>
<li>AOF 更安全，但恢复慢、文件大</li>
<li>RDB 更轻量，恢复快，但可能丢失更多数据</li>
<li>实际生产环境通常：<ul>
<li>同时开启 AOF + RDB</li>
<li>使用 AOF（everysec）+ 混合持久化作为折中方案</li>
</ul>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani5.png" onerror="onerror=null;src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis 过期删除策略+缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">Redis 过期删除策略在介绍 Redis 的过期删除机制之前，需要先说明：定时删除、惰性删除、定期删除是对过期数据清理思路的抽象划分，用于分析不同策略在 CPU 开销与内存占用之间的取舍。实际的高性能缓存系统通常不会采用其中某一种，而是进行组合设计。 常见的过期删除策略1. 定时删除定时删除指的是：当键到达过期时间的瞬间立即删除该键。 其实现通常需要：  为每一个设置了过期时间的 key 维护独立的定时事件（如定时器或最小堆） 到期后触发删除回调  优点：  过期键能够被及时清理 内存利用率高  缺点：  定时事件数量与过期 key 数量近似线性相关 当过期 key 较多时，定时回调会占用大量 CPU 严重影响主线程吞吐量  因此，Redis 并未采用这种高精度但高成本的策略。 2. 惰性删除惰性删除的核心思想是：不主动删除过期 key，仅在访问时检查其是否过期。 执行流程：  客户端访问 key Redis 判断 key 是否已过期 若已过期，立即删除并返回 key 不存在  优点：  对 CPU 非常友好 不做无意义的主动扫描  缺点：  如果某些 key...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 使用实践</div></div><div class="info-2"><div class="info-item-1">这一部分更多偏实践部分，理论部分见其余 Redis 相关博客</div></div></div></a><a class="pagination-related" href="/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis 底层数据结构"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-14</div><div class="info-item-2">Redis 底层数据结构</div></div><div class="info-2"><div class="info-item-1">Redis 底层数据结构Redis 的高性能并非来自单一结构，而是通过多种针对场景高度定制的数据结构实现。上层五种数据类型（String / List / Hash / Set / ZSet）只是抽象接口，真正的性能边界由底层结构决定。 SDS（Simple Dynamic String）基本原理SDS 是 Redis 自定义的字符串实现，替代 C 原生 char*。其核心是显式维护字符串长度与剩余空间。 典型结构： 12345struct sdshdr &#123;    int len;    // 已用长度    int alloc;  // 分配总长度    char buf[];&#125; 核心特点 O(1) 获取长度（避免 strlen） 支持二进制数据（不依赖 \0作为字符串的结尾） 预分配与惰性释放，减少内存重分配 避免缓冲区溢出  使用到的数据类型 String 所有 key Hash / List / Set / ZSet 内部元素  时间复杂度 获取长度：O(1) 追加：均摊 O(1) 修改：O(n)  链表（Linked...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani12.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 线程模型</div></div><div class="info-2"><div class="info-item-1">Redis 线程模型Redis 常被描述为“单线程高性能”的代表，但单线程并不等于简单或低效。准确理解 Redis 的线程模型，需要区分：命令执行、网络 I/O、后台任务这三条路径。 Redis 的单线程指的是什么是指—— Redis 的命令执行路径（command execution）是单线程的。 具体来说：  所有客户端命令，统一在 主线程 中，按顺序完成：读取 → 解析 → 执行 → 返回结果    这意味着：  不需要加锁、命令天然具备原子性、数据结构实现可以极度简化   但是，Redis 并不是整个进程只有一个线程  基于内存的设计Redis 将所有核心数据结构存放在内存中，而不是磁盘。 这带来的不仅是“快”这么简单：  避免磁盘 I/O 阻塞 单次命令执行时间高度可控 延迟分布稳定，适合单线程顺序执行模型  相比之下，频繁访问磁盘的系统（如传统关系型数据库）更容易出现阻塞点，不适合纯单线程执行所有逻辑。 关于数据不丢失的问题Redis...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani5.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 过期删除策略+缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">Redis 过期删除策略在介绍 Redis 的过期删除机制之前，需要先说明：定时删除、惰性删除、定期删除是对过期数据清理思路的抽象划分，用于分析不同策略在 CPU 开销与内存占用之间的取舍。实际的高性能缓存系统通常不会采用其中某一种，而是进行组合设计。 常见的过期删除策略1. 定时删除定时删除指的是：当键到达过期时间的瞬间立即删除该键。 其实现通常需要：  为每一个设置了过期时间的 key 维护独立的定时事件（如定时器或最小堆） 到期后触发删除回调  优点：  过期键能够被及时清理 内存利用率高  缺点：  定时事件数量与过期 key 数量近似线性相关 当过期 key 较多时，定时回调会占用大量 CPU 严重影响主线程吞吐量  因此，Redis 并未采用这种高精度但高成本的策略。 2. 惰性删除惰性删除的核心思想是：不主动删除过期 key，仅在访问时检查其是否过期。 执行流程：  客户端访问 key Redis 判断 key 是否已过期 若已过期，立即删除并返回 key 不存在  优点：  对 CPU 非常友好 不做无意义的主动扫描  缺点：  如果某些 key...</div></div></div></a><a class="pagination-related" href="/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/" title="RedisTemplate &amp; StringRedisTemplate 使用指南"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani10.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">RedisTemplate &amp; StringRedisTemplate 使用指南</div></div><div class="info-2"><div class="info-item-1">RedisTemplate &amp; StringRedisTemplate 使用指南前言由于对于 Redis 始终停留在理论阶段——懂数据结构类型、数据结构底层实现、缓存击穿、缓存穿透、缓存雪崩，还有各种防xxx的方案，但是貌似都停留在学习上、代码阅读上，现在重新补充一下代码实现的细节上。 项目中很多地方使用了 StringRedisTemplate，其实是继承自 RedisTemplate 的。 然后就去搜 RedisTemplate 的 API、搜如何使用，挑选了7-8篇博客结合 ai 整理知识点如下： 从导入依赖开始为什么是从导入依赖开始呢？主要是这个过程引发了我的疑问： 看到有一篇博客使用如下pom依赖： 12345&lt;!--Redis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Redis中Lua脚本的使用"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani9.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">Redis中Lua脚本的使用</div></div><div class="info-2"><div class="info-item-1">Redis中Lua脚本的使用参考资料：cnblogs.com、Redis Lua 脚本介绍Redis 从 2.6 版本开始内置 Lua 脚本执行引擎，用于在服务器端组合多个 Redis 命令为一个原子操作，从而避免客户端多次往返网络、保证复杂逻辑的原子性执行。Lua 是一种轻量级、可嵌入的脚本语言，非常适合嵌入 Redis 这种高性能内存数据库中。 Lua 在 Redis 中执行时无需额外配置，只需通过命令将脚本发送到 Redis。脚本由 Redis Server 内的 Lua 5.1 解释器运行。Redis 脚本将命令组合在一起，避免多次网络往返，并在执行期间阻塞其他客户端命令，确保原子性。脚本执行结果可返回值给客户端。 Lua 脚本基本语法Lua 语法简单，适合嵌入式脚本应用。基本数据类型包括：nil（空）、boolean（布尔值）、number（数字）、string（字符串）和 table（表）。table 是 Lua 的核心数据结构，它既可表现为数组也可表现为字典。 变量声明： 12name = &#x27;example&#x27;       --...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="author-info-name">暮雪Avid</div><div class="author-info-description">热爱+时间=实现</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yukinoshita52"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yukinoshita52" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://https://muxueblogs.netlify.app/about/" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/1808485376?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如出现图片访问失败问题，请科学上网，诶嘿(*^▽^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.</span> <span class="toc-text">Redis 持久化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Redis 为什么需要持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">AOF 日志持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">AOF 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E7%9A%84%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">AOF 的写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">AOF 的刷盘策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E6%96%87%E4%BB%B6%E8%86%A8%E8%83%80%E4%B8%8E%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">AOF 文件膨胀与重写机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">AOF 重写过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-%E4%B8%8E%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88Copy-On-Write%EF%BC%89"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">fork 与写时复制（Copy-On-Write）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-%E5%BF%AB%E7%85%A7%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">RDB 快照持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">RDB 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">RDB 的生成方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E9%A3%8E%E9%99%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">RDB 的特点与风险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%90%AF%E5%8A%A8%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">Redis 启动时的数据恢复流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-%E4%B8%8E-RDB-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.</span> <span class="toc-text">AOF 与 RDB 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88Hybrid-Persistence%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">混合持久化（Hybrid Persistence）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" title="Redis AOF、RDB 持久化策略"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani1.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis AOF、RDB 持久化策略"/></a><div class="content"><a class="title" href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" title="Redis AOF、RDB 持久化策略">Redis AOF、RDB 持久化策略</a><time datetime="2025-12-23T06:08:04.000Z" title="发表于 2025-12-23 14:08:04">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani5.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 过期删除策略+缓存淘汰策略"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略">Redis 过期删除策略+缓存淘汰策略</a><time datetime="2025-12-22T12:08:37.000Z" title="发表于 2025-12-22 20:08:37">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani2.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 使用实践"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践">Redis 使用实践</a><time datetime="2025-12-22T11:25:26.000Z" title="发表于 2025-12-22 19:25:26">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani12.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 线程模型"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型">Redis 线程模型</a><time datetime="2025-12-22T10:01:25.000Z" title="发表于 2025-12-22 18:01:25">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani7.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="docker个人实践记录"/></a><div class="content"><a class="title" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录">docker个人实践记录</a><time datetime="2025-12-16T07:44:45.000Z" title="发表于 2025-12-16 15:44:45">2025-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 - 2026 By 暮雪Avid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://npm.elemecdn.com/nanshen@latest/img/icp.webp"><span>浙ICP备2025158028号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="/js/busuanzi-async.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,Yukinoshita,自由,平等,公正,诶嘿o(*￣︶￣*)o,法治,爱国,Yukino,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>