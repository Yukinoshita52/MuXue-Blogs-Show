<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis中Lua脚本的使用 | 暮雪Avid的博客</title><meta name="author" content="暮雪Avid"><meta name="copyright" content="暮雪Avid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis中Lua脚本的使用 参考资料：cnblogs.com、Redis Lua 脚本介绍 Redis 从 2.6 版本开始内置 Lua 脚本执行引擎，用于在服务器端组合多个 Redis 命令为一个原子操作，从而避免客户端多次往返网络、保证复杂逻辑的原子性执行。Lua 是一种轻量级、可嵌入的脚本语言，非常适合嵌入 Redis 这种高性能内存数据库中。 Lua 在 Redis 中执行时无需额外配置">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis中Lua脚本的使用">
<meta property="og:url" content="https://blogs.muxueavid.top/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="暮雪Avid的博客">
<meta property="og:description" content="Redis中Lua脚本的使用 参考资料：cnblogs.com、Redis Lua 脚本介绍 Redis 从 2.6 版本开始内置 Lua 脚本执行引擎，用于在服务器端组合多个 Redis 命令为一个原子操作，从而避免客户端多次往返网络、保证复杂逻辑的原子性执行。Lua 是一种轻量级、可嵌入的脚本语言，非常适合嵌入 Redis 这种高性能内存数据库中。 Lua 在 Redis 中执行时无需额外配置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani2.png">
<meta property="article:published_time" content="2025-12-13T10:27:02.000Z">
<meta property="article:modified_time" content="2025-12-13T10:27:02.000Z">
<meta property="article:author" content="暮雪Avid">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani2.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis中Lua脚本的使用",
  "url": "https://blogs.muxueavid.top/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/",
  "image": "https://blogs.muxueavid.top/blogs/common/blog-ani2.png",
  "datePublished": "2025-12-13T10:27:02.000Z",
  "dateModified": "2025-12-13T10:27:02.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "暮雪Avid",
      "url": "https://blogs.muxueavid.top/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blogs.muxueavid.top/blogs/common/avator.jpg"><link rel="canonical" href="https://blogs.muxueavid.top/2025/12/13/Redis/Redis%E4%B8%ADLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis中Lua脚本的使用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://blogs.muxueavid.top/blogs/common/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://blogs.muxueavid.top/blogs/common/blog-ani2.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">暮雪Avid的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis中Lua脚本的使用</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis中Lua脚本的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-13T10:27:02.000Z" title="发表于 2025-12-13 18:27:02">2025-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-13T10:27:02.000Z" title="更新于 2025-12-13 18:27:02">2025-12-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>6分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Redis中Lua脚本的使用</h1>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/felordcn/p/13838321.html">cnblogs.com</a>、<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/develop/programmability/eval-intro/?utm_source=chatgpt.com">Redis</a></p>
<h2 id="Lua-脚本介绍">Lua 脚本介绍</h2>
<p>Redis 从 2.6 版本开始内置 Lua 脚本执行引擎，用于在服务器端组合多个 Redis 命令为一个原子操作，从而避免客户端多次往返网络、保证复杂逻辑的原子性执行。Lua 是一种轻量级、可嵌入的脚本语言，非常适合嵌入 Redis 这种高性能内存数据库中。</p>
<p>Lua 在 Redis 中执行时无需额外配置，只需通过命令将脚本发送到 Redis。脚本由 Redis Server 内的 Lua 5.1 解释器运行。Redis 脚本将命令组合在一起，避免多次网络往返，并在执行期间阻塞其他客户端命令，确保原子性。脚本执行结果可返回值给客户端。</p>
<h2 id="Lua-脚本基本语法">Lua 脚本基本语法</h2>
<p>Lua 语法简单，适合嵌入式脚本应用。基本数据类型包括：<code>nil</code>（空）、<code>boolean</code>（布尔值）、<code>number</code>（数字）、<code>string</code>（字符串）和 <code>table</code>（表）。<code>table</code> 是 Lua 的核心数据结构，它既可表现为数组也可表现为字典。</p>
<p>变量声明：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;example&#x27;</span>       <span class="comment">-- 全局变量</span></span><br><span class="line"><span class="keyword">local</span> age = <span class="number">18</span>         <span class="comment">-- 局部变量</span></span><br></pre></td></tr></table></figure>
<p>表（类似数组、字典）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> arr = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>&#125;        <span class="comment">-- 数组样</span></span><br><span class="line"><span class="keyword">local</span> dict = &#123;key=<span class="string">&#x27;value&#x27;</span>&#125;       <span class="comment">-- 字典样</span></span><br></pre></td></tr></table></figure>
<p>控制结构类似其他语言：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> x &lt; <span class="number">20</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;medium&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;large&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>循环遍历表：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(arr) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>返回值可以使用 <code>return</code>，Lua 支持返回多个值，但在 Redis 脚本中推荐返回一个表以避免客户端解析混乱。</p>
<h2 id="Lua-脚本在-Redis-中的使用方式">Lua 脚本在 Redis 中的使用方式</h2>
<p>在 Redis 中执行 Lua 脚本核心命令是 <code>EVAL</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; &lt;key1&gt; ... &lt;keyN&gt; &lt;arg1&gt; ... &lt;argM&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;script&gt;</code>：Lua 脚本内容</li>
<li><code>&lt;numkeys&gt;</code>：脚本使用的 Redis 键数量</li>
<li>接下来是 <code>&lt;key1&gt; ... keyN</code>，脚本中通过 <code>KEYS[1]</code> 等访问</li>
<li>余下是参数通过 <code>ARGV[1]</code> 等访问。</li>
</ul>
<p>键与参数分离的目的是让 Redis 能够基于 <code>numkeys</code> 提前分析访问的键，有助于集群模式下正确路由。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span> 1 mykey</span><br></pre></td></tr></table></figure>
<p>Redis 还提供了脚本缓存机制，通过 <code>SCRIPT LOAD</code> 加载脚本并返回 SHA1 摘要，然后可用 <code>EVALSHA</code> 执行，避免每次发送完整脚本字符串，提高性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT LOAD <span class="string">&quot;return &#x27;hello&#x27;&quot;</span></span><br><span class="line">EVALSHA &lt;sha1&gt; 0</span><br></pre></td></tr></table></figure>
<h2 id="Redis-中-Lua-脚本的特性与原理">Redis 中 Lua 脚本的特性与原理</h2>
<p>Lua 脚本在 Redis 内部执行时具有以下关键特性：</p>
<ul>
<li><strong>原子性</strong>：整个脚本在执行期间不会被打断，所有命令作为一个原子事务运行。</li>
<li><strong>阻塞执行</strong>：执行期间 Redis 不处理其他客户端命令，因此脚本应保持短小以避免阻塞客户端。</li>
<li><strong>数据类型转换</strong>：Lua 与 Redis 之间数据互传需进行类型转换，例如 Lua 返回的小数可能被转换成整数。</li>
<li><strong>错误处理</strong>：<code>redis.call()</code> 在命令错误时会抛出错误，中断脚本；<code>redis.pcall()</code> 则返回错误表，可在脚本内部捕获处理。</li>
</ul>
<h2 id="Redis-中的最佳实践">Redis 中的最佳实践</h2>
<p><strong>脚本设计</strong><br>
Lua 脚本应尽量保持短、逻辑简单。避免大型循环或长耗时计算，因为它们会阻塞 Redis 线程。</p>
<p><strong>参数与键分离</strong><br>
使用 <code>KEYS</code> 和 <code>ARGV</code> 明确区分 Redis 键和参数。键用于 Redis 访问，参数用于业务逻辑。Redis 集群模式下所有键应在同一槽位以避免错误脚本行为。</p>
<p><strong>缓存机制</strong><br>
尽可能通过 <code>SCRIPT LOAD</code> 和 <code>EVALSHA</code> 重用脚本，减少网络传输和重复编译开销。</p>
<p><strong>错误与测试</strong><br>
在上线前全面测试脚本逻辑。脚本执行失败不会自动回滚之前的修改。需要在业务层处理失败后的状态一致性。</p>
<p><strong>避免复杂 Lua 特性</strong><br>
Lua 有许多语言特性如协程、复杂函数定义等，但在 Redis 脚本中应避免使用，聚焦于简单逻辑以提高可维护性。</p>
<p>以下内容在 Redis + Lua 的工程语境下展开，强调<strong>为什么用、怎么用、避免什么</strong>。</p>
<h2 id="Redis-使用实例">Redis 使用实例</h2>
<h3 id="库存扣减（高并发原子性）">库存扣减（高并发原子性）</h3>
<p><strong>场景</strong></p>
<p>秒杀、抢购、优惠券库存扣减。<br>
要求：<strong>不能超卖、不能多扣、必须原子执行</strong>。</p>
<p><strong>问题本质</strong></p>
<p>以下逻辑如果拆散为多条命令，会产生竞态条件：</p>
<ol>
<li>查询库存</li>
<li>判断是否大于 0</li>
<li>扣减库存</li>
</ol>
<p><strong>Lua 脚本实现</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> stock <span class="keyword">or</span> stock &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;DECR&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> stock - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Redis 调用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">&quot;&lt;lua-script&gt;&quot;</span> 1 stock:sku:1001</span><br></pre></td></tr></table></figure>
<p><strong>价值</strong></p>
<ul>
<li>单线程原子执行</li>
<li>无需 Redis 事务（MULTI/EXEC）</li>
<li>避免客户端 CAS 自旋</li>
<li>秒杀场景标准解法</li>
</ul>
<h3 id="分布式限流（滑动窗口）">分布式限流（滑动窗口）</h3>
<p><strong>场景</strong></p>
<p>接口防刷、短信验证码、登录频控。</p>
<p><strong>限流规则示例</strong></p>
<ul>
<li>每个用户</li>
<li>10 秒内最多 5 次</li>
</ul>
<p><strong>Lua 脚本实现（ZSET）</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> window = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;ZREMRANGEBYSCORE&#x27;</span>, key, <span class="number">0</span>, now - window)</span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;ZCARD&#x27;</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count &gt;= limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;ZADD&#x27;</span>, key, now, now)</span><br><span class="line">redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, window)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>特点</strong></p>
<ul>
<li>精确滑动窗口</li>
<li>清理 + 判断 + 写入一次完成</li>
<li>避免多命令时间漂移</li>
</ul>
<p><strong>价值</strong></p>
<ul>
<li>高并发下限流结果一致</li>
<li>Lua 是唯一正确解法</li>
</ul>
<h3 id="防重复提交-幂等控制">防重复提交 / 幂等控制</h3>
<p><strong>场景</strong></p>
<ul>
<li>表单重复提交</li>
<li>订单重复创建</li>
<li>MQ 消费幂等</li>
</ul>
<p><strong>典型逻辑</strong></p>
<ul>
<li>key 不存在 → 执行业务</li>
<li>key 存在 → 拒绝</li>
</ul>
<p><strong>Lua 脚本</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;EXISTS&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="string">&#x27;EX&#x27;</span>, ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ul>
<li>SETNX + EXPIRE 原子化</li>
<li>不依赖 Redis 版本是否支持 SET key value NX EX</li>
</ul>
<h2 id="Java-中调用-Redis-Lua-脚本">Java 中调用 Redis Lua 脚本</h2>
<h3 id="StringRedisTemplate-调用方式"><strong>StringRedisTemplate 调用方式</strong></h3>
<p>适用场景</p>
<ul>
<li>key / value 都是字符串</li>
<li>绝大多数业务场景首选</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lua</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;local stock = tonumber(redis.call(&#x27;GET&#x27;, KEYS[1])) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if not stock or stock &lt;= 0 then return -1 end &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;DECR&#x27;, KEYS[1]) return stock - 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">script.setScriptText(lua);</span><br><span class="line">script.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">        script,</span><br><span class="line">        Collections.singletonList(<span class="string">&quot;stock:sku:1001&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>关键点</p>
<ul>
<li><code>KEYS</code> → List 传入</li>
<li><code>ARGV</code> → execute 后的可变参数</li>
<li>返回值类型必须显式声明</li>
</ul>
<h3 id="RedisTemplate-调用方式">RedisTemplate 调用方式</h3>
<p>适用场景</p>
<ul>
<li>value 是对象、JSON、复杂结构</li>
<li>使用序列化器</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">script.setScriptText(lua);</span><br><span class="line">script.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; keys = Arrays.asList(<span class="string">&quot;stock:sku:1001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">        script,</span><br><span class="line">        redisTemplate.getStringSerializer(),</span><br><span class="line">        redisTemplate.getValueSerializer(),</span><br><span class="line">        keys</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>Redis 内置 Lua 脚本功能用于将一系列命令组合为一个原子操作，提高性能、减少网络往返、保证逻辑一致性。Lua 语法简单，适合轻量级编写 Redis 逻辑。通过 <code>EVAL</code>、<code>EVALSHA</code>、<code>SCRIPT LOAD</code> 等命令执行和管理脚本，结合良好设计和测试策略，可显著提升 Redis 的开发效率与运行稳定性。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/" title="RedisTemplate &amp; StringRedisTemplate 使用指南"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" onerror="onerror=null;src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RedisTemplate & StringRedisTemplate 使用指南</div></div><div class="info-2"><div class="info-item-1">RedisTemplate &amp; StringRedisTemplate 使用指南 前言 由于对于 Redis 始终停留在理论阶段——懂数据结构类型、数据结构底层实现、缓存击穿、缓存穿透、缓存雪崩，还有各种防xxx的方案，但是貌似都停留在学习上、代码阅读上，现在重新补充一下代码实现的细节上。 项目中很多地方使用了 StringRedisTemplate，其实是继承自 RedisTemplate 的。 然后就去搜 RedisTemplate 的 API、搜如何使用，挑选了7-8篇博客结合 ai 整理知识点如下： 从导入依赖开始 为什么是从导入依赖开始呢？主要是这个过程引发了我的疑问： 看到有一篇博客使用如下pom依赖： 12345&lt;!--Redis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis 底层数据结构"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani6.png" onerror="onerror=null;src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis 底层数据结构</div></div><div class="info-2"><div class="info-item-1">Redis 底层数据结构 Redis 的高性能并非来自单一结构，而是通过多种针对场景高度定制的数据结构实现。上层五种数据类型（String / List / Hash / Set / ZSet）只是抽象接口，真正的性能边界由底层结构决定。 SDS（Simple Dynamic String） 基本原理 SDS 是 Redis 自定义的字符串实现，替代 C 原生 char*。其核心是显式维护字符串长度与剩余空间。 典型结构： 12345struct sdshdr &#123;    int len;    // 已用长度    int alloc;  // 分配总长度    char buf[];&#125; 核心特点  O(1) 获取长度（避免 strlen） 支持二进制数据（不依赖 \0作为字符串的结尾） 预分配与惰性释放，减少内存重分配 避免缓冲区溢出  使用到的数据类型  String 所有 key Hash / List / Set / ZSet 内部元素  时间复杂度  获取长度：O(1) 追加：均摊 O(1) 修改：O(n)  链表（Linked...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis 底层数据结构"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-14</div><div class="info-item-2">Redis 底层数据结构</div></div><div class="info-2"><div class="info-item-1">Redis 底层数据结构 Redis 的高性能并非来自单一结构，而是通过多种针对场景高度定制的数据结构实现。上层五种数据类型（String / List / Hash / Set / ZSet）只是抽象接口，真正的性能边界由底层结构决定。 SDS（Simple Dynamic String） 基本原理 SDS 是 Redis 自定义的字符串实现，替代 C 原生 char*。其核心是显式维护字符串长度与剩余空间。 典型结构： 12345struct sdshdr &#123;    int len;    // 已用长度    int alloc;  // 分配总长度    char buf[];&#125; 核心特点  O(1) 获取长度（避免 strlen） 支持二进制数据（不依赖 \0作为字符串的结尾） 预分配与惰性释放，减少内存重分配 避免缓冲区溢出  使用到的数据类型  String 所有 key Hash / List / Set / ZSet 内部元素  时间复杂度  获取长度：O(1) 追加：均摊 O(1) 修改：O(n)  链表（Linked...</div></div></div></a><a class="pagination-related" href="/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/" title="RedisTemplate &amp; StringRedisTemplate 使用指南"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">RedisTemplate &amp; StringRedisTemplate 使用指南</div></div><div class="info-2"><div class="info-item-1">RedisTemplate &amp; StringRedisTemplate 使用指南 前言 由于对于 Redis 始终停留在理论阶段——懂数据结构类型、数据结构底层实现、缓存击穿、缓存穿透、缓存雪崩，还有各种防xxx的方案，但是貌似都停留在学习上、代码阅读上，现在重新补充一下代码实现的细节上。 项目中很多地方使用了 StringRedisTemplate，其实是继承自 RedisTemplate 的。 然后就去搜 RedisTemplate 的 API、搜如何使用，挑选了7-8篇博客结合 ai 整理知识点如下： 从导入依赖开始 为什么是从导入依赖开始呢？主要是这个过程引发了我的疑问： 看到有一篇博客使用如下pom依赖： 12345&lt;!--Redis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Redis 数据类型"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">Redis 数据类型</div></div><div class="info-2"><div class="info-item-1">Redis 数据类型 所有的数据类型有：String、Hash、List、Set、Zset、BitMap、HyperLogLog、GEO、Stream String 介绍 String 就是最基本的 Key-Value 类型数据，key 是唯一标识，Value 可以是字符串也可以是数字（整数、浮点数）。 底层是由 SDS（Simple Dynamic String）进行实现。 常用指令    指令 描述     SET key value 设置指定 key 的值。如果 key 已经存在，则覆盖旧值。   GET key 获取指定 key 的值。如果 key 不存在，返回 nil。   GETRANGE key start end 获取指定 key 中字符串值的子字符串。   SETEX key seconds value 设置 key 的值，并同时设置过期时间（以秒为单位）。   PSETEX key milliseconds value 设置 key 的值，并同时设置过期时间（以毫秒为单位）。   SETNX key value 仅在 key 不存在时设置 key 的值。如果...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 使用实践</div></div><div class="info-2"><div class="info-item-1">这一部分更多偏实践部分，理论部分见其余 Redis 相关博客</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 线程模型</div></div><div class="info-2"><div class="info-item-1">Redis 线程模型Redis 常被描述为“单线程高性能”的代表，但单线程并不等于简单或低效。准确理解 Redis 的线程模型，需要区分：命令执行、网络 I/O、后台任务这三条路径。 Redis 的单线程指的是什么是指—— Redis 的命令执行路径（command execution）是单线程的。 具体来说：  所有客户端命令，统一在 主线程 中，按顺序完成：读取 → 解析 → 执行 → 返回结果    这意味着：  不需要加锁、命令天然具备原子性、数据结构实现可以极度简化   但是，Redis 并不是整个进程只有一个线程  基于内存的设计Redis 将所有核心数据结构存放在内存中，而不是磁盘。 这带来的不仅是“快”这么简单：  避免磁盘 I/O 阻塞 单次命令执行时间高度可控 延迟分布稳定，适合单线程顺序执行模型  相比之下，频繁访问磁盘的系统（如传统关系型数据库）更容易出现阻塞点，不适合纯单线程执行所有逻辑。 关于数据不丢失的问题Redis...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 过期删除策略+缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">Redis 过期删除策略在介绍 Redis 的过期删除机制之前，需要先说明：定时删除、惰性删除、定期删除是对过期数据清理思路的抽象划分，用于分析不同策略在 CPU 开销与内存占用之间的取舍。实际的高性能缓存系统通常不会采用其中某一种，而是进行组合设计。 常见的过期删除策略1. 定时删除定时删除指的是：当键到达过期时间的瞬间立即删除该键。 其实现通常需要：  为每一个设置了过期时间的 key 维护独立的定时事件（如定时器或最小堆） 到期后触发删除回调  优点：  过期键能够被及时清理 内存利用率高  缺点：  定时事件数量与过期 key 数量近似线性相关 当过期 key 较多时，定时回调会占用大量 CPU 严重影响主线程吞吐量  因此，Redis 并未采用这种高精度但高成本的策略。 2. 惰性删除惰性删除的核心思想是：不主动删除过期 key，仅在访问时检查其是否过期。 执行流程：  客户端访问 key Redis 判断 key 是否已过期 若已过期，立即删除并返回 key 不存在  优点：  对 CPU 非常友好 不做无意义的主动扫描  缺点：  如果某些 key...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="author-info-name">暮雪Avid</div><div class="author-info-description">热爱+时间=实现</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yukinoshita52"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yukinoshita52" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://https://muxueblogs.netlify.app/about/" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/1808485376?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如出现图片访问失败问题，请科学上网，诶嘿(*^▽^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Redis中Lua脚本的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">Lua 脚本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">Lua 脚本基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E5%9C%A8-Redis-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Lua 脚本在 Redis 中的使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%AD-Lua-%E8%84%9A%E6%9C%AC%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">Redis 中 Lua 脚本的特性与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.</span> <span class="toc-text">Redis 中的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">Redis 使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%88%E9%AB%98%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">库存扣减（高并发原子性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">分布式限流（滑动窗口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4-%E5%B9%82%E7%AD%89%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">防重复提交 &#x2F; 幂等控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E8%B0%83%E7%94%A8-Redis-Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">1.7.</span> <span class="toc-text">Java 中调用 Redis Lua 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StringRedisTemplate-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">StringRedisTemplate 调用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisTemplate-%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">RedisTemplate 调用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani3.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 过期删除策略+缓存淘汰策略"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略">Redis 过期删除策略+缓存淘汰策略</a><time datetime="2025-12-22T12:08:37.000Z" title="发表于 2025-12-22 20:08:37">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani2.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 使用实践"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践">Redis 使用实践</a><time datetime="2025-12-22T11:25:26.000Z" title="发表于 2025-12-22 19:25:26">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 线程模型"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型">Redis 线程模型</a><time datetime="2025-12-22T10:01:25.000Z" title="发表于 2025-12-22 18:01:25">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/" title="技术图谱"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani10.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="技术图谱"/></a><div class="content"><a class="title" href="/2025/12/20/%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/" title="技术图谱">技术图谱</a><time datetime="2025-12-20T09:10:35.000Z" title="发表于 2025-12-20 17:10:35">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani3.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="docker个人实践记录"/></a><div class="content"><a class="title" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录">docker个人实践记录</a><time datetime="2025-12-16T07:44:45.000Z" title="发表于 2025-12-16 15:44:45">2025-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 By 暮雪Avid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://npm.elemecdn.com/nanshen@latest/img/icp.webp"><span>浙ICP备2025158028号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="/js/cursor-right.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,Yukinoshita,自由,平等,公正,诶嘿o(*￣︶￣*)o,法治,爱国,Yukino,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>