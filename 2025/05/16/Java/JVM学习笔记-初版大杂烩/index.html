<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JVM学习笔记--初版大杂烩 | 暮雪Avid的博客</title><meta name="author" content="暮雪Avid"><meta name="copyright" content="暮雪Avid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java程序员拥有JVM自动管理，但是，自由是存在代价的——为了不让内存处理不当成为系统性能的瓶颈，我们仍需要学习JVM相关知识，掌握其内存结构、清楚类加载机制、了解常见GC算法、学会GC调优。"><meta property="og:type" content="article"><meta property="og:title" content="JVM学习笔记--初版大杂烩"><meta property="og:url" content="https://blogs.muxueavid.top/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/index.html"><meta property="og:site_name" content="暮雪Avid的博客"><meta property="og:description" content="Java程序员拥有JVM自动管理，但是，自由是存在代价的——为了不让内存处理不当成为系统性能的瓶颈，我们仍需要学习JVM相关知识，掌握其内存结构、清楚类加载机制、了解常见GC算法、学会GC调优。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blogs.muxueavid.top/static/default_cover_imgs/blog-ani10.png"><meta property="article:published_time" content="2025-05-15T16:00:00.000Z"><meta property="article:modified_time" content="2025-05-16T16:00:00.000Z"><meta property="article:author" content="暮雪Avid"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blogs.muxueavid.top/static/default_cover_imgs/blog-ani10.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM学习笔记--初版大杂烩",
  "url": "https://blogs.muxueavid.top/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/",
  "image": "https://blogs.muxueavid.top/static/default_cover_imgs/blog-ani10.png",
  "datePublished": "2025-05-15T16:00:00.000Z",
  "dateModified": "2025-05-16T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "暮雪Avid",
      "url": "https://blogs.muxueavid.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/./static/imgs/avator.jpg"><link rel="canonical" href="https://blogs.muxueavid.top/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JVM学习笔记--初版大杂烩",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image:url(static/imgs/background.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./static/imgs/avator.jpg" onerror='this.onerror=null,this.src="/./static/imgs/error.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(static/default_cover_imgs/blog-ani10.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">暮雪Avid的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM学习笔记--初版大杂烩</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM学习笔记--初版大杂烩</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-15T16:00:00.000Z" title="发表于 2025-05-16 00:00:00">2025-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-16T16:00:00.000Z" title="更新于 2025-05-17 00:00:00">2025-05-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM运行的整体流程"><a href="#JVM运行的整体流程" class="headerlink" title="JVM运行的整体流程"></a>JVM运行的整体流程</h1><blockquote><p>笔记：依据<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PJ411n7xZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d">视频教程</a>学习后，纯看配图，使用的个人语言的书写（有水印的配图进行了自己绘制）</p><p>目前版本：1.0</p></blockquote><p><img src="./imgs/blog-20250516201106780.jpg" style="zoom:67%"></p><p>宏观来看，JVM的不同操作系统的实现，使得Java经过一次编译后的.class字节码文件，能够在不同的平台上运行</p><p>印证了流程很广泛的一句话——“一次编译，处处运行”</p><p>其实不仅仅是Java语言，其他的语言，只要仅编译器编译后符合JVM所定义的字节码文件的格式规范，就能在Java虚拟机上运行：</p><p><img src="./imgs/blog-20250516201832202.jpg" style="zoom:67%"></p><p><strong>JVM的作用</strong></p><p>Java虚拟机就是二进制字节码文件的<strong>运行时环境</strong>，负责装载字节码到其内部，解释or编译为对应操作系统平台的机器指令执行。</p><p><strong>JVM架构图</strong></p><p><img src="./imgs/blog-20250516202357582.jpg" style="zoom:67%"></p><p>注：此图非常重要，要非常熟悉。</p><p>上图较为简易的描述了JVM的工作流程：</p><ol><li>从一个class字节码文件开始</li><li>首先经过类加载子系统的加载</li><li>然后把加载后的信息保存进入运行时数据区</li><li>运行时数据区的内存结构划分为不同的结构——方法区用于存放类的方法信息；堆中主要用于保存对象、字符串常量等信息；程序计数器仅用于保存程序要执行的下一条指令信息；本地方法栈中保存的是一些Java的核心类库的实现（一般用C/C++实现）；虚拟机栈中是一个个栈帧，栈帧保存了当前执行方法的所需信息（比如使用到的对象的引用、基本数据类型的值、String的引用）。</li><li>执行引擎负责具体的执行过程；本地方法接口从本地方法库加载方法的实现、然后被本地方法栈调用。</li></ol><blockquote><p>ps：描述不一定准确</p></blockquote><p>更加详细的架构图如下，可供复习使用：</p><p><img src="./imgs/blog-20250516205131610.jpg" style="zoom:67%"></p><p><strong>JVM架构模型</strong></p><p>JVM是<strong>基于栈的架构模型</strong>，不妨与另一种（<strong>基于寄存器的架构模型</strong>）进行对比，来说明其特点。</p><p>栈这种结构，联系数据结构与算法所学的知识，无非“进栈”、“出栈”、“后进先出”等特点</p><p>那么基于这些特点，其每一条指令就非常小，因为无需指定指令所对应的位置（因为对栈的操作就是在栈顶）；而基于寄存器的，每一条指令就显得长一些，因为它不光要指出指令的具体操作，还要明确操作的位置。举个简单例子：</p><p>同样执行2+3，基于栈架构所用指令（JVM为例）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure><p>基于寄存器架构（80x86汇编语言举例）举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,<span class="number">2</span> <span class="comment">//将ax寄存器的值设为1</span></span><br><span class="line">add ax,<span class="number">3</span> <span class="comment">//使ax寄存器的值加3</span></span><br></pre></td></tr></table></figure><p>可见，基于栈架构的所用指令数量会更多，即使其每一条指令很简单</p><p>那么JVM为什么要采用栈的架构呢？总结如下：</p><ol><li>基于栈架构，<strong>跨平台性更好</strong>。因为不同平台CPU架构不同，所以不能用基于寄存器架构的</li><li>虽然经过汇编后，相比于寄存器架构方式指令更多、运行效率更低，但是考虑到跨平台性和可移植性，JVM选择了栈架构的设计</li></ol><h1 id="类加载子系统（Class-Loader-SubSystem）"><a href="#类加载子系统（Class-Loader-SubSystem）" class="headerlink" title="类加载子系统（Class Loader SubSystem）"></a>类加载子系统（Class Loader SubSystem）</h1><h2 id="总括：Class-Loader-SubSystem的作用"><a href="#总括：Class-Loader-SubSystem的作用" class="headerlink" title="总括：Class Loader SubSystem的作用"></a>总括：Class Loader SubSystem的作用</h2><p>类加载子系统只负责将class文件中的类的信息加载到JVM中，<strong>加载的类信息存放于一块称为方法区的内存空间</strong>，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p>它起了一个<strong>创造模板</strong>的作用，详细些：class文件中存储了一些类的模板信息（比如定义了哪些字段、有哪些方法、实现了哪些接口、父类是谁等），然后类加载子系统把这些模板的信息读取进来（到JVM中）</p><p><img src="./imgs/blog-20250516211557952.png" style="zoom:67%"></p><p>这些“模板信息”存放于方法区中（JDK8前叫做永久代，在堆中；JDK8后改为云空间，在系统内存中）</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="./imgs/blog-20250516213120744.png" style="zoom:67%"></p><h3 id="1-加载（Loading）"><a href="#1-加载（Loading）" class="headerlink" title="1 加载（Loading）"></a>1 加载（Loading）</h3><blockquote><p>非自己语言</p></blockquote><p><strong>加载：</strong></p><ol><li><p>通过一个类的<strong>全限定名</strong>获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="2-链接（Linking）"><a href="#2-链接（Linking）" class="headerlink" title="2 链接（Linking）"></a>2 链接（Linking）</h3><blockquote><p>非自己语言</p></blockquote><p>分为三个子阶段：验证、准备、解析</p><h4 id="2-1-验证（Verification）"><a href="#2-1-验证（Verification）" class="headerlink" title="2.1 验证（Verification）"></a>2.1 验证（Verification）</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求（e.g.开头的：<strong>CAFEBABE</strong>），保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><h4 id="2-2-准备（Preparation）"><a href="#2-2-准备（Preparation）" class="headerlink" title="2.2 准备（Preparation）"></a>2.2 准备（Preparation）</h4><ol><li>为<strong>类变量</strong>（<strong>static变量</strong>）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-解析（Resolution）"><a href="#2-3-解析（Resolution）" class="headerlink" title="2.3 解析（Resolution）"></a>2.3 解析（Resolution）</h4><ol><li><p><strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p><strong>符号引用</strong>就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><h3 id="3-初始化（Initialization）"><a href="#3-初始化（Initialization）" class="headerlink" title="3 初始化（Initialization）"></a>3 初始化（Initialization）</h3><blockquote><p>即<clinit>方法的调用——在此时发生</clinit></p></blockquote><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.yukino.User”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><blockquote><p>非自己语言</p></blockquote><ol><li>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</li></ol><p><img src="./imgs/blog-20250517122036577.png" style="zoom:80%"></p><h3 id="JDK1-8中源码继承关系图"><a href="#JDK1-8中源码继承关系图" class="headerlink" title="JDK1.8中源码继承关系图"></a>JDK1.8中源码继承关系图</h3><p><strong>ExtClassLoader</strong>（<strong>Launcher内部类</strong>）——扩展类加载器</p><p><img src="./imgs/blog-20250517122512461.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器（也成系统类加载器）</p><p><img src="./imgs/blog-20250517122710042.png" alt=""></p><h3 id="JDK1-9及之后的"><a href="#JDK1-9及之后的" class="headerlink" title="JDK1.9及之后的"></a>JDK1.9及之后的</h3><blockquote><p>注意继承于<strong>BuiltinClassLoader</strong>了，不再是<strong>URLClassLoader</strong></p></blockquote><p><strong>PlatformClassLoader（Launcher内部类）</strong>——平台类加载器</p><p><img src="./imgs/blog-20250517123421236.png" alt=""></p><p><strong>AppClassLoader</strong>（<strong>Launcher内部类</strong>）——应用类加载器</p><p><img src="./imgs/blog-20250517123544208.png" alt=""></p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><blockquote><p>非自己语言</p></blockquote><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（ExtClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li><strong>隔离加载类</strong>（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架、中间件之间是隔离的）</li><li><strong>修改类加载的方式</strong></li><li><strong>扩展加载源</strong>（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li><strong>防止源码泄漏</strong>（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？"><a href="#如何自定义类加载器？" class="headerlink" title="如何自定义类加载器？"></a>如何自定义类加载器？</h4><ol><li>开发人员可以通过<strong>继承抽象类java.lang.ClassLoader类</strong>的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findclass()</code>方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写<code>findclass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h2><p>ClassLoader是一个抽象类，其后所有的类加载器都继承自ClassLoader（JDK8的启动类加载器除外）</p><p>（JDK9之后的BootClassLoader又间接继承与ClassLoader了）</p><p><img src="./imgs/blog-20250517185020815.png" alt=""></p><div class="table-container"><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的示例</td></tr><tr><td>defineClass(String name,byte[] b,int off, int len)</td><td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的示例</td></tr><tr><td>resolveClass(Class&lt;?&gt; e)</td><td>连接指定的一个Java类</td></tr></tbody></table></div><p><strong>获取ClassLoader的途径</strong></p><div class="table-container"><table><thead><tr><th>获取当前类的ClassLoader</th><th>clazz.getClassLoader()</th></tr></thead><tbody><tr><td><strong>获取当前线程上下文的ClassLoader</strong></td><td>Thread.currentThread().getContextClassLoader()</td></tr><tr><td><strong>获取系统的ClassLoader</strong></td><td>ClassLoader.getSystemClassLoader()</td></tr><tr><td><strong>获取调用者的ClassLoader</strong></td><td>DriverManager.getCallerClassLoader()</td></tr></tbody></table></div><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><p><img src="./imgs/blog-20250517190508639.png" style="zoom:67%"></p><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li><p><strong>类的全类名一致</strong></p></li><li><p><strong>加载这个类的ClassLoader实例对象一致</strong></p><blockquote><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p></blockquote></li></ol><h2 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h2><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ol><h1 id="运行时数据区（Runtime-Data-Area）"><a href="#运行时数据区（Runtime-Data-Area）" class="headerlink" title="运行时数据区（Runtime Data Area）"></a>运行时数据区（Runtime Data Area）</h1><blockquote><p>通过之前的：类的加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化，就会使用执行引擎对类进行使用，同时执行引擎还会使用到运行时数据区中的数据</p></blockquote><p><img src="./imgs/blog-20250517193445230.png" style="zoom:80%"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><p><strong>JVM 系统线程</strong></p><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h2 id="程序计数器（PC-Register）"><a href="#程序计数器（PC-Register）" class="headerlink" title="程序计数器（PC Register）"></a>程序计数器（PC Register）</h2><p><img src="./imgs/blog-20250517201638237.png" style="zoom:67%"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><p><strong>PC寄存器的作用</strong>，一言以蔽之：</p><p>PC寄存器用来存储指向下一条指令的地址。由执行引擎读取下一条指令，并执行该指令。</p><h2 id="本地方法接口-本地方法库"><a href="#本地方法接口-本地方法库" class="headerlink" title="本地方法接口+本地方法库"></a>本地方法接口+本地方法库</h2><p><img src="./imgs/blog-20250517202140204.png" style="zoom:67%"></p><p>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong></p><p>因此，在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，初衷是融合C/C++程序。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><blockquote><p><strong>就是用于调用本地方法接口的</strong></p></blockquote><p><img src="./imgs/blog-20250517202533710.png" style="zoom:80%"></p><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><blockquote><p>栈管运行，堆管存储</p><p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</p></blockquote><h3 id="虚拟机栈是什么？"><a href="#虚拟机栈是什么？" class="headerlink" title="虚拟机栈是什么？"></a>虚拟机栈是什么？</h3><p><img src="./imgs/blog-20250518114956160.png" style="zoom:67%"></p><ul><li><p>虚拟机栈（VM Stack）。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</p></li><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><p><img src="./imgs/blog-20250518115530548.png" style="zoom:67%"></p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p><img src="./imgs/blog-20250518120415477.png" style="zoom:80%"></p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="./imgs/blog-20250518120603099.png" style="zoom:67%"></p><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="./imgs/blog-20250518120634048.png" style="zoom:67%"></p><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><h3 id="认识局部变量表"><a href="#认识局部变量表" class="headerlink" title="认识局部变量表"></a>认识局部变量表</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h3 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h3><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><p><img src="./imgs/blog-20250518121636958.png" style="zoom:67%"></p><blockquote><p>可见除double、long类型占2个slot外，其余类型均占1个slot</p></blockquote><h3 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量<strong>过了其作用域</strong>，那么在其作用域之后申明新的局部变量变就很有可能会<strong>复用</strong>过期局部变量的槽位，从而达到节省资源的目的。</p><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line">1、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line">2、按照在类中声明的位置分：</span><br><span class="line">  2-1、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ol><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><h3 id="操作数栈字节码示例"><a href="#操作数栈字节码示例" class="headerlink" title="操作数栈字节码示例"></a>操作数栈字节码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><img src="./imgs/blog-20250518123010951.png" style="zoom:80%"></p><p>详细运行过程如下：</p><ol><li><img src="./imgs/blog-20250518123758242.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518123943672.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124040895.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124229041.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124327892.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124617207.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124744230.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518124859690.png" style="zoom:67%"></li><li><img src="./imgs/blog-20250518125044802.png" style="zoom:67%"></li></ol><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p></li></ol><p><strong>符号引用</strong>，指向的为——方法名、方法参数、返回值类型等信息，而<strong>直接引用</strong>就是指向了实际要执行的方法信息（例如符号引用指向的是接口中定义的方法，然后直接引用就是指向其实现类的实现方法？）</p><p><strong>为什么要用常量池呢？</strong></p><ol><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h4 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h4><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><h4 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h4><ol><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol><h5 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h5><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h5 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a>关于 invokedynamic 指令</h5><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><h5 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h5><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java：String info = &quot;mogu blog&quot;;     		(Java是静态类型语言的，会先编译就进行类型检查)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS：var name = &quot;shkstart&quot;;    var name = 10;	（运行时才进行检查）   </span><br></pre></td></tr></table></figure><pre><code>Python: info = 130.5 (运行时才检查)
</code></pre><h5 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h5><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p></li></ol><p><strong>举例</strong></p><p>如下图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p>再比如：</p><ul><li><p>son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p></li><li><p>下次Son对象再调用toString就直接去找Object，不用先找Son—&gt;再找Father—&gt;最后才到Object的这样的一个过程。</p></li></ul><p><img src="./imgs/blog-20250518131803931.png" style="zoom:67%"></p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p><strong>正常退出</strong>：正常执行完成</p><ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li><p>在字节码指令中，返回指令包含：</p><ul><li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ul></li><li><p><strong>异常退出</strong>：出现未处理的异常，非正常退出</p><ul><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>，方便在发生异常的时候找到处理异常的代码</p><blockquote><p>异常处理表：</p></blockquote><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul></li></ul></li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><h3 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h3><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h3 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h3><h4 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h4><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h4 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h4><p>不能保证不溢出，只能保证SOF出现的几率小</p><h4 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h4><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h4 id="垃圾回收是否涉及到虚拟栈？"><a href="#垃圾回收是否涉及到虚拟栈？" class="headerlink" title="垃圾回收是否涉及到虚拟栈？"></a>垃圾回收是否涉及到虚拟栈？</h4><p>不会</p><div class="table-container"><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table></div><h4 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h4><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h1></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/./static/default_cover_imgs/blog-ani10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="汇编语言"><img class="cover" src="/./static/default_cover_imgs/blog-ani5.png" onerror='onerror=null,src="/./static/imgs/error.png"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">汇编语言</div></div><div class="info-2"><div class="info-item-1">汇编语言寄存器 对于8086、8088或80286，阴影区域是不可用的 FS和GS寄存器无专用名称 通用寄存器 数据寄存器：AX（accumulator）、BX（base）、CX（count）、DX（data） 指针寄存器：SP（stack pointer）、BP（base pointer） 变址寄存器：DI（destination index）、SI（source index） 控制寄存器 IP（instruction pointer）、FLAGS 段寄存器 CS（code segment）、DS（data segment）、ES（extra segment）、SS（stack segment） 标志寄存器 OF溢出标志，运算过程溢出置1，否则置0 SF符号标志，结果为负置1，否则置0 ZF零标志，运算结果为0置1，否则置0 CF进位标志，e.g.加法运算中，有进位置1，否则置0 AF辅助进位标志，记录运算时第三位产生的进位值 PF奇偶标志。结果操作数中1个数为偶置1，否则置0 标志位 标志名 标志为1 标志为0 OF ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./static/imgs/avator.jpg" onerror='this.onerror=null,this.src="/./static/imgs/error.gif"' alt="avatar"></div><div class="author-info-name">暮雪Avid</div><div class="author-info-description">热爱+时间=实现</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yukinoshita52"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yukinoshita52" target="_blank" title="Github"><i class="fab fa-github" style="color:#4a7dbe"></i></a><a class="social-icon" href="/2642350585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://space.bilibili.com/1808485376?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不定时更新，记录知识点or工具使用</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">JVM运行的整体流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%88Class-Loader-SubSystem%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">类加载子系统（Class Loader SubSystem）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E6%8B%AC%EF%BC%9AClass-Loader-SubSystem%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">总括：Class Loader SubSystem的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">1 加载（Loading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">2 链接（Linking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.1 验证（Verification）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2 准备（Preparation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.3 解析（Resolution）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">3 初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8%E4%B8%AD%E6%BA%90%E7%A0%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">2.3.1.</span> <span class="toc-text">JDK1.8中源码继承关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-9%E5%8F%8A%E4%B9%8B%E5%90%8E%E7%9A%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">JDK1.9及之后的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">虚拟机自带的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">系统类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">用户自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">什么时候需要自定义类加载器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">如何自定义类加载器？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EClassLoader"><span class="toc-number">2.4.</span> <span class="toc-text">关于ClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">双亲委派机制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF"><span class="toc-number">2.5.2.</span> <span class="toc-text">双亲委派机制优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.</span> <span class="toc-text">沙箱安全机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AAclass%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">如何判断两个class对象是否相同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">对类加载器的引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88Runtime-Data-Area%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">运行时数据区（Runtime Data Area）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">运行时数据区与内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">JVM 线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-Register%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">程序计数器（PC Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%BA%93"><span class="toc-number">3.3.</span> <span class="toc-text">本地方法接口+本地方法库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.5.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.1.</span> <span class="toc-text">虚拟机栈是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.5.2.</span> <span class="toc-text">虚拟机栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.3.</span> <span class="toc-text">虚拟机栈的异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="toc-number">3.6.</span> <span class="toc-text">栈的存储单位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.6.1.</span> <span class="toc-text">栈中存储什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">栈运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.3.</span> <span class="toc-text">栈帧的内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">认识局部变量表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eslot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.7.2.</span> <span class="toc-text">关于slot的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="toc-number">3.7.3.</span> <span class="toc-text">slot的重复利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.4.</span> <span class="toc-text">静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">3.7.5.</span> <span class="toc-text">补充说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.8.</span> <span class="toc-text">操作数栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.8.1.</span> <span class="toc-text">操作数栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.8.2.</span> <span class="toc-text">操作数栈的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E5%AD%97%E8%8A%82%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.8.3.</span> <span class="toc-text">操作数栈字节码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">3.8.4.</span> <span class="toc-text">栈顶缓存技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.8.5.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.8.6.</span> <span class="toc-text">方法的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.8.6.1.</span> <span class="toc-text">静态链接与动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E7%BB%91%E5%AE%9A%E4%B8%8E%E6%99%9A%E6%9C%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">3.8.6.2.</span> <span class="toc-text">早期绑定与晚期绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="toc-number">3.8.6.3.</span> <span class="toc-text">多态与绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.6.3.1.</span> <span class="toc-text">虚方法与非虚方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-invokedynamic-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.8.6.3.2.</span> <span class="toc-text">关于 invokedynamic 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-number">3.8.6.3.3.</span> <span class="toc-text">动态语言和静态语言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.8.6.3.4.</span> <span class="toc-text">Java语言中方法重写的本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">3.8.7.</span> <span class="toc-text">虚方法表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.8.8.</span> <span class="toc-text">方法返回地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="toc-number">3.8.9.</span> <span class="toc-text">一些附加信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.8.10.</span> <span class="toc-text">栈相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">3.8.10.1.</span> <span class="toc-text">举例栈溢出的情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%A0%88%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%B0%B1%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%8D%E5%87%BA%E7%8E%B0%E6%BA%A2%E5%87%BA%E4%B9%88%EF%BC%9F"><span class="toc-number">3.8.10.2.</span> <span class="toc-text">调整栈大小，就能保证不出现溢出么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E8%B6%8A%E5%A4%A7%E8%B6%8A%E5%A5%BD%E4%B9%88%EF%BC%9F"><span class="toc-number">3.8.10.3.</span> <span class="toc-text">分配的栈内存越大越好么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E5%90%A6%E6%B6%89%E5%8F%8A%E5%88%B0%E8%99%9A%E6%8B%9F%E6%A0%88%EF%BC%9F"><span class="toc-number">3.8.10.4.</span> <span class="toc-text">垃圾回收是否涉及到虚拟栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.8.10.5.</span> <span class="toc-text">方法中定义的局部变量是否线程安全？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#To-Be-Continue"><span class="toc-number">4.</span> <span class="toc-text">To Be Continue</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/" title="JVM学习笔记--初版大杂烩"><img src="/./static/default_cover_imgs/blog-ani10.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="JVM学习笔记--初版大杂烩"></a><div class="content"><a class="title" href="/2025/05/16/Java/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%9D%E7%89%88%E5%A4%A7%E6%9D%82%E7%83%A9/" title="JVM学习笔记--初版大杂烩">JVM学习笔记--初版大杂烩</a><time datetime="2025-05-15T16:00:00.000Z" title="发表于 2025-05-16 00:00:00">2025-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="汇编语言"><img src="/./static/default_cover_imgs/blog-ani5.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="汇编语言"></a><div class="content"><a class="title" href="/2025/04/24/other/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="汇编语言">汇编语言</a><time datetime="2025-04-24T05:28:54.000Z" title="发表于 2025-04-24 13:28:54">2025-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/23/Python/JS%E9%80%86%E5%90%91/" title="JS逆向"><img src="/./static/default_cover_imgs/blog-ani1.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="JS逆向"></a><div class="content"><a class="title" href="/2025/04/23/Python/JS%E9%80%86%E5%90%91/" title="JS逆向">JS逆向</a><time datetime="2025-04-23T05:48:07.000Z" title="发表于 2025-04-23 13:48:07">2025-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/" title="爬虫之Scrapy框架使用"><img src="/./static/default_cover_imgs/blog-ani4.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="爬虫之Scrapy框架使用"></a><div class="content"><a class="title" href="/2025/04/20/Python/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/" title="爬虫之Scrapy框架使用">爬虫之Scrapy框架使用</a><time datetime="2025-04-20T05:28:18.000Z" title="发表于 2025-04-20 13:28:18">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/" title="Python爬虫基础"><img src="/./static/default_cover_imgs/blog-ani8.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="Python爬虫基础"></a><div class="content"><a class="title" href="/2025/04/19/Python/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/" title="Python爬虫基础">Python爬虫基础</a><time datetime="2025-04-19T06:03:34.000Z" title="发表于 2025-04-19 14:03:34">2025-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">&copy;2025 By 暮雪Avid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://npm.elemecdn.com/nanshen@latest/img/icp.webp"><span>浙ICP备2025158028号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="/js/pictureCDN.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,Yukinoshita,自由,平等,公正,诶嘿o(*￣︶￣*)o,法治,爱国,Yukino,敬业,诚信,友善" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>