<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>DataStructure基础——树 | 暮雪Avid的博客</title><meta name="author" content="暮雪Avid"><meta name="copyright" content="暮雪Avid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="包含二叉树、赫夫曼树、二叉搜索树、平衡二叉树、多叉树，涉及到了他们的各自的性质、方法、使用场景。理解树，热爱树，成为树[doge]！"><meta property="og:type" content="article"><meta property="og:title" content="DataStructure基础——树"><meta property="og:url" content="https://blogs.muxueavid.top/2025/03/30/algorithm/datastruct/%E6%A0%91/index.html"><meta property="og:site_name" content="暮雪Avid的博客"><meta property="og:description" content="包含二叉树、赫夫曼树、二叉搜索树、平衡二叉树、多叉树，涉及到了他们的各自的性质、方法、使用场景。理解树，热爱树，成为树[doge]！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani12.png"><meta property="article:published_time" content="2025-03-30T14:26:12.000Z"><meta property="article:modified_time" content="2025-03-30T14:26:12.000Z"><meta property="article:author" content="暮雪Avid"><meta property="article:tag" content="数据结构与算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani12.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DataStructure基础——树",
  "url": "https://blogs.muxueavid.top/2025/03/30/algorithm/datastruct/%E6%A0%91/",
  "image": "https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani12.png",
  "datePublished": "2025-03-30T14:26:12.000Z",
  "dateModified": "2025-03-30T14:26:12.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "暮雪Avid",
      "url": "https://blogs.muxueavid.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/./static/imgs/avator.jpg"><link rel="canonical" href="https://blogs.muxueavid.top/2025/03/30/algorithm/datastruct/%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"DataStructure基础——树",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image:url(static/imgs/background.jpg)"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./static/imgs/avator.jpg" onerror='this.onerror=null,this.src="/./static/imgs/error.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani12.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">暮雪Avid的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">DataStructure基础——树</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">DataStructure基础——树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-30T14:26:12.000Z" title="发表于 2025-03-30 22:26:12">2025-03-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-30T14:26:12.000Z" title="更新于 2025-03-30 22:26:12">2025-03-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">24.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>树</h1><p><strong>为什么需要树这种存储结构?</strong></p><ol><li>数组：<ul><li>优点：通过下标方式查找元素，查找速度快，况且还可以通过排序+查找算法进一步提高查找速度，<strong>随机存取</strong>是其最大优势。</li><li>缺点：插入删除元素复杂，涉及到整体移动的问题，耗费大量时间。</li></ul></li><li>链式存储：<ul><li>优点：插入删除方便。</li><li>缺点：查找效率不高，需要从头开始遍历查找。</li></ul><blockquote><p>提一嘴哈希表（数组+链表版），一定程度上集数组和链表之长，既提高查找效率，又简化了插入删除操作。</p></blockquote></li><li>树：能提高数据的<strong>存储、读取</strong>效率，比如<strong>二叉排序树</strong>，即保证了查询效率，插入删除操作也方便。</li></ol><p><strong>树的常用术语</strong>(不必纠结)：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181746016.png" alt="image-20241103104817501" style="zoom:80%"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>节点</td><td>A、B、C……都是节点</td></tr><tr><td>根节点root</td><td>A</td></tr><tr><td>父节点</td><td>C是F和G的父节点</td></tr><tr><td>子节点</td><td>C是A的子节点</td></tr><tr><td>叶子节点</td><td>没有子节点的节点</td></tr><tr><td>节点的权</td><td>节点值</td></tr><tr><td>路径</td><td>从root找到当前节点的路线</td></tr><tr><td>层</td><td>如图</td></tr><tr><td>子树</td><td>D、H为B的子树</td></tr><tr><td>树的高度</td><td>4</td></tr><tr><td>森林</td><td>多棵树构成</td></tr></tbody></table><p>注意事项：</p><p>树分为有序树和无序树，有序树分左右，无序树不分左右。</p><h1>二叉树</h1><h2 id="基本概念">基本概念</h2><ol><li>每个节点都<strong>至多</strong>有两个子节点。</li><li>二叉树的子节点分为<strong>左节点</strong>和<strong>右节点</strong>。</li><li><strong>满二叉树</strong>：如果<strong>所有叶子节点都在最后一层</strong>，且节点总数为$2^n-1$个，其中n为层数，则称<strong>满二叉树</strong>。</li><li><strong>完全二叉树</strong>：若二叉树的<strong>所有叶子节点都在最后一层或倒数第二层</strong>，且最后一层的叶子节点<strong>左连续</strong>，倒数第二层的叶子节点<strong>右连续</strong>，则称<strong>完全二叉树</strong>。</li></ol><h2 id="性质">性质</h2><blockquote><p>参考《数据结构（C语言版）》–清华大学出版社</p><p>有助于加深对<a href="###%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91">顺序存储二叉树</a>中“<strong>为什么有这样的特点</strong>”的理解，使之成为严谨的数学推导。（当然不看也行，直接找规律也能推出来）</p></blockquote><ol><li>在二叉树的第$i$层至多有$2^{i-1}$个节点（$i\geq1$）</li><li>深度为$k$的二叉树至多有$2^k-1$个节点（$k\geq1$）</li><li>对任意一棵二叉树，如果其终端节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$</li></ol><blockquote><p>关于第三点的推导：</p><p>已知$n=n_0+n_1+n_2$，其中$n$为<strong>节点总数</strong>（这个式子是基于节点数列出来的）</p><p>又因为$n=n_1+2n_2+1$，这个式子的原因为<strong>节点数等于分支数+1</strong>，只有$n_1$有1个分支，$n_2$有2个分支，$n_0$没有分支。</p><p>两式消去$n_1$即可</p></blockquote><ol start="4"><li>具有n个节点的完全二叉树的深度 $\lfloor \log_2 n \rfloor + 1$。</li></ol><blockquote><p>Proof：</p><p>设深度为k，则根据完全二叉树定义以及性质2可知：</p><p>$2^{k-1}-1&lt;n\leq 2^k-1$或$2^{k-1}\leq n &lt; 2^k$，选则其一可解得……</p></blockquote><ol start="5"><li>对于一个有n个节点的完全二叉树，对于任一节点$i$（$1 \leq i \leq n$），有：<ul><li>若$i=1$，则为root节点；若$i&gt;1$，则其<strong>父节点</strong>为$\lfloor i/2 \rfloor$</li><li>若$2i&gt;n$，则节点$i$无左子节点，否则其<strong>左子节点</strong>为$2i$</li><li>若$2i+1&gt;n$，则节点$i$无右节点，否则其<strong>右子节点</strong>为$2i+1$</li></ul></li></ol><h2 id="链式存储二叉树">链式存储二叉树</h2><p>需要创建一个结点类，应包括数据本身的数据、左节点<code>left</code>、右节点<code>right</code>、[父节点<code>root</code>可选]</p><p>连式存储很常见，所以不做代码演示，因为后续的很多都用到了链式存储……</p><p>而且遍历、查找方法在节点类中均有写，但是最终我们是通过调用<code>BinaryTree</code>这个类里面的方法，所以节点类里面写的方法一般情况是给二叉树用的（如遍历、查找[后续代码可见其用意]）</p><h2 id="前序-中序-后续遍历">前序/中序/后续遍历</h2><h3 id="思路分析">思路分析</h3><blockquote><p>区分前/中/后序，看父节点什么时候输出。</p></blockquote><p><strong>概念</strong>：</p><ol><li>前序遍历：先输出<strong>父节点</strong>，再遍历左子树和右子树。</li><li>中序遍历：先遍历左子树，再输出<strong>父节点</strong>，再遍历右子树。</li><li>后续遍历：先遍历左子树，再遍历右子树，最后输出<strong>父节点</strong>。</li></ol><p><strong>流程</strong>：</p><ol><li>创建二叉树</li><li>遍历<ul><li><p>前序遍历</p><ul><li>先<strong>输出当前节点</strong>(初始时为root节点)</li><li>如果左子节点不为空，则向左递归执行前序遍历</li><li>如果右子节点不为空，则向右递归执行前序遍历</li></ul></li><li><p>中序遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行中序遍历</li><li><strong>输出当前节点</strong></li><li>如果当前节点的右子节点不为空，则向右递归执行中序遍历</li></ul></li><li><p>后续遍历</p><ul><li>如果当前节点的左子节点不为空，则向左递归执行后序遍历</li><li>如果当前节点的右子节点不为空，则向右递归执行后序遍历</li><li><strong>输出当前节点</strong></li></ul></li></ul></li></ol><p><strong>小技巧</strong>：</p><blockquote><p>无论何种技巧，画图永远不会错</p></blockquote><p>前序遍历就是走到哪输出到哪（<strong>从根先往左下，再回溯尝试往右</strong>）；中序遍历，某个节点没有左节点了（<strong>优先输出左叶子，没有左叶子后就从根往下，输出一次掉一片叶子</strong>），就输出；后序遍历，某个节点同时没有左右了，输出（<strong>优先左叶子，再右叶子，每次输出一次就相当于掉一片叶子</strong>）。</p><h3 id="代码实现">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrder</code>、<code>infixOrder</code>、<code>postOrder</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>,<span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>,<span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>,<span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;后续遍历：&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前序-中序-后续查找">前序/中序/后续查找</h2><h3 id="思路分析-2">思路分析</h3><p><strong>流程</strong>：</p><ol><li>存在一颗二叉树</li><li>查找<ul><li><strong>前序查找</strong><ul><li>先判断<strong>当前节点</strong>的id是否等于要查找的</li><li>如果相等，则返回当前节点</li><li>如果不等，则判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果左递归找到节点，则返回；否则，判断判断当前节点的<strong>右子节点</strong>是否为空，若不为空，则继续向右递归。</li></ul></li><li><strong>中序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，则判断<strong>当前节点</strong>是否是要找的绩点，如果是，则返回。</li><li>不是，判断<strong>右子节点</strong>是否为空，不为空，则向右递归，找到则返回，否则返回null。</li></ul></li><li><strong>后序查找</strong><ul><li>判断当前节点的<strong>左子节点</strong>是否为空，若不为空，则向左递归。</li><li>如果找到，则返回。</li><li>如果没找到，判断<strong>右子节点</strong>是否为空，不为空，则向左递归，找到则返回。</li><li>若没找到，判断<strong>当前节点</strong>是否是想要找的节点，如果是返回，不是则返回null。</li></ul></li></ul></li></ol><blockquote><p>tips1：无论怎样，凡是遇到需要访问左、右节点的操作，均需要先判断是否为空。</p><p>tips2：前序–&gt;当前，左，右； 中序–&gt;左，当前，右； 后序–&gt;左，右，当前。</p></blockquote><h3 id="代码实现-2">代码实现</h3><p><code>BinaryTreeDemo</code></p><p>核心为<code>preOrderSearch</code>、<code>infixOrderSearch</code>、<code>postOrderSearch</code>（in class <code>BinaryTree</code>和<code>HumanNode</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.preOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.infixOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历方式：&quot;</span>);</span><br><span class="line">        res = binaryTree.postOrderSearch(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到节点为：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除节点">删除节点</h2><h3 id="思路分析-3">思路分析</h3><p><strong>删除操作</strong>：</p><ol><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除子树</li></ol><blockquote><p>如果不想把整棵子树删除，</p><p>可以考虑将第二点改为：(放于实现2)</p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……(我这边暂时用一种简单实现：还是让B替代A，但是在B向左while循环，找到最左边的那个位置，然后把C插入(这样子代码实现简单，但是树的层数会变高……))</li></ul><blockquote><p>后续的二叉排序树更有另一套规则</p></blockquote></blockquote><p><strong>思路</strong>：</p><ol start="0"><li><p>若树只有一个root节点，则判断root是否要要删的，若是，置null。然后进行下面操作：(第0步写在<code>BinaryTree</code>的删除方法里[最先判断]，后续5步写在<code>HumanNode</code>的删除方法里)</p></li><li><p>因为二叉排序树是单向的，所以我们判断的是当前节点的子节点是否需要删除，而不是判断当前节点是否需要被删除（除非节点设计上带有父节点、或者查找时带有父节点信息）。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.left != null)</code>，且为要删除的节点，则删除<code>this.left = null</code>(简单粗暴法)，结束递归。</p></li><li><p>如果当前节点的左子节点不为空<code>if(this.right != null)</code>，且为要删除的节点，则删除<code>this.right = null</code>(简单粗暴法)，结束递归。</p></li><li><p>若第2、3步都没删除成功，则向左递归（当然要判断是否为空）。</p></li><li><p>若第4步没删除成功，则向右递归（当然要判断是否为空）。</p></li></ol><h3 id="代码实现-3">代码实现</h3><h4 id="实现1-直接把子树删掉">实现1(直接把子树删掉)</h4><p><code>BinaryTreeDemo</code></p><p>核心为：<code>delNodeById</code>in	class <code>BinaryTree</code>和<code>HumanNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The tree is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历ing&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.preOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.infixOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历ing&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.left.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            humanNode = <span class="built_in">this</span>.right.postOrderSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (humanNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> humanNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id == id ? <span class="built_in">this</span> : humanNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;<span class="comment">//左递归</span></span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;<span class="comment">//右递归</span></span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);<span class="comment">//输出父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现2-仅删节点-清晰">实现2(仅删节点)+清晰</h4><p><code>BinaryTree.delNodeById</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不变</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getId() == id)&#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HumanNode.delNodeById</code></p><ul><li>若该非叶子节点A只有一个子节点B，则让这个子节点B替代A</li><li>若改非叶子节点A有左节点B和右节点C，则让左子节点B替代A</li><li>但是其实实现还有有一定难度的：假如要删除的A既有左子节点B和右子节点C，且B、C都各自有两个子节点，这时候就很复杂咯……<ul><li>我这边暂时用一种简单实现：还是让B替代A，但是<strong>不断在B向左while循环</strong>，找到<strong>最左边的那个位置</strong>，然后把C插入</li><li>这样子代码实现简单，但是树的层数会变高……</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delNodeById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//左删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.left))&#123;<span class="comment">//如果是叶子节点</span></span><br><span class="line">                <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是叶子</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.left.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.left.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.left.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.left;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右删</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.id == id)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(<span class="built_in">this</span>.right))&#123;</span><br><span class="line">                <span class="built_in">this</span>.right =<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.right.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.right.right != <span class="literal">null</span>)&#123;<span class="comment">//说明要给this.right.right找合适的位置接回去</span></span><br><span class="line">                        <span class="type">HumanNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="built_in">this</span>.right;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(temp.left!= <span class="literal">null</span>)&#123;<span class="comment">//找到可以插入的位置</span></span><br><span class="line">                            temp=temp.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                        temp.left = <span class="built_in">this</span>.right.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.left;<span class="comment">//执行 原先被删除节点的左子节点进行替代的操作</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.left.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归删不掉，则右递归</span></span><br><span class="line">        <span class="keyword">if</span>(!flag &amp;&amp; <span class="built_in">this</span>.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">            flag = <span class="built_in">this</span>.right.delNodeById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码1：结果为1 4 6 8 7 3 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode4.setLeft(humanNode6);</span><br><span class="line">        humanNode4.setRight(humanNode7);</span><br><span class="line">        humanNode2.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>main</code>测试代码2：结果为1 2 4 6 7 8 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">2</span>, <span class="string">&quot;yukino2&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukino3&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">4</span>, <span class="string">&quot;yukino4&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">5</span>, <span class="string">&quot;yukino5&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yukino6&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">7</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">humanNode8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;yukino7&quot;</span>);</span><br><span class="line">        <span class="comment">//姑且手动创建</span></span><br><span class="line">        humanNode.setLeft(humanNode2);</span><br><span class="line">        humanNode.setRight(humanNode3);</span><br><span class="line">        humanNode2.setLeft(humanNode4);</span><br><span class="line">        humanNode3.setRight(humanNode5);</span><br><span class="line"></span><br><span class="line">        humanNode3.setLeft(humanNode6);</span><br><span class="line">        humanNode6.setLeft(humanNode7);</span><br><span class="line">        humanNode6.setRight(humanNode8);</span><br><span class="line">        binaryTree.setRoot(humanNode);</span><br><span class="line"></span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> binaryTree.delNodeById(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否删除成功：&quot;</span>+flag);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="顺序存储二叉树">顺序存储二叉树</h2><h3 id="思路分析-4">思路分析</h3><p><strong>说明</strong>：</p><p>从数据存储来看，数组存储方式和树存储方式可以相互转换（如下：）</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181758051.png" alt="image-20241103185227543"><p><strong>要求</strong>：</p><ol><li>二叉树中的数据用数组的形式存放，如上</li><li>在遍历数组时，仍能实现树的<strong>前序/中序/后序遍历</strong>。</li></ol><p><strong>特点</strong>：</p><ol><li>顺序存储二叉树，通常只考虑<strong>完全二叉树</strong>。</li><li>第n个元素的左子节点为$2*n+1$</li><li>第n个元素的右子节点为$2*n+2$</li><li>第n个元素的父节点为$(n-1)/2$<blockquote><p>n表示二叉树中第几个元素（从0开始），且编号顺序为——<strong>低层优先、左节点优先</strong></p></blockquote></li></ol><blockquote><p>ps：八大排序算法之<strong>堆排序</strong>，就会使用顺序存储二叉树。</p></blockquote><h3 id="代码实现-4">代码实现</h3><p><code>ArrayBinaryTreeDemo</code></p><blockquote><p>实现了数组的前序/中序/后序查找</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">ArrayBinaryTree</span> <span class="variable">arrayBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBinaryTree</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.preOrder();<span class="comment">//1 2 4 5 3 6 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.infixOrder();<span class="comment">//4 2 5 1 6 3 7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">        arrayBinaryTree.postOrder();<span class="comment">//4 5 2 6 7 3 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现顺序存储二叉树的遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，使得不写参数就是代表从根节点开始遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前数组为空，无法执行前序遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">1</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * index + <span class="number">2</span> &lt; arr.length) &#123;</span><br><span class="line">            postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点为:&quot;</span> + arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树">线索化二叉树</h2><h3 id="思路分析-5">思路分析</h3><p><strong>问题</strong>：</p><p>将${ 1,3,6,8,10,14 }$构建成一颗二叉树，如下图</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181813911.png" alt="image-20241103201821509" style="zoom:80%"><ol><li>当对上述中序遍历时：8，3，10，1，14，6</li><li>但是对于8，10，14，6这几个节点的左右指针没有充分利用</li><li>如果有个新需求——充分利用各个节点的指针，<strong>让每个节点可以指向自己的前后节点</strong></li><li>解决方案：<strong>线索化二叉树</strong></li></ol><p><strong>介绍</strong>：</p><ol><li>$n$个节点的二叉链表中含有$n+1$个空指针域（推导：$2n-(n-1)=n+1$）。利用二叉链表中的空指针域，存放指向该节点在<strong>某种遍历次序</strong>下的<strong>前驱节点</strong>和<strong>后驱节点</strong>，这种附加的指针称为“线索”。</li><li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为<strong>线索二叉树</strong>。分为<strong>前序线索二叉树</strong>、<strong>中序线索二叉树</strong>、<strong>后序线索二叉树</strong>。</li><li>一个节点的前一个节点，称<strong>前驱节点</strong>。</li><li>一个节点的后一个节点，称<strong>后继节点</strong>。</li></ol><p><strong>图解——将上述二叉树按中序遍历线索化</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181827267.png" alt="image-20241104094103323"><p>8号左指针指向较为特殊，通过代码运行逻辑可以得出。（特地标出来，是为了说明8的<code>leftType = =1</code>，为后续遍历中序线索化二叉树做铺垫）</p><p>但是有些问题：线索化后的二叉树，其<code>left</code>既可能指向左子树（如1），也可能指向其前驱节点（如10）；其<code>right</code>既可能指向后继节点（如8），也可能指向其右子树（如1、3）。</p><ul><li>[x] 进一步简化、讲清楚找<strong>红色线索</strong>的方法！！！参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56494923/article/details/130457392">blog</a>画出线索的方法，很简单，易于记忆！</li></ul><p><em><strong>画出线索的方法（重要！这是分析の方法）</strong></em>:</p><ol><li>中序线索找法<ul><li>根据特定的遍历方式，写出最终的输出。例如上述想实现中序线索化，则先用中序遍历的思路看看——<strong>8，3，10，1，14，6</strong></li><li>根据这个输出顺序，给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li><strong>由于是中序，8号左边null</strong>。其余的：<strong>8右为3</strong>；<strong>10左为3</strong>，<strong>10右为1</strong>；1左右？不需要；<strong>14左1</strong>，<strong>14右6</strong>；6不需要左，最终6右不需要。</li></ul></li><li>前序线索找法<ul><li>先用前序遍历得到输出：<strong>1，3，8，10，6，14</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点</strong>、<strong>后继节点</strong></li><li>1不需要；3不需要；<strong>8左3</strong>，<strong>8右10</strong>；<strong>10左8</strong>，<strong>10右6</strong>；<strong>6右14</strong>；<strong>14左6</strong>，<strong>14右仍为null</strong>(经测：14的<code>rightType==0</code>)；</li></ul></li><li>后序线索找法<ul><li>先用后序遍历得到输出：<strong>8，10，3，14，6，1</strong></li><li>给<strong>左或右为空的节点</strong>连接上对应的<strong>前驱节点、后继节点</strong></li><li><strong>8左为null</strong>，<strong>8右为10</strong>；<strong>10左为8</strong>，<strong>10右为3</strong>；3不需要；<strong>14左为3</strong>，<strong>14右为1</strong>；<strong>6右为1</strong>；1不需要。</li></ul></li></ol><p><strong>线索化代码流程</strong>：（步骤执行顺序的不同）</p><ol><li><p>前序线索化：</p><ul><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>如果左节点的<code>leftType == 0</code> ，再线索化左子树（左递归）</li><li>如果右节点的<code>rightType == 0</code>，再线索化右子树（右递归）</li><li><blockquote><p>进入前序线索化，在进入左、右递归前！一定要判断<code>某某Type == 0</code>！不然会进入死递归！坐等<code>StackOverflowError</code>吧！</p></blockquote></li></ul></li><li><p>中序线索化：</p><ul><li>线索化左子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li><li>线索化右子树</li></ul></li><li><p>后序线索化：</p><ul><li>线索化左子树</li><li>线索化右子树</li><li>线索化当前节点：处理<strong>前驱结点</strong>+处理<strong>后继节点</strong></li></ul></li></ol><blockquote><p>神奇吧，只有前序线索化在进入递归前需要判断……</p></blockquote><ul><li>[x] 必须要给<code>threadedNode(HumanNode node)</code>方法画一个图解！（这玩意的设置前驱节点和设置后继节点的代码部分并不是很直观、。而且，画图这一过程可以加深我的印象以及理解。）</li></ul><p><strong>图解–设置前驱结点、后继节点</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181840162.png" alt="image-20241104090654992"><h3 id="代码实现-5">代码实现</h3><h4 id="中序线索化">中序线索化</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>要点在于：在<code>HumanNode</code>中新增了<code>leftType</code>和<code>rightType</code>两个字段及对应getter、setter方法。</p><p>在<code>ThreadedBinaryTree</code>中使用了<code>threadedNode</code>方法用于(<strong>中序</strong>)线索化二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>,<span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>,<span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>,<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>,<span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>,<span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>,<span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d&quot;</span>,node5.getLeft().getId(),node5.getRight().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;8号节点的右指针类型：&quot;</span>+node4.getRightType());</span><br><span class="line"><span class="comment">//        System.out.println(node4.getLeft().getId());//注意，8号节点的left为null，因为此时prev == null。（调试发现）</span></span><br><span class="line">        <span class="comment">//虽然8号节点的leftType已经被设置为1，但是left指向为null。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="前序线索化">前序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索化">后序线索化</h4><p><code>threadedNode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序线索化二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">    threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">    threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">    <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.setLeft(prev);</span><br><span class="line">        node.setLeftType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">        prev.setRight(node);</span><br><span class="line">        prev.setRightType(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;理应新增的线索测试：&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;8号右边为：%d号节点\n&quot;</span>, node4.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号左边为：%d号节点\n&quot;</span>, node5.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;10号右边为：%d号节点\n&quot;</span>, node5.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号左边为：%d号节点\n&quot;</span>, node6.getLeft().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;14号右边为：%d号节点\n&quot;</span>, node6.getRight().getId());</span><br><span class="line">        System.out.printf(<span class="string">&quot;6号右边为：%d号节点\n&quot;</span>, node3.getRight().getId());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 向左递归线索化</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向右递归线索化</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//3.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="遍历线索化二叉树">遍历线索化二叉树</h2><h3 id="思路分析-6">思路分析</h3><p>要求：对已经(中序)线索化的二叉树采取相同策略(中序)的遍历方式。</p><p>问题：因为线索化后，各个节点的指向以发生变化，因此原先的遍历方式不能再使用，需要用新的遍历方式遍历线索化二叉树。</p><p>优点：由于各个节点可以通过线型方式遍历，所以无需使用递归，提高了遍历的效率。</p><h3 id="代码实现-6">代码实现</h3><h4 id="遍历中序线索化二叉树">遍历中序线索化二叉树</h4><p><code>ThreadedBinaryTreeDemo</code></p><p>新增<code>threadedList</code><strong>遍历中序线索化二叉树</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">        <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">        <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">            node = node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.getRight();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历中序线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.threadedList();<span class="comment">// 8 3 10 1 14 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环地找到leftType == 1的节点</span></span><br><span class="line">            <span class="comment">//对应中序遍历的 “左递归优先”</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前节点的右指针指向后继节点，则一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树中进行线索化的方法（此为中序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="comment">//如果node == null，不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化左子树</span></span><br><span class="line">        threadedNode(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);<span class="comment">//让当前节点指向前驱节点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);<span class="comment">//(修改指针类型)说明此时的左指针是指向前驱节点，非左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;<span class="comment">//此时应该是node递归到了&quot;下一个&quot;，看看上一个prev的right是不是为空</span></span><br><span class="line">            prev.setRight(node);        <span class="comment">//这时才设置是设置后继节点的时候(画图理解)</span></span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = node;<span class="comment">//每处理一个节点后，更新！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 线索化右子树</span></span><br><span class="line">        threadedNode(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历前序线索化二叉树">遍历前序线索化二叉树</h4><p><code>threadedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">            System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">            node = node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        node = node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>完整版</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">1</span>, <span class="string">&quot;yukino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">3</span>, <span class="string">&quot;yukinoshita&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">6</span>, <span class="string">&quot;yu&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">8</span>, <span class="string">&quot;kino&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">10</span>, <span class="string">&quot;yuKiNO&quot;</span>);</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanNode</span>(<span class="number">14</span>, <span class="string">&quot;shita&quot;</span>);</span><br><span class="line"></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否线索化成功：</span></span><br><span class="line"><span class="comment">//        System.out.printf(&quot;10号节点的前驱节点id为：%d \t 后继节点id为：%d \n&quot;, node5.getLeft().getId(), node5.getRight().getId());</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;14号节点的左指针类型：&quot; + node6.getLeftType());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试遍历前序线索化二叉树是否成功：</span></span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    HumanNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HumanNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//在递归进行线索化时，prev总是为前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HumanNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HumanNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;<span class="comment">//左指针不是线索</span></span><br><span class="line">                System.out.println(node);<span class="comment">//则边访问，边移动</span></span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载，自动从root节点开始线索化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序线索化二叉树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNode</span><span class="params">(HumanNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 线索化当前节点</span></span><br><span class="line">        <span class="comment">//1.1. 设置前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.setLeft(prev);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2. 设置后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; prev.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.setRight(node);</span><br><span class="line">            prev.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 向左递归线索化，但是必须是有效节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 向右递归线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNode(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HumanNode left;</span><br><span class="line">    <span class="keyword">private</span> HumanNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        规定leftType == 0，指向的是左子树；为1，指向前驱节点</span></span><br><span class="line"><span class="comment">        规定rightType == 0，指向的是右子树；为1，指向后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HumanNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HumanNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HumanNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HumanNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HumanNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历后序线索化二叉树">遍历后序线索化二叉树</h4><p><code>threadedList</code></p><p>这个代码很复杂，已经需要使用<strong>三叉链表</strong>了。</p><blockquote><p>引用自<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56494923/article/details/130457392">博客</a>，暂时不深入思考、以及实现。</p><ul><li>[ ] 有空再说。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181854902.png" alt="image-20241104193040292" style="zoom:80%"></blockquote><h1>赫夫曼树</h1><blockquote><p>Huffman，赫夫曼，哈夫曼，霍夫曼。</p></blockquote><h2 id="基本概念介绍">基本概念介绍</h2><ol><li><strong>路径和路径长度</strong>：从一个节点往下可以到达的孩子或孙子节点的通路，成为<strong>路径</strong>；通路中分支的数目称为<strong>路径长度</strong>。若根节点为第L层，则第L层的节点的路径长度为$L-1$</li><li><strong>结点的权、带权路径长度</strong>：节点中含有一个有某种含义的数值，称为<strong>节点的权</strong>；路径长度*节点的权 = <strong>带权路径长度</strong></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181905706.png" alt="image-20241105200517736" style="zoom:80%"><ol start="3"><li><strong>树的带权路径长度</strong>：<strong>所有叶子节点的带权路径长度之和</strong>，称为<strong>树的带权路径长度</strong>，记为<strong>WPL（weighted path length）</strong>，赫夫曼树的特点就是<em><strong>带权路径长度最短</strong></em>，也就是要让权值越大的节点离根节点越近。</li><li><em><strong>WPL最小的就是赫夫曼树</strong></em>，<strong>图解</strong>(e.g.中间的是赫夫曼树)：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181916896.png" alt="image-20241105201026809" style="zoom:80%"><h2 id="创建赫夫曼树">创建赫夫曼树</h2><h3 id="思路分析-7">思路分析</h3><p>构成赫夫曼树的<strong>步骤</strong>：</p><ol><li>将数据从小到大排序(首次，将每个数据都看作根节点) / 或根据每棵树的根节点进行排序(非首次–or通用讲法)。</li><li>取出根节点权值最小的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li><li>再将这颗新的二叉树，以根节点的权值大小再次排序（也就是回到第一步）。不断重复 ，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ol><p><strong>简单理解</strong>：一，排序；二，取出最小两颗，组成新树，根节点为；三，回到第一步。（也就是图解中，三张图片为一轮）</p><p><strong>图解</strong>：</p><p>以${ 15,8,6,1,20,10 }$为例</p><ul><li>执行第一步排序，得到${ 1,6,8,10,15,20 }$，相当于有6棵树，每棵树都是一个单独的节点：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181928786.png" alt="image-20241105204913658" style="zoom:80%"><ul><li>第二步，取出最小的两颗二叉树；第三步，新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181940799.png" alt="image-20241105205229638" style="zoom:80%"><ul><li>第四步（也可以说是回到），再以新的这些树的<strong>根节点</strong>进行从小到大排序：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501181953985.png" alt="image-20241105205419103" style="zoom:80%"><ul><li>开始重复：再次执行第一步（上面已经排有序了）。</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182006239.png" alt="image-20241105210527613" style="zoom:80%"><ul><li>再排序：(注意！实际代码运行此处有差异！)</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182018290.png" alt="image-20241105210700873" style="zoom:80%"><ul><li>再取、再排：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182030635.png" alt="image-20241105211006627" style="zoom:80%"><ul><li>再取、再排：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182041472.png" alt="image-20241105211150432" style="zoom:80%"><ul><li>最后一步——赫夫曼树的降临：</li></ul><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182052046.png" alt="image-20241105211319376" style="zoom:80%"><blockquote><p>（上述仅能展示思路！！但是最终的二叉树视代码实现而定！！）</p><blockquote><p>我的实现代码中，最终得到的huffmanTree就不是上面这个形状的，原因在于有一步的排序过程——出现了两个根节点为15的树。</p><p>我的代码中，采取的策略是——新生成的树都是在ArrayList末尾进行add，然后再排序，所以新生成、根节点为15的树应该在旧的那个之后……下面给出修改后过程（中间有所不同）</p><blockquote><p>为什么前序遍历后怎么和预期不一样……问题就出在这里……</p></blockquote></blockquote></blockquote><p>小结：赫夫曼树根据排序方式的不同，最终形成的赫夫曼树的结构也不同。但是WPL一致、最小。这里的&quot;排序方法&quot;语义较小，是指遇到相同元素的情况下，该如何排序。</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182102706.png" alt="image-20241106113028048" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182112861.png" alt="image-20241106113522437" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182126042.png" alt="image-20241106113642780" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182137600.png" alt="image-20241106113746002" style="zoom:80%"><p>所以代码的前序遍历应该为：</p><p>$60 \quad 25 \quad 10 \quad 15 \quad 35 \quad 15 \quad 7 \quad 1 \quad 6 \quad 8 \quad 20$</p><h3 id="代码实现-7">代码实现</h3><p><code>HuffmanTree</code></p><p>主要代码：<code>createHuffmanTree</code>创建赫夫曼树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;13, 7, 8, 3, 29, 6,1&#125;;</span></span><br><span class="line"><span class="comment">//        int [] arr = &#123;&#125;;</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;huffman tree is empty&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val:arr)&#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出最小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出次小</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//构建新子树：</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.weight+ rightNode.weight,leftNode,rightNode);</span><br><span class="line">            <span class="comment">//删除已处理的，加入新的树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回这棵树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> weight) &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> weight, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">//表示从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历：(用于测试)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="赫夫曼编码">赫夫曼编码</h2><h3 id="思路分析-8">思路分析</h3><blockquote><p>直接采用atguigu的介绍：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=115">视频链接</a>。</p></blockquote><p><strong>基本介绍</strong></p><p>赫夫曼编码也翻译为<strong>哈夫曼编码(Huffman Coding)</strong>，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p><p>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</p><p>赫夫曼编码广泛地用于<strong>数据文件压缩</strong>。其压缩率通常在20%～90%之间</p><p>赫夫曼码是**可变字长编码(VLC)**的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</p><p><strong>原理</strong>：</p><ol><li><p>通信领域中信息的处理方式1-定长编码</p><ul><li><code>i like like like java do you like a java</code> // 共40个字符(包括空格)</li><li><code>105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97</code>//对应Ascii码</li><li><code>01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001</code>//对应的二进制</li><li>按照二进制来传递信息，总的长度是 359 (包括空格)</li><li><a target="_blank" rel="noopener" href="https://www.mokuge.com/tool/asciito16/">在线转码工具</a></li></ul></li><li><p>通信领域中信息的处理方式2-变长编码</p><ul><li><code>i like like like java do you like a java</code> // 共40个字符(包括空格)</li><li><code>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 空格:9</code>// 各个字符对应的个数</li><li><code>0=空格 , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</code> 说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.</li><li>按照上面给各个字符规定的编码，则我们在传输 “i like like like java do you like a java” 数据时，编码就是10010110100…</li></ul></li></ol><ul><li><blockquote><p>但是这种编码方式不是<strong>前缀编码</strong>[^9]，会出现二义性。</p></blockquote></li></ul><ol start="3"><li><p>通信领域中信息的处理方式3-赫夫曼编码</p><ul><li><p><code>i like like like java do you like a java</code> // 共40个字符(包括空格)</p></li><li><p><code>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</code> // 各个字符对应的个数</p></li><li><p>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值。</p></li></ul></li></ol><p><strong>赫夫曼编码详解</strong>：</p><p>传输的字符串为：<code>i like like like java do you like a java</code></p><ol><li>统计各个字符对应的个数<code>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</code></li><li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值（字符也要传入）</li></ol><blockquote><p>也就是传入$arr=[1,1,1,2,2,2,4,4,4,5,5,9]$去<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>：</p><p>构成赫夫曼树的步骤：</p><ol><li><p>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p></li><li><p>取出根节点权值最小的两颗二叉树</p></li><li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</p></li><li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182149929.png" alt="image-20241106133401235" style="zoom:80%"></blockquote><ol start="3"><li>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下：<code>o:000	u: 10010	d: 100110 y: 100111 i: 101a : 110 k: 1110 e: 1111 j: 0000 v: 0001l: 001 : 01</code></li><li>按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot; 字符串对应的编码为 (注意这里我们使用的无损压缩)<code>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</code>通过赫夫曼编码处理 长度为 133</li><li>长度为:133 说明:原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%。此编码满足前缀编码,，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性。赫夫曼编码是无损处理方案。</li></ol><h3 id="数据压缩">数据压缩</h3><p><strong>思路</strong>：</p><ol><li>Node { data (存放数据)， weight (权值)， left 和 right }</li><li>得到 “i like like like java do you like a java” 对应的 byte[] 数组</li><li>编写一个方法，将准备构建赫夫曼树的Node 节点放到 List , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]…], 体现 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</li><li>可以通过List 创建对应的赫夫曼树</li></ol><p><strong>代码解释</strong>：</p><p>这个代码过程较多，但是每一部分并不难。<br>简单归纳下：总体的目标是把原始数据对应的<code>byte[]</code> 压缩为更小的<code>byte[]</code></p><ol><li><p>获取原始数据的byte[]</p></li><li><p>将这个根据这个byte[]构建赫夫曼树，规则详见<a href="###%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91">创建赫夫曼树</a>，这里简单回顾：</p><ul><li>排序-》取出两个最小的节点，构成新节点-》删除两个最小节点，将新的节点加入到数组-》只要数组长度大于1，就循环整个操作-》最后通过nodesArray.get(0)就获取到了赫夫曼树的根节点。</li></ul><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182204232.png" alt="image-20241106163538269" style="zoom:67%"></blockquote></li><li><p>创建<strong>赫夫曼树</strong>后，就要利用赫夫曼树，得到对应的<strong>赫夫曼编码</strong>，规则为——为每一个叶子节点的值data编一个&quot;码&quot;，这个码就是从根节点到叶子节点的路径，每向左拼接一个&quot;0&quot;，每向右拼接一个&quot;1&quot;。最终得到赫夫曼编码，存放在Map&lt;key,value&gt;中，key就是数据，比如97('a’的ASCII)，value就是对应的码，比如01</p></li></ol><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182216330.png" alt="image-20241106163609031"></blockquote><ol start="4"><li>根据这个赫夫曼编码，可以将原始数据压缩，压缩过程又细分两步：<ol><li>由于光是通过赫夫曼编码处理后，得到的只是&quot;0100110101010…&quot;这样的<strong>字符串</strong>，甚至比原先的字符串还长，所以要将这个字符串转换为8位一个的byte</li><li>第二步就是转换，不足8位就截断。<code>huffmanCodeBytes[k] = (byte) Integer.parseInt(strByte, 2);</code>其中，strByte是每次取了8位（不足就截断）。</li></ol></li><li>最后得到的<code>huffmanCodeBytes</code>就是最终结果（类型为<code>byte[]</code>，且长度比<code>str.getBytes()</code>要短，就做到了压缩）</li></ol><blockquote><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182226996.png" alt="image-20241106164313508" style="zoom:80%"></blockquote><p>可能需要补充的知识？</p><p>原码、反码、补码的转换。（也就是在压缩过程，为什么从&quot;10101000&quot;变成huffmanCodeBytes中的-88）</p><p>10101000(补码)-&gt;10100111(反码)-&gt;11011000(原码)</p><p>补码-1 = 反码；符号位不变，反码取反=原码。原码对应值计算为-88。</p><h4 id="实现1">实现1</h4><p><code>HuffmanCode</code></p><blockquote><p>若对此代码不懂，再看一遍：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=117">p117</a>至<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1E4411H73v?spm_id_from=333.788.player.switch&amp;vd_source=31d39c465d959f9ebfb4e20fc1ca0a9d&amp;p=120">p120</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();</span><br><span class="line">        System.out.println(<span class="string">&quot;还未压缩前的长度：&quot;</span> + contentBytes.length);</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;nodes：&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建赫夫曼树为：&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        huffmanTreeRoot.preOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">//        getCodes(huffmanTreeRoot);</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); <span class="comment">//(其实不新生成也行，如上)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;生成的赫夫曼编码为：&quot;</span> + HuffmanCode.huffmanCodes);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(<span class="string">&quot;huffmanCodeBytes：&quot;</span>+Arrays.toString(huffmanCodeBytes));</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩率为:&quot;</span>+(contentBytes.length-huffmanCodeBytes.length * <span class="number">1.0</span>) / contentBytes.length * <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="封装后实现2">封装后实现2</h4><p><code>HuffmanCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输入的原始数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span>+Arrays.toString(huffmanBytes));</span><br><span class="line"><span class="comment">//        对此部分进行封装：</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;还未压缩前的长度：&quot; + contentBytes.length);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //通过getNodes方法得到byte[]数组对应的节点（）</span></span><br><span class="line"><span class="comment">//        List&lt;Node&gt; nodes = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;nodes：&quot; + nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;创建赫夫曼树为：&quot;);</span></span><br><span class="line"><span class="comment">//        Node huffmanTreeRoot = createHuffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        huffmanTreeRoot.preOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //测试是否生成了对应的huffman编码</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot,&quot;&quot;,stringBuilder);</span></span><br><span class="line"><span class="comment">////        getCodes(huffmanTreeRoot);</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); //(其实不新生成也行，如上)</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生成的赫夫曼编码为：&quot; + HuffmanCode.huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeBytes：&quot;+Arrays.toString(huffmanCodeBytes));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩率为:&quot;+(contentBytes.length-huffmanCodeBytes.length * 1.0) / contentBytes.length * 1.0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes)&#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes,huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据解压">数据解压</h3><p><strong>思路</strong>：</p><ol><li>将赫夫曼压缩后的字节数组	转换为 二进制字符串。使用<code>byteToBitString</code>方法</li><li>再将这个二进制字符串 对照 赫夫曼编码 转换为原始字符串。使用<code>decode</code>方法</li></ol><p><code>HuffmanCode</code></p><blockquote><p>注意：此代码有bug（没修）——如果最后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = str.getBytes();<span class="comment">//得到其byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后：&quot;</span> + Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(sourceBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件的压缩和解压">文件的压缩和解压</h3><p><code>zipFile</code>方法和<code>unZipFile</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.huffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//        String srcFile = &quot;C:\\Users\\26423\\Desktop\\ceshi22.bmp&quot;;</span></span><br><span class="line"><span class="comment">//        String dstFile =&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;;</span></span><br><span class="line"><span class="comment">//        zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩文件成功&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi22.zip&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\26423\\Desktop\\ceshi2333.bmp&quot;</span>;</span><br><span class="line">        unZipFile(zipFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压文件成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对文件的解压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义文件输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和 is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组 huffmanCodes</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[])ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//写数据到dstFile文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对文件进行压缩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 希望压缩的文件的完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 压缩后的文件放到哪个目录下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile,String dstFile)</span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流,存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//这里以对象流的形式写入 赫夫曼编码（是为了以后恢复源文件时使用）</span></span><br><span class="line">            <span class="comment">//注意一定要把赫夫曼编码写入压缩文件（不然恢复不了）</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数据解码的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1. 先得到huffmanBytes对应的二进制字符串（010100010）</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytes[i];</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：赫夫曼字节数组对应的二进制字符串&quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//把二进制字符串按照赫夫曼表进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼表进行调换，因为要反向查询。</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：&quot;+map);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个List，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i不动，让count移动</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for结束后，list中就存放了所有的字符</span></span><br><span class="line">        <span class="comment">//还要把list中的数据放入byte[]并返回</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 讲一个byte转成一个二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 高位需要补位（true），不需要（false）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该byte对应的二进制的字符串（补码形式返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;<span class="comment">//将b转成int</span></span><br><span class="line">        <span class="comment">//如果是正数，还需要补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;<span class="comment">//按位或256</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag || temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法进行封装，使得调用方便</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过赫夫曼编码处理后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据nodes创建huffmanTree</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//根据huffmanTree获得赫夫曼编码</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据赫夫曼编码对原始数据对应的字节码数组进行压缩</span></span><br><span class="line"><span class="comment">//        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        return huffmanCodeBytes;</span></span><br><span class="line">        <span class="keyword">return</span> zip(bytes, huffmanCodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes        原始字符串对应的byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes (根据字符串)生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼编码压缩处理后的byte数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试：stringBuilder: &quot;+stringBuilder.toString());</span></span><br><span class="line">        <span class="comment">//将&quot;010001000101010101010...&quot;转成byte数组</span></span><br><span class="line">        <span class="comment">//或者：int len =(stringBuilder.length() + 7) / 8;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 存储压缩后的by数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>, k++) &#123;<span class="comment">//因为是每8位对应一个byte</span></span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte，放入到huffmanCodeBytes</span></span><br><span class="line">            huffmanCodeBytes[k] = (<span class="type">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用getCodes方便，重载一下：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表放在Map&lt;Byte,String&gt;  键:值 = ASCII:码  e.g. 97:001</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表时，需要去拼接路径，故用一个StringBuilder存储某个叶子节点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到传入的node节点所有的叶子节点的赫夫曼编码，存放到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径(左边为0，右边为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code加入到builder</span></span><br><span class="line">        builder.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;<span class="comment">//node为空不处理</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123;<span class="comment">//说明node为非叶子节点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, builder);<span class="comment">//向左</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, builder);<span class="comment">//向右</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//是叶子节点</span></span><br><span class="line">                huffmanCodes.put(node.data, builder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要对每一个字符出现的次数做统计，统计出来的数字即为weight</span></span><br><span class="line"><span class="comment">     * 换言之，weight反映了这个字符在原数据（str）中出现的频率</span></span><br><span class="line"><span class="comment">     * 频率越高，自然，后续构建赫夫曼树时，就要将它放到距离根节点较近的位置上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个List，形式：[Node[data:97,weight=5], Node[data:32,weight:9],...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历bytes，统计每一个byte出现的次数-&gt;Map</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> counts.get(b);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;<span class="comment">//Map还没有这个字符数据</span></span><br><span class="line">                counts.put(b, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node对象，并加入到nodes集合</span></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            newNode.left = leftNode;</span><br><span class="line">            newNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            nodes.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据，如&#x27;a&#x27;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件压缩注意事项">文件压缩注意事项</h3><ol><li>如果文件本身就是经过压缩的，那么使用赫夫曼编码压缩后大小不会有明显变化，比如视频、ppt、png。</li><li>赫夫曼编码是按字节来处理的，因此可以处理所有文件（二进制文件、文本文件）(.xml)</li><li>如果一个文件中的内容重复数据不多，压缩效果也不会很明显。</li></ol><h1>二叉搜索树</h1><h2 id="基本介绍">基本介绍</h2><p><strong>二叉搜索树</strong>，<strong>BST(Binary Search Tree)</strong>，对于二叉搜索树的任何一个<strong>非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小</strong>，<strong>右子节点的值比当前节点的值大</strong>。如果有相同的值，可以放在左子节点或右子节点。</p><h2 id="二叉搜索树的创建和遍历">二叉搜索树的创建和遍历</h2><p>新加入节点时：</p><ol><li>若新加入节点为空，直接返回。</li><li>比较插入值和当前节点值大小，若小于当前节点值，判断左节点是否为空，若为空，直接插入到左节点，否则向左递归地插入</li><li>否则（大于等于），判断右节点是否为空，若为空则直接插入到右节点，否则向右递归地插入</li></ol><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试二叉搜索树的中序遍历：&quot;</span>);</span><br><span class="line">        bst.inOrder();<span class="comment">//发现刚好是升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉搜索树节点的删除">二叉搜索树节点的删除</h2><h3 id="思路分析-9">思路分析</h3><blockquote><p>由于删除时情况较多（但是不难），所以还是需要理一下所有可能的情况</p></blockquote><p>分以下三种情况：</p><ol><li>删除叶子节点</li><li>删除只有1颗子树的节点</li><li>删除有2颗子树的节点</li></ol><p><strong>具体思路</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182238374.png" alt="image-20241108193248201" style="zoom:80%"><ol><li><p>若删除叶子节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，再删除。</li></ul></li><li><p>删除只有一颗子树的节点</p><ul><li>先要找到目标节点<code>targetNode</code></li><li>在找的同时，要用<code>parentNode</code>标记其父节点</li><li>确定<code>targetNode</code>是<code>parentNode</code>的左子节点还是右子节点，以及确定<code>targetNode</code>是有左子树还是右子树</li><li>因此有四种情况：<ul><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有左子树——<code>parent.left = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的左子节点，<code>targetNode</code>有右子树——<code>parent.left = targetNode.right</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有左子树——<code>parent.right = targetNode.left</code></li><li><code>targetNode</code>是<code>parentNode</code>的右子节点，<code>targetNode</code>有右子树——<code>parent.right = targetNode.right</code></li></ul></li><li>删除5为例：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182250598.png" alt="image-20241108193304227" style="zoom:80%"></li></ul></li><li><p>删除有两颗子树的节点</p><ul><li><p>先要找到目标节点<code>targetNode</code></p></li><li><p>在找的同时，要用<code>parentNode</code>标记其父节点</p></li><li><p>从<code>targetNode</code>的右子树里找到最小的节点 （或从<code>targetNode</code>的左子树里找最大的节点（同样的流程））</p></li><li><p>如图找到：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182303500.png" alt="image-20241108193645936" style="zoom:80%"></p></li><li><p>用<code>temp</code>临时存储最小节点<code>minNode</code>的值，删除<code>minNode</code>，这一步删除有点特殊：<code>targetNode.left = minNode.right</code>。这是一句通用的写法，可以适应不同情况：因为既然是在<code>targetNode</code>的右子树里找的<code>minNode</code>，所以其左边必定无节点，且无论其右节点是否为空，都可以这样子写。</p></li><li><p>如图删除：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182315889.png" alt="image-20241108194225832" style="zoom:80%"></p></li><li><p>删除<code>targetNode</code>，即<code>targetNode.value = temp</code></p></li><li><p>如图：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182333482.png" alt="image-20241108194625603" style="zoom:80%"></p></li></ul></li><li><p>特别注意！上述找到的<code>parentNode</code>可能为null，说明要删除的节点是root节点。</p></li></ol><blockquote><p>思考：上述思路可能有可以改进的地方——也就是&quot;<strong>找到要删除的节点的父节点</strong>&quot;，为了这个父节点，代码实现中还特地写了一个独立的方法去查找。好处是清晰，坏处是可能效率略降低？（原路多找一次）。</p><p>可能的改进思路：可以把<code>search</code>待删除节点的方法作一定修改：可以返回一个集合，里面装两个节点（被删除节点和父节点）；可以直接返回父节点，后续删除时只是需要多判断一下其左右节点哪个是要被删除的，如何保证被删除的节点的稳定——通过<code>if(this.left.value == val)</code>来判断？那么左右节点值都一样呢？（以及万一是根节点要被删除，那么如何返回这个父节点的问题）</p><p>代码暂时不作优化。</p></blockquote><h3 id="代码实现-8">代码实现</h3><p><code>BinarySearchTreeDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yukinoshita.dataStructure.binarySearchTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTreeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bst.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试delNode方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除前：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">        bst.delNode(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        bst.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">        <span class="keyword">if</span>(targetNode == <span class="literal">null</span>) <span class="keyword">return</span>;<span class="comment">//找不到待删除节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">        <span class="keyword">if</span>(parentNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明要删除的节点就是root节点（也要分三种……）</span></span><br><span class="line">            <span class="comment">//如果左右为空，直接删</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左右都有子树，选取右子树中最小的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//temp 为 找到的root的右子树的最小节点</span></span><br><span class="line">                <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> root;</span><br><span class="line">                <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentOfTemp = temp;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                parentOfTemp.left = temp.right;</span><br><span class="line">                root.value = temp.value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有左或右，直接更新root</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>) root = root.left;</span><br><span class="line">                <span class="keyword">else</span> root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的节点不是root（保证了操作parentNode时不出错）</span></span><br><span class="line">        <span class="comment">//1.待删除节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(parentNode.left!=<span class="literal">null</span> &amp;&amp; parentNode.left.value == value) parentNode.left =<span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> parentNode.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.待删除节点有左子树和右子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//temp 为 找到的targetNode的右子树的最小节点</span></span><br><span class="line">            <span class="comment">//还要记录其的parent，已正确执行删除这个最小节点的操作</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> targetNode.right;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parentOfTemp</span> <span class="operator">=</span> targetNode;</span><br><span class="line">            <span class="keyword">while</span>(temp.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                parentOfTemp = temp;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            parentOfTemp.left = temp.right;</span><br><span class="line">            targetNode.value = temp.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.待删除节点只有左子树或右子树</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//目标节点在parentNode的左边</span></span><br><span class="line">            <span class="keyword">if</span>(parentNode.left != <span class="literal">null</span> &amp;&amp; parentNode.left.value == value)&#123;</span><br><span class="line">                <span class="comment">//目标节点有左子树</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.left = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.left = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//目标节点在parentNode的右边</span></span><br><span class="line">                <span class="keyword">if</span>(targetNode.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    parentNode.right = targetNode.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parentNode.right = targetNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//我总是忘记--这种判断自身是否为空的操作……但其实很必要加，不然就会报空指针异常</span></span><br><span class="line">        <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        root.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找待删除节点的父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) || (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不好的写法，是暴力查找！</span></span><br><span class="line"><span class="comment">//            if(this.left != null) return this.left.searchParent(value);</span></span><br><span class="line"><span class="comment">//            if(this.right != null) return this.right.searchParent(value);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//效率高的写法：</span></span><br><span class="line">            <span class="comment">//如果要查找的值小于当前的值，且当前节点的左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找为value的节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//说明找不到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);<span class="comment">//递归地继续找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归地添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.inOrder();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.inOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>后记：代码中有一部分可以拿出来作为一个方法<code>int delRightTreeMin(Node node)&#123;&#125;</code></p><p>说明：<code>node</code>为传入的结点，方法作用是删除以node为根节点这棵二叉排序树的最小根节点，最后返回最小节点<code>minNode</code>的值。</p><p>ps：该方法可用于替换代码中的两部分——一是待删除结点有左右子树且待删除结点就是root，二是待删除结点有左右子树且待删除结点不是root。</p></blockquote><h1>平衡二叉树</h1><p><strong>问题</strong>：</p><p>如下图可见<strong>二叉搜索树</strong>可能存在的问题:</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182346268.png" alt="image-20241109195852364" style="zoom:80%"><p>有以下问题：1.左子树都为空，更像单链表；2.插入速度没有影响，但查询速度大幅减低(每次向下一层前还需要和左比较，比链表还慢)，不能发挥BST（BinarySearchTree）的查询优势。</p><p>解决方案：<strong>平衡二叉树（AVL）</strong></p><p><strong>基本介绍</strong></p><ol><li><strong>平衡二叉树</strong>也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）<strong>又被称</strong>AVL树</strong>，可以保证<strong>查询效率较高</strong>。</li><li>特点：<ul><li>是一颗<strong>空树</strong>或它的<strong>左右子树的高度差的绝对值不超过1</strong>。</li><li><strong>左右子树都是一棵平衡二叉树</strong>。</li></ul></li><li>常用实现算法有：红黑树、AVL、替罪羊树、Treap、伸展树等</li></ol><p>为了使得一棵普通的二叉搜索树变成平衡二叉树，也就是让左右子树的高度差降低，我们引出一些方法——e.g.<strong>左旋转</strong>、<strong>右旋转</strong>、<strong>双旋转</strong></p><h2 id="左旋转">左旋转</h2><p>适用于右子树高度大于左子树的情况</p><p><strong>左旋转步骤</strong>：</p><ol><li>保存当前节点的值，已该值创建<code>newNode</code></li><li>将<code>newNode</code>的left设置为当前节点的左子树</li><li>将<code>newNode</code>的right设置为当前节点的右子树的左子树</li><li>将当前节点的值更新为右子树的值</li><li>将当前节点的right设置为右子树的右子树</li><li>将当前节点的left设置为<code>newNode</code></li></ol><p><strong>左旋转图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182400936.png" alt="image-20241110094040328" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182412965.png" alt="image-20241110094207819" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182432522.png" alt="image-20241110094235038" style="zoom:80%"><p>至此，这棵树就符合平衡二叉树的定义。</p><p>可以看出：左旋转用于当一棵树的左子树的高度小于右子树的高度时。（记忆，想象一个旋钮，把它往左边旋转，那么右边就&quot;旋上去&quot;，右边高度就降低了）</p><h3 id="代码实现-9">代码实现</h3><ol><li>新增三个方法<code>height</code>、<code>leftHeight</code>、<code>rightHeight</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回右子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回左子树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回以当前结点为根节点的树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>左旋转方法<code>leftRotate</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建新节点，记录当前节点的值</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="comment">//2. 将newNode的left设置为当前节点的左子树</span></span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left;</span><br><span class="line">    <span class="comment">//3. 将newNode的right设置为当前节点的右子树的左子树</span></span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right.left;<span class="comment">//****这里不用判断有没有右子树，因为如果this.right为空的话，也不可能会导致右子树比左子树高，更不会执行左旋转*****</span></span><br><span class="line">    <span class="comment">//4. 将当前节点的值更新为右子树的值</span></span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.right.value;</span><br><span class="line">    <span class="comment">//5. 将当前节点的right设置为右子树的右子树</span></span><br><span class="line">    <span class="built_in">this</span>.right = <span class="built_in">this</span>.right.right;</span><br><span class="line">    <span class="comment">//6. 将当前节点的left设置为newNode</span></span><br><span class="line">    <span class="built_in">this</span>.left = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋转">右旋转</h2><p>适用于左子树高度大于右子树的情况</p><p><strong>右旋转步骤</strong>：</p><ol><li>保存当前结点的值，以该值创建<code>newNode</code></li><li>将<code>newNode</code>的right设置为当前节点的右子树</li><li>将<code>newNode</code>的left设置为当前结点的左子树的右子树</li><li>将当前结点的值更新为左子树的值</li><li>将当前结点的left设置为左子树的左子树</li><li>将当前结点的right设置为<code>newNode</code></li></ol><p><strong>右旋转图解</strong>：</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182504801.png" alt="image-20241110133603478" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182514707.png" alt="image-20241110133631995" style="zoom:80%"> <img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182524611.png" alt="image-20241110133707683" style="zoom:80%"><h3 id="代码实现-10">代码实现</h3><p><code>rightRotate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    newNode.right = <span class="built_in">this</span>.right;</span><br><span class="line">    newNode.left = <span class="built_in">this</span>.left.right;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.left.value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="built_in">this</span>.left.left;</span><br><span class="line">    <span class="built_in">this</span>.right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加节点时使用左旋转和右旋转方法：</p><p><code>Node.add</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归地添加节点的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span>(rightHeight()-leftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">if</span>(leftHeight()-rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双旋转">双旋转</h2><p>有情况下，仅凭一次左旋转或右旋转是无法使的二叉搜索树转换为平衡二叉树的。</p><p>e.g.<code>int[] arr=&#123;10,11,7,6,8,9&#125;;</code>此时发现，经过一次右旋转后，反而使得右子树的高度比左子树的高度大1。</p><p><strong>图示</strong>：<img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182537421.png" alt="image-20241110141336862" style="zoom:80%"></p><p><strong>解决方法——双旋转思路+图解</strong>：</p><ol><li><p>当<strong>符合右旋转</strong>的条件时（<code>this.leftHeight() - this.rightHeight() &gt; 1</code>）<br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182549008.png" alt="image-20241110141635728" style="zoom:80%"></p></li><li><p>且如果它的 <strong>左子树的右子树的高度 大于 左子树的左子树的高度</strong>，即<code>this.left.rightHeight() &gt; this.left.leftHeight()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182559575.png" alt="image-20241110142528639" style="zoom:80%"></p></li><li><p>先需<strong>对当前节点的左子树进行左旋转</strong>，即<code>this.left.leftRotate()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182610683.png" alt="image-20241110142933085" style="zoom:80%"></p></li><li><p>再对当前节点进行右旋转，即<code>this.rightRotate()</code><br><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182622396.png" alt="image-20241110143304696" style="zoom:80%"></p></li></ol><blockquote><p>如果是“<strong>当符合左旋转</strong>”的条件时，且“它的 <strong>右子树的左子树的高度 大于 右子树的右子树的高度</strong>”</p></blockquote><h3 id="代码实现-11">代码实现</h3><p><code>Node.add</code>方法的修改，使其能够进行双旋转（可以对比<a href="####%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">右旋转代码实现</a>里面的add方法，有什么区别）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; node.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) <span class="built_in">this</span>.right.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.right = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) <span class="built_in">this</span>.left.add(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">this</span>.left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当添加完一个节点后：右子树高度 - 左子树高度 &gt; 1，左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的右子树的左子树的高度 大于 它的右子树的右子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.leftHeight() &gt; <span class="built_in">this</span>.right.rightHeight()) &#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的右结点 进行右旋转</span></span><br><span class="line">            <span class="built_in">this</span>.right.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当添加完一个节点后：左子树高度 - 右子树高度 &gt; 1，右旋转</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果它的左子树的右子树的高度 大于 它的左子树的左子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left!=<span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.rightHeight() &gt; <span class="built_in">this</span>.left.leftHeight())&#123;</span><br><span class="line">            <span class="comment">//先需要对当前节点的左结点 进行左旋转</span></span><br><span class="line">            <span class="built_in">this</span>.left.leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>多叉树</h1><p><strong>二叉树存在问题</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182634337.png" alt="image-20241110144142213" style="zoom:80%"><ol><li>二叉树加载到内存时，如果节点数量过多，会存在问题：</li><li>构建二叉树时，需进行多次i/o操作（海量数据一般在文件或数据库中），对构建效率有影响。</li><li>海量数据也会造成树的高度过大（谁告诉你一定是满二叉树?）</li></ol><p><strong>多叉树基本介绍</strong></p><ol><li>在二叉树中，每个结点有数据项，最多有两个子节点。如果允许每个结点可以有更多的数据项和子结点，就是<strong>多叉树（Multiway Tree）</strong></li><li>2-3树、2-3-4树就是多叉树，多叉树通过重新组织结点，减少树的高度，能对二叉树进行优化</li><li>举例图：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182644649.png" alt="image-20241110144751794" style="zoom:80%"><p><strong>B树基本介绍</strong></p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182654628.png" alt="image-20241110115227975" style="zoom:80%"><ol><li>B树通过重新组织结点，降低树的高度，减少了i/o读写次数来提升效率</li><li><strong>文件系统及数据库系统的设计者利用了磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页</strong>(页得大小通常为4k)，这样<strong>每个节点只需要一次I/O</strong>就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中</li></ol><p><strong>2-3树基本介绍</strong></p><p>2-3树是最简单的B树结构，具有如下特点:</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>（B树都满足）</li><li>有两个子节点的节点叫<strong>二节点</strong>，二节点<strong>要么没有子节点</strong>，<strong>要么有两个</strong>子节点</li><li>有三个子节点的节点叫<strong>三节点</strong>，三节点<strong>要么没有子节点</strong>，<strong>要么有三个</strong>子节点</li><li>2-3树是由<strong>二节点和三节点</strong>构成的树。</li></ol><h2 id="2-3树">2-3树</h2><p><strong>关于三节点的说明</strong>：</p><p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182708712.png" alt="image-20241110144908830" style="zoom:80%">7号节点在8号左边，10号介于8和12中间，14在12右边。</p><p><strong>构建2-3树</strong>：</p><p><strong>插入规则</strong>：</p><ol><li>2-3树的<strong>所有叶子节点都在同一层</strong>。（B树都满足这个条件）</li><li>二节点要么没有子节点，要么有两个子节点。</li><li>三节点要么没有子节点，要么有三个子节点。</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆</strong>，<strong>如果上层满，则拆本层</strong>，拆后仍然需要满足上面3个条件。</li><li>对于三节点的子树的值大小仍然遵守（BST 二叉搜索树）的规则</li></ol><p><strong>图解</strong>：</p><p>以数列${ 16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20 } $为例</p><ol><li>插入16，24，12，32。十分自然：</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182719769.png" alt="image-20241110164703683" style="zoom:80%"><ol start="2"><li>插入14（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182735098.png" alt="image-20241110164746993" style="zoom:80%"><ol start="3"><li>插入26（需拆上一层）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182746622.png" alt="image-20241110164905390" style="zoom:80%"><ol start="4"><li>插入34（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182756249.png" alt="image-20241110165036078" style="zoom:80%"><ol start="5"><li>插入10（复杂）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182805896.png" alt="image-20241110165746037" style="zoom:150%"><ol start="6"><li>插入8（自然）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182817198.png" alt="image-20241110170229138" style="zoom:80%"><ol start="7"><li>插入28（中间过程演示）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182829094.png" alt="image-20241110170605919" style="zoom:80%"><ol start="8"><li>插入38（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182839077.png" alt="image-20241110170903042" style="zoom:80%"><ol start="9"><li>插入20（简单）</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182848306.png" alt="image-20241110170950636" style="zoom:80%"><h2 id="2-3-4树">2-3-4树</h2><p>2-3-4树概念和2-3树类似，多了一个四节点，也是一种B树</p><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182858787.png" alt="image-20241110121240298" style="zoom:80%"><h2 id="B树">B树</h2><p><strong>B-tree树</strong>即<strong>B树</strong>，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，<strong>B-tree就是指的B树</strong>。（还有写成<strong>B-树</strong>的，实际上没有&quot;B减树&quot;，就是B树）</p><ol><li><strong>B树的阶</strong>：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li><li><strong>B树的搜索</strong>：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong></li><li>搜索<strong>有可能在非叶子结点结束</strong>（已找到）</li><li>其搜索性能<strong>等价于在关键字全集内做一次二分查找</strong></li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182939663.png" alt="image-20241110171831364" style="zoom:80%"><h2 id="B-树">B+树</h2><p>B+树是B树的变体，也是一种多路搜索树。</p><ol><li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li><li>不可能在非叶子结点命中</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li><li>更适合文件索引系统</li><li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</li></ol><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/树/blog-20250501182950012.png" alt="image-20241110172528554" style="zoom:80%"><h2 id="B-树-2">B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p><ol><li>B* 树定义了非叶子结点关键字个数至少为$\frac{2}{3}M$，即块的最低使用率为$\frac{2}{3}$，而B+树的块的最低使用率为B+树的$\frac{1}{2}$。</li><li>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</li></ol></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-share"><div class="social-share" data-image="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani12.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="DataStructure基础——哈希表"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani4.png" onerror='onerror=null,src="/./static/imgs/error.png"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DataStructure基础——哈希表</div></div><div class="info-2"><div class="info-item-1">介绍了哈希表的概念、使用</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E5%9B%BE/" title="DataStructure基础——图"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani6.png" onerror='onerror=null,src="/./static/imgs/error.png"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DataStructure基础——图</div></div><div class="info-2"><div class="info-item-1">介绍了图的基本概念与使用场景</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/08/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-08</div><div class="info-item-2">数据结构与算法</div></div><div class="info-2"><div class="info-item-1">数据结构 前言：数据结构，好比是一类基本工具，每一类数据结构被抽象出来，必定有其用途。用好数据结构，就相当于用好了这类基本工具。——工欲善其事必先利其器。 TODO:数学渲染有问题……后续改一下 算法 排序算法-概论 分类 分为内部排序和外部排序， 内部排序，是指将要处理的数据都加载到内部存储器（内存）完成排序 外部排序，当数据量过大，无法全部加载到内存中时，需要借助外部存储进行排序 算法对比 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ In-place 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ In-place 稳定 希尔排序 $O(n\log n)$ $O(n\log n)$ $O(n\log^2 n)$ $O(1)$ In-place 不稳定 归并排序 $O(n\log...</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="DataStructure基础——哈希表"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DataStructure基础——哈希表</div></div><div class="info-2"><div class="info-item-1">介绍了哈希表的概念、使用</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/" title="DataStructure基础——数组与链表"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani10.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DataStructure基础——数组与链表</div></div><div class="info-2"><div class="info-item-1">介绍数组与链表的基本概念与使用</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E5%9B%BE/" title="DataStructure基础——图"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DataStructure基础——图</div></div><div class="info-2"><div class="info-item-1">介绍了图的基本概念与使用场景</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E6%A0%88/" title="DataStructure基础——栈"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DataStructure基础——栈</div></div><div class="info-2"><div class="info-item-1">介绍栈的基本概念与使用</div></div></div></a><a class="pagination-related" href="/2025/03/30/algorithm/datastruct/%E9%98%9F%E5%88%97/" title="DataStructure基础——队列"><img class="cover" src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DataStructure基础——队列</div></div><div class="info-2"><div class="info-item-1">介绍队列的基本概念与使用</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./static/imgs/avator.jpg" onerror='this.onerror=null,this.src="/./static/imgs/error.gif"' alt="avatar"></div><div class="author-info-name">暮雪Avid</div><div class="author-info-description">热爱+时间=实现</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yukinoshita52"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yukinoshita52" target="_blank" title="Github"><i class="fab fa-github" style="color:#4a7dbe"></i></a><a class="social-icon" href="/2642350585@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://space.bilibili.com/1808485376?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如出现图片访问失败问题，请科学上网，诶嘿(*^▽^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">链式存储二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.</span> <span class="toc-text">前序&#x2F;中序&#x2F;后续遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.4.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%90%8E%E7%BB%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">2.5.</span> <span class="toc-text">前序&#x2F;中序&#x2F;后续查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-2"><span class="toc-number">2.5.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.5.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">删除节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">2.6.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B01-%E7%9B%B4%E6%8E%A5%E6%8A%8A%E5%AD%90%E6%A0%91%E5%88%A0%E6%8E%89"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">实现1(直接把子树删掉)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B02-%E4%BB%85%E5%88%A0%E8%8A%82%E7%82%B9-%E6%B8%85%E6%99%B0"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">实现2(仅删节点)+清晰</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">顺序存储二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-4"><span class="toc-number">2.7.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">2.7.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.8.</span> <span class="toc-text">线索化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-5"><span class="toc-number">2.8.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">2.8.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">中序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">前序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">后序线索化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.9.</span> <span class="toc-text">遍历线索化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-6"><span class="toc-number">2.9.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">2.9.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">遍历中序线索化二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%89%8D%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">遍历前序线索化二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.9.2.3.</span> <span class="toc-text">遍历后序线索化二叉树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">创建赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-7"><span class="toc-number">3.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">3.2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">赫夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-8"><span class="toc-number">3.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.3.2.</span> <span class="toc-text">数据压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B01"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">实现1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%90%8E%E5%AE%9E%E7%8E%B02"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">封装后实现2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%8E%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">数据解压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">文件的压缩和解压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.5.</span> <span class="toc-text">文件压缩注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">二叉搜索树的创建和遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">4.3.</span> <span class="toc-text">二叉搜索树节点的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-9"><span class="toc-number">4.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">4.3.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">5.1.</span> <span class="toc-text">左旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-number">5.1.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">5.2.</span> <span class="toc-text">右旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-number">5.2.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">5.3.</span> <span class="toc-text">双旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="toc-number">5.3.1.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">多叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E6%A0%91"><span class="toc-number">6.1.</span> <span class="toc-text">2-3树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-4%E6%A0%91"><span class="toc-number">6.2.</span> <span class="toc-text">2-3-4树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">6.3.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91-2"><span class="toc-number">6.5.</span> <span class="toc-text">B*树</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/17/MySQL/MySQL%E9%94%81/" title="MySQL锁"><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani6.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="MySQL锁"></a><div class="content"><a class="title" href="/2025/11/17/MySQL/MySQL%E9%94%81/" title="MySQL锁">MySQL锁</a><time datetime="2025-11-17T11:42:54.000Z" title="发表于 2025-11-17 19:42:54">2025-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/17/MySQL/MySQL%E4%BA%8B%E5%8A%A1/" title="MySQL事务"><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani7.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="MySQL事务"></a><div class="content"><a class="title" href="/2025/11/17/MySQL/MySQL%E4%BA%8B%E5%8A%A1/" title="MySQL事务">MySQL事务</a><time datetime="2025-11-17T08:30:55.000Z" title="发表于 2025-11-17 16:30:55">2025-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/12/MySQL/MySQL%E7%B4%A2%E5%BC%95/" title="MySQL索引"><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani4.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="MySQL索引"></a><div class="content"><a class="title" href="/2025/11/12/MySQL/MySQL%E7%B4%A2%E5%BC%95/" title="MySQL索引">MySQL索引</a><time datetime="2025-11-12T08:10:13.000Z" title="发表于 2025-11-12 16:10:13">2025-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/11/MySQL/MySQL8-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/" title="MySQL8 窗口函数"><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani8.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="MySQL8 窗口函数"></a><div class="content"><a class="title" href="/2025/11/11/MySQL/MySQL8-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/" title="MySQL8 窗口函数">MySQL8 窗口函数</a><time datetime="2025-11-11T15:51:49.000Z" title="发表于 2025-11-11 23:51:49">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/11/other/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="cron表达式"><img src="https://raw.githubusercontent.com/Yukinoshita52/StructureImages/main/blogs/common/blog-ani5.png" onerror='this.onerror=null,this.src="/./static/imgs/error.png"' alt="cron表达式"></a><div class="content"><a class="title" href="/2025/11/11/other/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="cron表达式">cron表达式</a><time datetime="2025-11-11T15:36:25.000Z" title="发表于 2025-11-11 23:36:25">2025-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"><div id="footer-wrap"><div class="copyright">&copy;2025 By 暮雪Avid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://npm.elemecdn.com/nanshen@latest/img/icp.webp"><span>浙ICP备2025158028号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="/js/pictureCDN.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,Yukinoshita,自由,平等,公正,诶嘿o(*￣︶￣*)o,法治,爱国,Yukino,敬业,诚信,友善" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>