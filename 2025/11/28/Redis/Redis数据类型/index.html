<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 数据类型 | 暮雪Avid的博客</title><meta name="author" content="暮雪Avid"><meta name="copyright" content="暮雪Avid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis 数据类型所有的数据类型有：String、Hash、List、Set、Zset、BitMap、HyperLogLog、GEO、Stream String介绍String 就是最基本的 Key-Value 类型数据，key 是唯一标识，Value 可以是字符串也可以是数字（整数、浮点数）。 底层是由 SDS（Simple Dynamic String）进行实现。 常用指令    指令 描述">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 数据类型">
<meta property="og:url" content="https://blogs.muxueavid.top/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="暮雪Avid的博客">
<meta property="og:description" content="Redis 数据类型所有的数据类型有：String、Hash、List、Set、Zset、BitMap、HyperLogLog、GEO、Stream String介绍String 就是最基本的 Key-Value 类型数据，key 是唯一标识，Value 可以是字符串也可以是数字（整数、浮点数）。 底层是由 SDS（Simple Dynamic String）进行实现。 常用指令    指令 描述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani8.png">
<meta property="article:published_time" content="2025-11-28T10:31:02.000Z">
<meta property="article:modified_time" content="2025-12-14T10:31:30.000Z">
<meta property="article:author" content="暮雪Avid">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blogs.muxueavid.top/blogs/common/blog-ani8.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 数据类型",
  "url": "https://blogs.muxueavid.top/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
  "image": "https://blogs.muxueavid.top/blogs/common/blog-ani8.png",
  "datePublished": "2025-11-28T10:31:02.000Z",
  "dateModified": "2025-12-14T10:31:30.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "暮雪Avid",
      "url": "https://blogs.muxueavid.top/"
    }
  ]
}</script><link rel="shortcut icon" href="https://blogs.muxueavid.top/blogs/common/avator.jpg"><link rel="canonical" href="https://blogs.muxueavid.top/2025/11/28/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 数据类型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://blogs.muxueavid.top/blogs/common/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://blogs.muxueavid.top/blogs/common/blog-ani8.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">暮雪Avid的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 数据类型</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis 数据类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-28T10:31:02.000Z" title="发表于 2025-11-28 18:31:02">2025-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-14T10:31:30.000Z" title="更新于 2025-12-14 18:31:30">2025-12-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>所有的数据类型有：String、Hash、List、Set、Zset、BitMap、HyperLogLog、GEO、Stream</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>String 就是最基本的 Key-Value 类型数据，key 是唯一标识，Value 可以是字符串也可以是数字（整数、浮点数）。</p>
<p>底层是由 SDS（Simple Dynamic String）进行实现。</p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SET key value</strong></td>
<td>设置指定 <code>key</code> 的值。如果 <code>key</code> 已经存在，则覆盖旧值。</td>
</tr>
<tr>
<td><strong>GET key</strong></td>
<td>获取指定 <code>key</code> 的值。如果 <code>key</code> 不存在，返回 <code>nil</code>。</td>
</tr>
<tr>
<td><strong>GETRANGE key start end</strong></td>
<td>获取指定 <code>key</code> 中字符串值的子字符串。</td>
</tr>
<tr>
<td><strong>SETEX key seconds value</strong></td>
<td>设置 <code>key</code> 的值，并同时设置过期时间（以秒为单位）。</td>
</tr>
<tr>
<td><strong>PSETEX key milliseconds value</strong></td>
<td>设置 <code>key</code> 的值，并同时设置过期时间（以毫秒为单位）。</td>
</tr>
<tr>
<td><strong>SETNX key value</strong></td>
<td>仅在 <code>key</code> 不存在时设置 <code>key</code> 的值。如果 <code>key</code> 已经存在，则不执行任何操作。</td>
</tr>
<tr>
<td><strong>MSET key value [key value …]</strong></td>
<td>批量设置多个 <code>key-value</code> 对。</td>
</tr>
<tr>
<td><strong>MGET key [key …]</strong></td>
<td>批量获取多个 <code>key</code> 的值。</td>
</tr>
<tr>
<td><strong>INCR key</strong></td>
<td>将存储在 <code>key</code> 上的数字值增 1。</td>
</tr>
<tr>
<td><strong>DECR key</strong></td>
<td>将存储在 <code>key</code> 上的数字值减 1。</td>
</tr>
<tr>
<td><strong>INCRBY key increment</strong></td>
<td>将存储在 <code>key</code> 上的数字值增加指定的 <code>increment</code>。</td>
</tr>
<tr>
<td><strong>DECRBY key decrement</strong></td>
<td>将存储在 <code>key</code> 上的数字值减少指定的 <code>decrement</code>。</td>
</tr>
<tr>
<td><strong>APPEND key value</strong></td>
<td>将 <code>value</code> 追加到 <code>key</code> 原来的值的末尾。</td>
</tr>
<tr>
<td><strong>STRLEN key</strong></td>
<td>获取存储在 <code>key</code> 上的字符串值的长度。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">xiaolingcoding-Redis 数据结构-String 应用场景</a></p>
</blockquote>
<p>缓存对象</p>
<p>例如要存储一个uid为1、age=18、name=yukino的对象，可以使用<code>对象类:ID + JSON</code>存储整个对象，也可以使用<code>对象类:ID:属性 + 值</code>的方式存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式1：</span><br><span class="line">SET user:1 &#x27;&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;yukino&quot;&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># 方式2：</span><br><span class="line">MSET user:1:age 18 user:1:name yukino</span><br><span class="line"># 等价于 SET user:1:age 18、SET user:1:name yukino</span><br></pre></td></tr></table></figure>
<p>常规计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SET blog:1001:likes 0</span><br><span class="line">(integer) OK</span><br><span class="line"></span><br><span class="line">INCR blog:1001:likes</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">INCR blog:1001:likes</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">GET blog:1001:likes</span><br><span class="line">&quot;2&quot;</span><br><span class="line"></span><br><span class="line">DECR blog:1001:likes</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>分布式锁</p>
<p>分析：加锁操作可以通过一句<code>SET lock_key unique_value NX PX 10000</code>来实现，这个操作是原子性的。</p>
<p>解锁时，由于需要包含“当前当前客户端持有锁”+“删除这个锁”两个操作，所以要用Lua脚本来实现。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;GET&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&quot;DEL&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>java代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributedLockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lua 脚本内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNLOCK_LUA_SCRIPT</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;if redis.call(\&quot;GET\&quot;, KEYS[1]) == ARGV[1] &quot;</span> +</span><br><span class="line">        <span class="string">&quot;then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return redis.call(\&quot;DEL\&quot;, KEYS[1]) &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 0 &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的键名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;lock:resource_a&quot;</span>;</span><br><span class="line">    <span class="comment">// 客户端唯一标识 (例如，UUID)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNIQUE_VALUE</span> <span class="operator">=</span> <span class="string">&quot;client_uuid_123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>)) &#123;</span><br><span class="line">            <span class="comment">// --- 1. 尝试加锁 ---</span></span><br><span class="line">            <span class="comment">// EX 10 (10秒过期), NX (不存在才设置)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lockResult</span> <span class="operator">=</span> jedis.set(LOCK_KEY, UNIQUE_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(lockResult)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加锁成功。&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// --- 2. 业务逻辑处理 ---</span></span><br><span class="line">                System.out.println(<span class="string">&quot;执行受保护的业务逻辑...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// --- 3. 释放锁 ---</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// KEYS 列表：传递锁的键名</span></span><br><span class="line">                <span class="comment">// ARGV 列表：传递客户端唯一标识</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">releaseResult</span> <span class="operator">=</span> jedis.eval(</span><br><span class="line">                    UNLOCK_LUA_SCRIPT,</span><br><span class="line">                    Collections.singletonList(LOCK_KEY), </span><br><span class="line">                    Collections.singletonList(UNIQUE_VALUE)</span><br><span class="line">                );</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 结果：1 表示成功删除（解锁），0 表示失败（键不存在或值不匹配）</span></span><br><span class="line">                <span class="keyword">if</span> (releaseResult.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;解锁成功。&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;解锁失败：锁已过期或不是当前客户端持有。返回结果: &quot;</span> + releaseResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加锁失败，资源被锁定。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享 Session 信息</p>
<p>如下，在分布式系统中，用户登陆后，登陆会话信息可能存储在服务器1上，但是下一次再来登陆，可能负载均衡算法轮询到服务器2提供服务，这时服务器2上就没有对应的Session信息，出现用户需要重新登陆的情况，而且一份相同的信息需要在不同服务器中存储。</p>
<p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600927.png" alt="img" style="zoom: 75%;" /></p>
<p>而如果使用Redis来存储管理这些会话信息就十分方便，不会出现重复存储的问题、读取速度快、能够对会话设置过期时间。</p>
<p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600929.png" alt="img" style="zoom: 80%;" /></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>List 是字符串列表，根据按照插入顺序存储和读取，可在头部或尾部快速添加或删除。</p>
<p>底层是由双向链表或压缩列表实现，高版本后由 quicklist 实现。</p>
<h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LPUSH key element [element …]</strong></td>
<td>将一个或多个值插入到列表的 <strong>头部</strong>（最左边）。如果 <code>key</code> 不存在，创建一个空列表并执行操作。</td>
</tr>
<tr>
<td><strong>RPUSH key element [element …]</strong></td>
<td>将一个或多个值插入到列表的 <strong>尾部</strong>（最右边）。如果 <code>key</code> 不存在，创建一个空列表并执行操作。</td>
</tr>
<tr>
<td><strong>LPOP key</strong></td>
<td>移除并返回列表的 <strong>头部</strong>（最左边）元素。</td>
</tr>
<tr>
<td><strong>RPOP key</strong></td>
<td>移除并返回列表的 <strong>尾部</strong>（最右边）元素。</td>
</tr>
<tr>
<td><strong>BLPOP key [key …] timeout</strong></td>
<td><strong>阻塞式</strong> LPOP。移除并返回第一个非空列表的头部元素。如果没有元素，则阻塞直到有元素可用或达到 <code>timeout</code>。</td>
</tr>
<tr>
<td><strong>BRPOP key [key …] timeout</strong></td>
<td><strong>阻塞式</strong> RPOP。移除并返回第一个非空列表的尾部元素。如果没有元素，则阻塞直到有元素可用或达到 <code>timeout</code>。</td>
</tr>
<tr>
<td><strong>LLEN key</strong></td>
<td>获取列表的长度。</td>
</tr>
<tr>
<td><strong>LRANGE key start stop</strong></td>
<td>获取列表指定范围内的元素。索引从 0 开始。<code>start</code> 和 <code>stop</code> 可以是负数，表示从尾部开始计数（-1 是最后一个元素）。</td>
</tr>
<tr>
<td><strong>LINDEX key index</strong></td>
<td>通过索引获取列表中的元素。</td>
</tr>
<tr>
<td><strong>LSET key index element</strong></td>
<td>通过索引设置列表中指定位置的元素值。</td>
</tr>
<tr>
<td><strong>LINSERT key BEFORE 或 AFTER pivot value</strong></td>
<td>在列表中指定元素 <code>pivot</code> 的 <strong>前面</strong> 或 <strong>后面</strong> 插入新元素 <code>value</code>。</td>
</tr>
<tr>
<td><strong>LREM key count value</strong></td>
<td>根据 <code>count</code> 的值，移除列表中与 <code>value</code> 相等的元素。</td>
</tr>
<tr>
<td><strong>RPOPLPUSH source destination</strong></td>
<td>原子性地将 <code>source</code> 列表的尾部元素弹出，并将其推入 <code>destination</code> 列表的头部。常用于实现循环队列或消息处理。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2">xiaolingcoding-Redis List 应用场景</a></p>
</blockquote>
<p>消息队列（不完全靠谱）</p>
<p>通过 <code>LPUSH mq message</code>添加消息，通过 <code>RPOP mq</code>读取消息。</p>
<p>消息保序：Redis 的 List 数据类型支持了消息的顺序性。</p>
<p>阻塞读取：但是使用 LPUSH 命令存储消息后，是没有通知的，所以需要一个 while(true) 循环或者间隔一定时间的轮询来消费消息，使用 while(true) 的话会让消费者不断执行RPOP，间隔一定时间轮询的话，做不到及时性。所以另外还有一个命令 BRPOP（Block RPOP）阻塞式右弹出，当消息队列没消息时，会阻塞RPOP命令，有消息进入后才进行RPOP。</p>
<p>重复消息处理：使用全局唯一ID，处理完一条消息后，在消费者程序端记录，若已经处理过则不再处理。</p>
<p>消息的可靠性：List会在一条消息读取后，这条消息就被删除了，如果此时消费者端宕机，重启后这条消息就是没被执行完且无法恢复执行的。为了解决这一问题，可以新增一条备用List，每当一条消息读取后，在备用List中进行存储。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Hash 是一个键值对（key-value）集合，其中 value 存储类似于：<code>value = [&#123;field1,value1&#125;,&#123;field2,value2&#125;,...&#123;fieldN,valueN&#125;]</code>，所以 Hash 特别适合存储对象类型数据。</p>
<p>底层是由压缩列表或哈希表实现</p>
<h3 id="常用指令-2"><a href="#常用指令-2" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HSET key field value [field value …]</strong></td>
<td>将哈希表 <code>key</code> 中的一个或多个 <code>field-value</code> 对设置进去。如果 <code>key</code> 不存在，将创建一个新的哈希表。</td>
</tr>
<tr>
<td><strong>HGET key field</strong></td>
<td>获取存储在哈希表 <code>key</code> 中指定 <code>field</code> 的值。</td>
</tr>
<tr>
<td><strong>HMSET key field value [field value …]</strong></td>
<td><strong>（已弃用，推荐使用 HSET）</strong> 批量设置哈希表中的多个 <code>field-value</code> 对。</td>
</tr>
<tr>
<td><strong>HMGET key field [field …]</strong></td>
<td>批量获取哈希表 <code>key</code> 中一个或多个 <code>field</code> 的值。</td>
</tr>
<tr>
<td><strong>HGETALL key</strong></td>
<td>获取哈希表 <code>key</code> 中所有的 <code>field</code> 和 <code>value</code>。</td>
</tr>
<tr>
<td><strong>HKEYS key</strong></td>
<td>获取哈希表 <code>key</code> 中所有域（field）。</td>
</tr>
<tr>
<td><strong>HVALS key</strong></td>
<td>获取哈希表 <code>key</code> 中所有值（value）。</td>
</tr>
<tr>
<td><strong>HDEL key field [field …]</strong></td>
<td>删除哈希表 <code>key</code> 中的一个或多个指定域（field）。</td>
</tr>
<tr>
<td><strong>HEXISTS key field</strong></td>
<td>查看哈希表 <code>key</code> 中指定域 <code>field</code> 是否存在。</td>
</tr>
<tr>
<td><strong>HLEN key</strong></td>
<td>获取哈希表 <code>key</code> 中域（field）的数量。</td>
</tr>
<tr>
<td><strong>HINCRBY key field increment</strong></td>
<td>为哈希表 <code>key</code> 中指定域 <code>field</code> 的整数值增加指定的 <code>increment</code>。</td>
</tr>
<tr>
<td><strong>HINCRBYFLOAT key field increment</strong></td>
<td>为哈希表 <code>key</code> 中指定域 <code>field</code> 的浮点数值增加指定的 <code>increment</code>。</td>
</tr>
<tr>
<td><strong>HSETNX key field value</strong></td>
<td>仅当哈希表 <code>key</code> 中不存在指定域 <code>field</code> 时，才设置该域的值。</td>
</tr>
<tr>
<td><strong>HSCAN key cursor [MATCH pattern] [COUNT count]</strong></td>
<td>迭代哈希表中的键值对，用于处理大规模数据，避免阻塞。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3">xiaolingcoding-Redis Hash应用场景</a></p>
</blockquote>
<p>缓存对象，例如要存储一个uid为1的对象，其age=18，name=yukino</p>
<p>可以如下存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET uid:1 age 18 name yukino</span><br></pre></td></tr></table></figure>
<p>购物车场景（userId为key、productId为field、productNum为value）（一个购物车里可以有多件商品，不同商品可以选择不同数量）</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>Set 是无序唯一键值对集合，支持集合的增删改查，还支持交集、并集、差集操作。</p>
<p>底层是由哈希表或整数集合实现。</p>
<h3 id="常用指令-3"><a href="#常用指令-3" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SADD key member [member …]</strong></td>
<td>将一个或多个 <code>member</code> 元素添加到集合 <code>key</code> 中。重复元素将被忽略。</td>
</tr>
<tr>
<td><strong>SMEMBERS key</strong></td>
<td>返回集合 <code>key</code> 中的所有成员。</td>
</tr>
<tr>
<td><strong>SISMEMBER key member</strong></td>
<td>判断 <code>member</code> 元素是否是集合 <code>key</code> 的成员。</td>
</tr>
<tr>
<td><strong>SCARD key</strong></td>
<td>获取集合 <code>key</code> 的成员数量。</td>
</tr>
<tr>
<td><strong>SREM key member [member …]</strong></td>
<td>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素。</td>
</tr>
<tr>
<td><strong>SPOP key [count]</strong></td>
<td>随机移除并返回集合中的一个或多个元素。</td>
</tr>
<tr>
<td><strong>SRANDMEMBER key [count]</strong></td>
<td>随机获取集合中的一个或多个元素，但不移除。</td>
</tr>
<tr>
<td><strong>SMOVE source destination member</strong></td>
<td>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</td>
</tr>
<tr>
<td><strong>SINTER key [key …]</strong></td>
<td>返回给定所有集合的<strong>交集</strong>（Intersection）成员。</td>
</tr>
<tr>
<td><strong>SUNION key [key …]</strong></td>
<td>返回给定所有集合的<strong>并集</strong>（Union）成员。</td>
</tr>
<tr>
<td><strong>SDIFF key [key …]</strong></td>
<td>返回第一个集合与后面所有集合的<strong>差集</strong>（Difference）成员。</td>
</tr>
<tr>
<td><strong>SINTERSTORE destination key [key …]</strong></td>
<td>将给定所有集合的交集存储到 <code>destination</code> 集合中。</td>
</tr>
<tr>
<td><strong>SUNIONSTORE destination key [key …]</strong></td>
<td>将给定所有集合的并集存储到 <code>destination</code> 集合中。</td>
</tr>
<tr>
<td><strong>SDIFFSTORE destination key [key …]</strong></td>
<td>将给定所有集合的差集存储到 <code>destination</code> 集合中。</td>
</tr>
<tr>
<td><strong>SSCAN key cursor [MATCH pattern] [COUNT count]</strong></td>
<td>迭代集合中的元素，用于处理大规模数据，避免阻塞。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>Set的特性在于去重、支持交并补，针对这一特性，可以去发现他的场景：</p>
<p><strong>场景1：点赞/喜欢/收藏场景</strong>——因为一个用户不能给同一个文章多次点赞，使用Set可以达到很好的去重效果，当然最大的优势是快速判断“某个用户是否给某篇文章点赞过”。</p>
<blockquote>
<p>粗略计算，100万点赞仅需50MB。但是1000万点赞就要500MB，10亿约46.56GB！</p>
<p>所以如果单纯为了统计“计数”，为什么不使用String类型或者HyperLogLog呢？使用Set的目的还是因为能知道每篇文章具体的“点赞用户”</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 用户1对文章1点赞</span><br><span class="line">SADD blog:1 user:1</span><br><span class="line"># 用户2对文章1点赞</span><br><span class="line">SADD blog:1 user:2</span><br><span class="line"></span><br><span class="line"># 用户1取消了对文章1的点赞</span><br><span class="line">SREM blog:1 user:1</span><br><span class="line"></span><br><span class="line"># 获取文章1所有点赞的用户</span><br><span class="line">SMEMBERS blog:1</span><br><span class="line"></span><br><span class="line"># 获取文章1点赞数量</span><br><span class="line">SCARD blog:1</span><br><span class="line"></span><br><span class="line"># 判断用户1是否给文章1点赞了（O(1)时间复杂度）</span><br><span class="line">SISMEMBER blog:1 user:1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>SISMEMBER blog:1 user:1</code>是$O(1)$时间复杂度的，不要弄混淆了……不要和Redis本身是key-value键值对存储类型数据库概念混淆……blog:1只是用于找到这个“value”，这个“value”是Set集合类型的，集合类型查找、判断元素就是$O(1)$（因为底层是（数据量小时）压缩列表或哈希表实现）</p>
</blockquote>
<p><strong>场景2：共同关注</strong></p>
<p>就是利用Set支持“交并补”的操作，可以查询两个用户的共同关注，可以用于好友推荐、相关内容推荐，或者像是微信公众号展示“N个朋友关注”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 用户1关注了1、3、5、7这些公众号（id）</span><br><span class="line">SADD user:1 1 3 5 7</span><br><span class="line"></span><br><span class="line"># 用户2关注了1、2、3这些公众号（id）</span><br><span class="line">SADD user:2 1 2 3</span><br><span class="line"></span><br><span class="line"># 验证某个公众号是否是共同关注（查询两次）</span><br><span class="line">SISMEMBER user:1 5</span><br><span class="line">SISMEMBER user:2 5</span><br><span class="line"></span><br><span class="line"># 查询两个用户的共同关注</span><br><span class="line">SINTER user:1 user:2 </span><br><span class="line"></span><br><span class="line"># 给用户2推荐新的公众号（用户2没关注的、但是用户1关注的：）</span><br><span class="line">SDIFF user:1 user:2</span><br></pre></td></tr></table></figure>
<p><strong>场景3：抽奖活动</strong></p>
<p>首先每个人肯定是唯一个体，那就把所有人（如果这个基数很大，可以在MySQL查询用户时就做一次“随机抽取”，然后再从这部分已经缩减的数据范围再做抽奖【但是还是要让算法随机】）都放入集合Set。然后要分情况，如果一个人可以多次获奖，那么抽取完后不用SPOP，如果一个人只能中奖1次，就需要SPOP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 抽出1个特等奖</span><br><span class="line">SRANDMEMBER lucky 1</span><br><span class="line"></span><br><span class="line"># 抽出5个二等奖</span><br><span class="line">SRANDMEMBER lucky 5</span><br><span class="line"></span><br><span class="line"># 如果不允许重复中奖：</span><br><span class="line">SPOP lucky 1</span><br><span class="line">SPOP lucky 5</span><br></pre></td></tr></table></figure>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Zset，即Sorted Set，有序集合，相比于Set数据类型多一个用于排序的属性score，这个score属性必须是数字类型（支持整数、浮点数、科学计数法）</p>
<p>底层使用压缩列表或者跳表实现。</p>
<h3 id="常用指令-4"><a href="#常用指令-4" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ZADD key score member [score member …]</strong></td>
<td>向有序集合 <code>key</code> 中添加一个或多个成员及其分数 (<code>score</code>)。如果成员已存在，则更新其分数。</td>
</tr>
<tr>
<td><strong>ZRANGE key start stop [WITHSCORES]</strong></td>
<td>返回有序集合 <code>key</code> 中，索引在 <code>start</code> 和 <code>stop</code> 之间（从小到大排序）的成员。可选择返回分数。</td>
</tr>
<tr>
<td><strong>ZREVRANGE key start stop [WITHSCORES]</strong></td>
<td>返回有序集合 <code>key</code> 中，索引在 <code>start</code> 和 <code>stop</code> 之间（从大到小排序）的成员。可选择返回分数。</td>
</tr>
<tr>
<td><strong>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</strong></td>
<td>返回分数在 <code>min</code> 和 <code>max</code> 之间（从小到大排序）的成员。</td>
</tr>
<tr>
<td><strong>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</strong></td>
<td>返回分数在 <code>max</code> 和 <code>min</code> 之间（从大到小排序）的成员。</td>
</tr>
<tr>
<td><strong>ZRANGEBYLEX key min max [LIMIT offset count]</strong></td>
<td><strong>（已弃用，推荐使用 ZRANGE）</strong> 返回有序集合中，成员的字典序在 <code>min</code> 和 <code>max</code> 之间的元素。要求所有分数相同。</td>
</tr>
<tr>
<td><strong>ZSCORE key member</strong></td>
<td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的分数。</td>
</tr>
<tr>
<td><strong>ZINCRBY key increment member</strong></td>
<td>为有序集合 <code>key</code> 中 <code>member</code> 成员的分数加上指定的 <code>increment</code> 值。常用于排行榜分数更新。</td>
</tr>
<tr>
<td><strong>ZCARD key</strong></td>
<td>获取有序集合 <code>key</code> 的成员数量。</td>
</tr>
<tr>
<td><strong>ZCOUNT key min max</strong></td>
<td>统计有序集合 <code>key</code> 中分数在 <code>min</code> 和 <code>max</code> 之间的成员数量。</td>
</tr>
<tr>
<td><strong>ZRANK key member</strong></td>
<td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的排名（从小到大排序，从 0 开始）。</td>
</tr>
<tr>
<td><strong>ZREVRANK key member</strong></td>
<td>返回有序集合 <code>key</code> 中 <code>member</code> 成员的倒序排名（从大到小排序，从 0 开始）。</td>
</tr>
<tr>
<td><strong>ZREM key member [member …]</strong></td>
<td>移除有序集合 <code>key</code> 中的一个或多个成员。</td>
</tr>
<tr>
<td><strong>ZREMRANGEBYRANK key start stop</strong></td>
<td>移除有序集合中，指定排名范围内的所有成员。</td>
</tr>
<tr>
<td><strong>ZREMRANGEBYSCORE key min max</strong></td>
<td>移除有序集合中，指定分数范围内的所有成员。</td>
</tr>
<tr>
<td>**ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM\</td>
<td>MIN\</td>
<td>MAX]**</td>
<td>计算多个有序集合的并集，并将结果存储在 <code>destination</code> 集合。</td>
</tr>
<tr>
<td>**ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM\</td>
<td>MIN\</td>
<td>MAX]**</td>
<td>计算多个有序集合的交集，并将结果存储在 <code>destination</code> 集合。</td>
</tr>
<tr>
<td><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong></td>
<td>迭代有序集合中的元素，用于处理大规模数据，避免阻塞。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>Zset，即Sorted Set，有序的集合元素，非常适合哪些按照某一规则排序的元素。适合排行榜、最新列表这类需要<strong>频繁更新</strong>的场景。</p>
<p><strong>场景1：排行榜</strong></p>
<p>设置某个ranking的Zset集合（此处为<code>user:avidbjm:ranking</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ps：ZADD key score member [score member ...]</span><br><span class="line"># 翻译：用户avidbjm的blog:1的score值为100（这个score可以是“点赞数”或者“综合分数值”）</span><br><span class="line">ZADD user:avidbjm:ranking 100 blog:1</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:2的点赞数为50</span><br><span class="line">ZADD user:avidbjm:ranking 50 blog:2</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:3的点赞数为200</span><br><span class="line">ZADD user:avidbjm:ranking 200 blog:3</span><br><span class="line"></span><br><span class="line"># 用户avidbjm的blog:4的点赞数为400</span><br><span class="line">ZADD user:avidbjm:ranking 400 blog:4</span><br></pre></td></tr></table></figure>
<p>对某一个具体内容进行加分or减分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 给user:avidbjm:ranking排行榜中的blog:2增加1分</span><br><span class="line">ZINCRBY user:avidbjm:ranking 1 blog:2</span><br><span class="line"></span><br><span class="line"># 给user:avidbjm:ranking排行榜中的blog:3减少2分</span><br><span class="line">ZINCRBY user:avidbjm:ranking -2 blog:3</span><br></pre></td></tr></table></figure>
<p>查看排行榜中某个内容的分数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ZSCORE key member</span><br><span class="line"># 查看这个排行榜的blog:3的分数值</span><br><span class="line">ZSCORE user:avidbjm:ranking blog:3</span><br></pre></td></tr></table></figure>
<p>查看排行榜前三的内容</p>
<blockquote>
<p>具体要看怎么定义“排名”，有的排名是score越小越靠前，有的是score越大越靠前，要根据需求来选择使用<code>ZRANGE key start stop [WITHSCORES]</code>或<code>ZREVRANGE key start stop [WITHSCORES]</code>，前者正序，后者逆序</p>
<blockquote>
<p> Zset是按照score从小到大顺序存储的</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出点赞最多的前三名（所以是ZREVRANGE）（WITHSCORES是附带输出score）</span><br><span class="line">ZREVRANGE user:avidbjm:ranking 0 2 WITHSCORES</span><br><span class="line"></span><br><span class="line"># 输出点赞最少的四名（示例不带WITHSCORES）</span><br><span class="line">ZRANGE user:avidbjm:ranking 0 3</span><br></pre></td></tr></table></figure>
<p><img src="https://blogs.muxueavid.top/blogs/2025/12/20251213174600930.png" alt="image-20251202225502047" style="zoom: 90%;" /></p>
<p><strong>场景2：电话、姓名排序</strong></p>
<p>这个场景的话是因为可以使用<code>ZRANGEBYLEX</code>和<code>ZREVRANGEBYLEX</code>指令来获取某一个特定区间的元素</p>
<blockquote>
<p>注意：使用这两个命令时，元素的score必须相同，否则会不准确。</p>
<p>但是<code>ZRANGEBYLEX</code>命令已经弃用！</p>
</blockquote>
<p>电话排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZADD phones_by_lex 0 &quot;13912345678&quot; 0 &quot;13800001111&quot; 0 &quot;18698765432&quot; 0 &quot;15011112222&quot; 0 &quot;13900000001&quot; 0 &quot;18800000000&quot;</span><br><span class="line"></span><br><span class="line"># 获取所有电话号码</span><br><span class="line">ZRANGE phones_by_lex 0 -1</span><br><span class="line"># 获取所有电话号码（另一种写法）</span><br><span class="line">ZRANGEBYLEX phones_by_lex - +</span><br><span class="line"></span><br><span class="line"># 查询139到140号段的号码（左闭右开）</span><br><span class="line">ZRANGEBYLEX phones_by_lex &quot;[139&quot; &quot;(140&quot;</span><br></pre></td></tr></table></figure>
<p>姓名排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD names_by_lex 0 &quot;Adam&quot; 0 &quot;Bob&quot; 0 &quot;Alice&quot; 0 &quot;Bernard&quot; 0 &quot;Charlie&quot; 0 &quot;David&quot; 0 &quot;Brenda&quot;</span><br><span class="line"></span><br><span class="line"># 查询字母A开头的名字（不包含B）</span><br><span class="line">ZRANGEBYLEX names_by_lex &quot;[A&quot; &quot;(B&quot;</span><br></pre></td></tr></table></figure>
<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>BitMap，即位图，是一连串的二进制数组（0、1），因为可以通过位移量（offset）定位元素，所以查询某个元素状态的时间复杂度为$O(1)$。</p>
<blockquote>
<p>BitMap 通过将数据元素 ID 直接映射到字节数组的索引（$I = \lfloor N / 8 \rfloor$）和字节内位移量（$P = N \pmod 8$），实现了极高的查找效率。由于定位一个元素状态仅涉及<strong>固定的数组寻址</strong>和<strong>基础的位运算</strong>，其操作时间独立于数据总量，因此时间复杂度为<strong>常数时间 $O(1)$</strong>，这使其成为处理大规模布尔状态（如用户签到、ID 存在性）的理想数据结构。</p>
</blockquote>
<h3 id="常用指令-5"><a href="#常用指令-5" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
<th><strong>复杂度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SETBIT key offset value</code></td>
<td>设置 BitMap 中指定偏移量（<code>offset</code>）上的位的值（<code>value</code>，必须是 0 或 1）。如果键不存在，它将自动创建一个足够大的 BitMap。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>GETBIT key offset</code></td>
<td>获取 BitMap 中指定偏移量（<code>offset</code>）上的位的值（0 或 1）。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>BITCOUNT key [start end]</code></td>
<td>统计 BitMap 中设置为 1 的位的数量。可以指定字节范围（<code>start</code> 和 <code>end</code>，均为字节偏移量）。</td>
<td>$O(N)$ ( $N$ 是被检查的字节数)</td>
</tr>
<tr>
<td><code>BITOP operation destkey key [key ...]</code></td>
<td>对一个或多个 BitMap 执行位操作（<code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>NOT</code>），并将结果存储到目标键（<code>destkey</code>）中。</td>
<td>$O(N)$ ( $N$ 是操作的最长键的长度)</td>
</tr>
<tr>
<td><code>BITPOS key bit [start end]</code></td>
<td>查找 BitMap 中第一个值为 <code>bit</code> (0 或 1) 的位的位置（偏移量）。可以指定字节范围。</td>
<td>$O(N)$ ( $N$ 是被检查的字节数)</td>
</tr>
<tr>
<td><code>STRLEN key</code></td>
<td>获取存储在 BitMap 中的字符串值的长度（字节数）。间接反映了 BitMap 的大小。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>GET key</code></td>
<td>获取存储 BitMap 的底层字符串值。</td>
<td>$O(N)$ ( $N$ 是字符串的长度)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>BitMap非常适合<strong>二值存储</strong>的场景（true or false），可以做到用少量内存空间存储大量简单状态信息，例如签到统计、判断用户登陆状态、连续打卡用户数量。</p>
<p><strong>场景1：签到统计</strong></p>
<p>比如需要统计一个用户165天的签到情况，只需要365bit就行，那么存储百万用户一年的登陆情况——$1000000 \times 365 \div 8 \div 1024 \div 1024 \approx 43.5MB$，非常得节省内容。更别说可以设置过期时间进行删除操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 语法：SETBIT key offset value（value只能为0或1）</span><br><span class="line"></span><br><span class="line"># ps：uid:sign:1:202604的语义是“uid为1的用户、2026年04月”</span><br><span class="line"></span><br><span class="line"># 设置某个用户某天的签到状态（表示2026-04-16这天签到了）</span><br><span class="line">SETBIT uid:sign:1:202604 16 1</span><br><span class="line"></span><br><span class="line"># 判断用户是否在2026-04-16这天进行签到</span><br><span class="line">GETBIT uid:sign:1:202604 16</span><br><span class="line"></span><br><span class="line"># 统计用户在2026-4月的签到天数（统计1的个数）</span><br><span class="line">BITCOUNT uid:sign:1:202604</span><br><span class="line"></span><br><span class="line"># 计算用户在2026-4月的首次打卡日（因为BITPOS默认扫描整个位图，返回第一个为1的offset）</span><br><span class="line"># 由于offset从0开始，要+1</span><br><span class="line">BITPOS uid:sign:1:202604 1</span><br></pre></td></tr></table></figure>
<p><strong>场景2：判断用户登陆状态</strong></p>
<p>由于一个用户只有登录、登出两种状态，所以用1位就能记录。那么粗略计算1亿用户大约12MB空间就可以记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># uid为10001的用户已登录</span><br><span class="line">SETBIT login_status 10001 1</span><br><span class="line"></span><br><span class="line"># 判断uid为10001的用户是否登录</span><br><span class="line">GETBIT login_status 10001</span><br><span class="line"></span><br><span class="line"># uid为10001的用户已下线</span><br><span class="line">SETBIT login_status 10001 0</span><br></pre></td></tr></table></figure>
<p><strong>场景3：连续打卡用户数量</strong></p>
<p>假设要计算连续3天打卡用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对三天的bitmap进行与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line"></span><br><span class="line"># 统计bit位=1的个数（就是连续三天打卡的用户数量）</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>
<p>前面已知，1亿用户的登陆状态也仅需约12MB，那么7天不到100MB，1个月不到500MB。</p>
<p>不过最好设置定时删除的时间，比如每周或每月清空一次，记录到数据库。</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>HyperLogLog，用于大数计数，提供了一种不完全精确的<strong>去重计数</strong>，但是可以保证输入元素数量很多时，能保持几乎不变的内存空间。</p>
<p>在 Redis 里，每个 HLL 键的内存开销大约是 <strong>12 KB</strong>，但是能存储$2^{64}$个不同元素的基数，它的标准误差 (Standard Error) 大约在 <strong>0.81%</strong> 左右。这意味着它提供的是<strong>近似值</strong>，而不是精确值。</p>
<h3 id="常用指令-6"><a href="#常用指令-6" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
<th><strong>复杂度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PFADD key element [element ...]</code></td>
<td>将一个或多个元素添加到 HyperLogLog 结构中。添加操作仅用于<strong>估计</strong>集合的基数（不重复元素的数量）。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>PFCOUNT key [key ...]</code></td>
<td>返回给定 HyperLogLog 结构的<strong>估计基数</strong>。可以接受多个键，返回这些 HyperLogLog <strong>并集</strong>的估计基数。</td>
<td>$O(N)$ ( $N$ 是 HyperLogLog 的数量)</td>
</tr>
<tr>
<td><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td>
<td>将一个或多个 HyperLogLog 合并（Merge）到目标 HyperLogLog（<code>destkey</code>）中。目标键将存储所有源键中所有元素的<strong>并集</strong>的基数估计信息。</td>
<td>$O(N)$ ( $N$ 是被合并的 HyperLogLog 的数量)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>独立访客 (UV) 统计</strong></p>
<p>统计网站、页面或应用程序在特定时间段内访问的用户数量，这是 HLL 最经典的应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PFADD page:uv:20251209 user_id_1 user_id_2</span><br><span class="line"></span><br><span class="line">PFCOUNT page:uv:20251209</span><br></pre></td></tr></table></figure>
<p><strong>多集合并集基数</strong></p>
<p>统计多个相关集合（例如，多个页面的 UV）的<strong>总去重基数</strong>。</p>
<ul>
<li>page:uv:mon: 源键 1，存储周一页面的独立访客（UV）统计数据。</li>
<li>page:uv:tue: 源键 2，存储周二页面的独立访客（UV）统计数据。</li>
<li>total:uv:week: 目标键，存储合并后的 HyperLogLog 数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE total:uv:week page:uv:mon page:uv:tue</span><br><span class="line"></span><br><span class="line">PFCOUNT total:uv:week</span><br></pre></td></tr></table></figure>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>Redis GEO (地理空间索引) 命令用于存储、查询和计算地理坐标点（经度/纬度）的数据，底层基于 ZSet 实现。</p>
<h3 id="常用指令-7"><a href="#常用指令-7" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
<th><strong>复杂度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></td>
<td>将一个或多个地理空间信息（经度、纬度、成员名称）添加到指定的键中。</td>
<td>$O(\log N)$ ( $N$ 是元素数量)</td>
</tr>
<tr>
<td><code>GEOPOS key member [member ...]</code></td>
<td>从指定的键中获取一个或多个成员的<strong>经度和纬度</strong>坐标。</td>
<td>$O(M)$ ( $M$ 是查询的成员数量)</td>
</tr>
<tr>
<td><code>GEODIST key member1 member2 [unit]</code></td>
<td>计算两个成员之间（在存储的键中）的<strong>距离</strong>。<code>unit</code> 可选：<code>m</code> (米)、<code>km</code> (千米)、<code>ft</code> (英尺)、<code>mi</code> (英里)。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>GEOHASH key member [member ...]</code></td>
<td>返回一个或多个成员对应的 <strong>Geohash 字符串</strong>。Geohash 是将二维经纬度数据压缩成一维字符串的方法。</td>
<td>$O(M)$ ( $M$ 是查询的成员数量)</td>
</tr>
<tr>
<td><code>GEORADIUS key longitude latitude radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASCDESC]</code></td>
<td>以给定经纬度为中心，查找指定半径内（<code>radius unit</code>）的所有成员。</td>
<td><script type="math/tex">O(C + \log N)</script></td>
</tr>
<tr>
<td><code>GEORADIUSBYMEMBER key member radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASCDESC]</code></td>
<td>以给定<strong>成员</strong>的位置为中心，查找指定半径内（<code>radius unit</code>）的所有其他成员。</td>
<td><script type="math/tex">O(C + \log N)</script></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>关于 GEORADIUS  和 GEORADIUSBYMEMBER </p>
<p><strong>$N$</strong>：是 GEO 键中存储的<strong>总元素数量</strong>（地理位置点的总数）。</p>
<p><strong>$C$</strong>：是命令实际<strong>返回的元素数量</strong>（在指定半径范围内的成员数量）。</p>
</blockquote>
<h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p>Redis GEO 主要用于处理地理空间位置信息，其核心优势在于能够高效地进行<strong>位置存储、距离计算</strong>和<strong>范围搜索</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>描述</strong></th>
<th><strong>Redis 命令示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>附近的人/地点搜索</strong></td>
<td>查找以用户当前位置为中心，在特定半径范围内的所有兴趣点（POI）或用户。这是 GEO 最常见的应用。</td>
<td><strong>添加位置：</strong> <code>GEOADD shops 116.3 39.9 &quot;Starbucks&quot;</code> <br/><strong>查询附近：</strong> <code>GEORADIUS shops 116.3 39.9 5 km WITHDIST</code></td>
</tr>
<tr>
<td><strong>O2O/LBS 服务</strong></td>
<td>为外卖、打车或零售服务分配最近的骑手/车辆/门店。例如，查找距离订单地址最近的 3 个外卖骑手。</td>
<td><strong>查询附近（按数量限制）：</strong> <code>GEORADIUS drivers 120.5 30.1 10 km COUNT 3 ASC</code></td>
</tr>
<tr>
<td><strong>距离计算与排序</strong></td>
<td>计算两个已知地点或用户之间的直线距离，用于路径规划辅助或收费计算。</td>
<td><strong>计算距离：</strong> <code>GEODIST places &quot;Shanghai Tower&quot; &quot;Oriental Pearl Tower&quot; km</code></td>
</tr>
<tr>
<td><strong>区域边界判定</strong></td>
<td>通过 <code>GEORADIUS</code> 或 <code>GEORADIUSBYMEMBER</code> 确定某个点是否位于特定服务区域或城市半径内。</td>
<td><strong>基于成员查询：</strong> <code>GEORADIUSBYMEMBER store_locations &quot;MainStore&quot; 50 km</code></td>
</tr>
<tr>
<td><strong>地图点位展示</strong></td>
<td>在前端地图上展示大量点位前，可以通过 <code>GEOPOS</code> 快速获取成员的经纬度坐标。</td>
<td><strong>获取坐标：</strong> <code>GEOPOS users &quot;userA&quot; &quot;userB&quot;</code></td>
</tr>
<tr>
<td><strong>Geohash 编码/解码</strong></td>
<td>快速获取或存储 Geohash 编码，用于数据传输或数据库索引（尽管 Redis GEO 自动处理了底层编码）。</td>
<td><strong>获取 Geohash：</strong> <code>GEOHASH places &quot;Eiffel Tower&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>Redis Stream 是一个强大的持久化消息队列，支持多消费者组（Consumer Group）和历史消息回溯。</p>
<h3 id="常用指令-8"><a href="#常用指令-8" class="headerlink" title="常用指令"></a>常用指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
<th><strong>复杂度</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>XADD key ID field value [field value ...]</code></td>
<td>向 Stream 中添加新的消息（条目）。<code>ID</code> 通常使用 <code>*</code> 自动生成，格式为 <code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;</code>。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>XLEN key</code></td>
<td>返回 Stream 中包含的消息（条目）数量。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>XRANGE key start end [COUNT count]</code></td>
<td>获取 Stream 中指定 ID 范围内的消息列表。<code>start</code> 和 <code>end</code> 可以是 ID 或特殊字符（如 <code>-</code> 表示最小 ID，<code>+</code> 表示最大 ID）。</td>
<td>$O(N)$ ( $N$ 是返回的消息数量)</td>
</tr>
<tr>
<td><code>XREVRANGE key end start [COUNT count]</code></td>
<td>与 <code>XRANGE</code> 相同，但返回的消息列表是<strong>逆序</strong>的（从 <code>end</code> 到 <code>start</code>）。</td>
<td>$O(N)$ ( $N$ 是返回的消息数量)</td>
</tr>
<tr>
<td><code>XTRIM key MAXLEN [~] count</code></td>
<td>限制 Stream 的最大长度，移除最旧的消息。<code>~</code> 标志表示近似修剪，以提高效率。</td>
<td>$O(1)$ (当消息不多时)</td>
</tr>
<tr>
<td><code>XGROUP CREATE key groupname ID [MKSTREAM] [ENTRIESREDIS] [LIMIT limit]</code></td>
<td><strong>创建消费者组</strong>。<code>ID</code> 指定消费者组从哪个 ID 开始消费（通常用 <code>$</code> 表示从现在开始的新消息，或 <code>0</code> 表示从头开始）。<code>MKSTREAM</code> 可用于在 Stream 不存在时自动创建。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td>
<td><strong>从 Stream 中读取</strong>消息。可以指定读取数量、阻塞时间。可以从多个 Stream 读取，并为每个 Stream 指定起始 ID。</td>
<td>$O(N)$ ( $N$ 是返回的消息数量)</td>
</tr>
<tr>
<td><code>XREADGROUP GROUP groupname consumername [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td>
<td><strong>从消费者组中读取</strong>消息。读取未被当前消费者组其他消费者处理的消息。<code>ID</code> 通常为 <code>&gt;</code>，表示读取未传递给当前消费者的下一条消息。</td>
<td>$O(N)$ ( $N$ 是返回的消息数量)</td>
</tr>
<tr>
<td><code>XACK key groupname ID [ID ...]</code></td>
<td><strong>确认 (Acknowledge)</strong> 指定 ID 的消息已被消费者成功处理。消息将从消费者的<strong>未处理消息列表 (PEL)</strong> 中移除。</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><code>XPENDING key groupname [IDLE min-idle-time] start end count [consumername]</code></td>
<td>获取<strong>待处理消息列表 (PEL)</strong> 的摘要信息或详细列表。PEL 包含已传递但未被确认的消息。</td>
<td>$O(log N)$ ( $N$ 是 PEL 中的消息数量)</td>
</tr>
<tr>
<td><code>XCLAIM key groupname consumername min-idle-time ID [ID ...]</code></td>
<td><strong>认领 (Claim)</strong> 长期处于待处理状态的消息，将其所有权转给新的消费者。用于处理失败的消费者或死信消息。</td>
<td>$O(M)$ ( $M$ 是被认领的消息数量)</td>
</tr>
<tr>
<td><code>XDEL key ID [ID ...]</code></td>
<td>从 Stream 中<strong>永久删除</strong>指定的条目。</td>
<td>$O(1)$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>描述</strong></th>
<th><strong>Redis 命令示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实时日志收集/处理</strong></td>
<td>将应用程序产生的日志（如访问日志、错误日志）实时写入 Stream，供多个后端服务（如分析系统、监控系统）并行消费和处理。</td>
<td><strong>生产 (Producer)：</strong> <code>XADD log:app:* level error message &quot;DB connection failed&quot;</code> <br/><br/><strong>消费 (Consumer Group)：</strong> <code>XGROUP CREATE log:app monitor $ MKSTREAM</code> <code>XREADGROUP GROUP monitor consumer_A COUNT 10 STREAMS log:app &gt;</code></td>
</tr>
<tr>
<td><strong>异步任务队列</strong></td>
<td>用于解耦服务和削峰填谷。例如，用户下单后，将订单 ID 写入 Stream，后续的库存扣减、积分发放、邮件通知等任务由不同的消费者组异步完成。</td>
<td><strong>生产：</strong> <code>XADD orders:new * orderId 1001 userId 500</code> <br/><br/><strong>消费与确认：</strong> <code>XREADGROUP GROUP worker group1 COUNT 1 STREAMS orders:new &gt;</code> <code>XACK orders:new worker 1678881234000-0</code></td>
</tr>
<tr>
<td><strong>事件溯源 (Event Sourcing)</strong></td>
<td>存储系统中发生的所有状态变更事件，作为系统的单一事实来源。Stream 的不可变和可回溯特性完美契合事件溯源模型。</td>
<td><strong>存储事件：</strong> <code>XADD account:123 * type deposit amount 500</code> <br/><br/><strong>历史回溯：</strong> <code>XRANGE account:123 0 -1</code></td>
</tr>
<tr>
<td><strong>消息广播与通知</strong></td>
<td>用于将重要通知或配置变更广播给所有订阅者。每个订阅者可以是一个独立的消费者组，确保每个订阅者都能接收到所有消息。</td>
<td><strong>生产：</strong> <code>XADD configs:update * key &quot;theme&quot; value &quot;dark&quot;</code><br/><br/> <strong>多组独立消费：</strong> <code>XREADGROUP GROUP service_A consumer_A ...</code> <code>XREADGROUP GROUP service_B consumer_B ...</code></td>
</tr>
<tr>
<td><strong>处理失败与重试</strong></td>
<td>当消费者处理消息失败后，消息仍保留在 PEL (Pending Entries List) 中。Stream 提供了认领（CLAIM）机制来处理超时或失败的消息，实现故障恢复和消息重试。</td>
<td><strong>查看待处理：</strong> <code>XPENDING orders:new worker 0 + 10</code> <br/><br/><strong>认领消息：</strong> <code>XCLAIM orders:new worker_new 3600000 1678881234000-0</code></td>
</tr>
</tbody>
</table>
</div>
<p>Redis Stream 区别于传统消息队列和 Redis List 的主要优势在于：</p>
<ul>
<li><strong>多消费者组模型：</strong> 支持消息的负载均衡（组内消费者抢占）和消息隔离（组间独立消费）。</li>
<li><strong>消息可回溯：</strong> 消息是持久存储的，可以根据 ID 随时从历史位置开始读取。</li>
<li><strong>消息确认 (ACK)：</strong> 明确的消息确认机制和 PEL 列表确保了消息至少被成功处理一次（At-Least-Once Delivery）。</li>
<li><strong>高吞吐量：</strong> 底层使用 Radix Tree 和 Listpack 等数据结构，保证了高效的写入和读取性能。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/11/24/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="MySQL分库分表"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani4.png" onerror="onerror=null;src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySQL分库分表</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/12/02/other/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86%E5%86%85%E5%AE%B9/" title="计算机通识内容"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani5.png" onerror="onerror=null;src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">计算机通识内容</div></div><div class="info-2"><div class="info-item-1">收录了一些通识知识（常识）</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" title="Redis AOF、RDB 持久化策略"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani11.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-23</div><div class="info-item-2">Redis AOF、RDB 持久化策略</div></div><div class="info-2"><div class="info-item-1">Redis 持久化策略Redis 为什么需要持久化？Redis 是基于内存的数据库，内存访问速度快，但内存数据在进程退出或机器宕机后必然丢失。因此，Redis 提供持久化机制，将内存中的数据以一定策略写入磁盘，用于服务重启后的数据恢复。 需要明确一个前提结论：  Redis 持久化只能降低数据丢失风险，并不能保证强一致性或绝对不丢数据。实际丢失多少数据，取决于持久化策略、刷盘频率以及宕机发生的时间点。  Redis 提供两种核心持久化机制：  AOF（Append Only File）日志 RDB（Redis DataBase）快照  AOF 日志持久化AOF 是什么AOF（Append Only File）通过记录写命令的方式持久化数据。Redis 会将所有会修改数据的命令，按执行顺序追加写入日志文件。 AOF 默认是关闭的，可通过配置开启： 12appendonly yesappendfilename &quot;appendonly.aof&quot; AOF 只记录写操作命令，不记录读操作，因为读命令无法用于数据恢复。 AOF...</div></div></div></a><a class="pagination-related" href="/2025/12/14/Redis/Redis-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis 底层数据结构"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani8.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-14</div><div class="info-item-2">Redis 底层数据结构</div></div><div class="info-2"><div class="info-item-1">Redis 底层数据结构Redis 的高性能并非来自单一结构，而是通过多种针对场景高度定制的数据结构实现。上层五种数据类型（String / List / Hash / Set / ZSet）只是抽象接口，真正的性能边界由底层结构决定。 SDS（Simple Dynamic String）基本原理SDS 是 Redis 自定义的字符串实现，替代 C 原生 char*。其核心是显式维护字符串长度与剩余空间。 典型结构： 12345struct sdshdr &#123;    int len;    // 已用长度    int alloc;  // 分配总长度    char buf[];&#125; 核心特点 O(1) 获取长度（避免 strlen） 支持二进制数据（不依赖 \0作为字符串的结尾） 预分配与惰性释放，减少内存重分配 避免缓冲区溢出  使用到的数据类型 String 所有 key Hash / List / Set / ZSet 内部元素  时间复杂度 获取长度：O(1) 追加：均摊 O(1) 修改：O(n)  链表（Linked...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 使用实践</div></div><div class="info-2"><div class="info-item-1">这一部分更多偏实践部分，理论部分见其余 Redis 相关博客</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 过期删除策略+缓存淘汰策略</div></div><div class="info-2"><div class="info-item-1">Redis 过期删除策略在介绍 Redis 的过期删除机制之前，需要先说明：定时删除、惰性删除、定期删除是对过期数据清理思路的抽象划分，用于分析不同策略在 CPU 开销与内存占用之间的取舍。实际的高性能缓存系统通常不会采用其中某一种，而是进行组合设计。 常见的过期删除策略1. 定时删除定时删除指的是：当键到达过期时间的瞬间立即删除该键。 其实现通常需要：  为每一个设置了过期时间的 key 维护独立的定时事件（如定时器或最小堆） 到期后触发删除回调  优点：  过期键能够被及时清理 内存利用率高  缺点：  定时事件数量与过期 key 数量近似线性相关 当过期 key 较多时，定时回调会占用大量 CPU 严重影响主线程吞吐量  因此，Redis 并未采用这种高精度但高成本的策略。 2. 惰性删除惰性删除的核心思想是：不主动删除过期 key，仅在访问时检查其是否过期。 执行流程：  客户端访问 key Redis 判断 key 是否已过期 若已过期，立即删除并返回 key 不存在  优点：  对 CPU 非常友好 不做无意义的主动扫描  缺点：  如果某些 key...</div></div></div></a><a class="pagination-related" href="/2025/12/12/Redis/RedisTemplate%E4%BD%BF%E7%94%A8/" title="RedisTemplate &amp; StringRedisTemplate 使用指南"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">RedisTemplate &amp; StringRedisTemplate 使用指南</div></div><div class="info-2"><div class="info-item-1">RedisTemplate &amp; StringRedisTemplate 使用指南前言由于对于 Redis 始终停留在理论阶段——懂数据结构类型、数据结构底层实现、缓存击穿、缓存穿透、缓存雪崩，还有各种防xxx的方案，但是貌似都停留在学习上、代码阅读上，现在重新补充一下代码实现的细节上。 项目中很多地方使用了 StringRedisTemplate，其实是继承自 RedisTemplate 的。 然后就去搜 RedisTemplate 的 API、搜如何使用，挑选了7-8篇博客结合 ai 整理知识点如下： 从导入依赖开始为什么是从导入依赖开始呢？主要是这个过程引发了我的疑问： 看到有一篇博客使用如下pom依赖： 12345&lt;!--Redis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   ...</div></div></div></a><a class="pagination-related" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img class="cover" src="https://blogs.muxueavid.top/blogs/common/blog-ani7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-22</div><div class="info-item-2">Redis 线程模型</div></div><div class="info-2"><div class="info-item-1">Redis 线程模型Redis 常被描述为“单线程高性能”的代表，但单线程并不等于简单或低效。准确理解 Redis 的线程模型，需要区分：命令执行、网络 I/O、后台任务这三条路径。 Redis 的单线程指的是什么是指—— Redis 的命令执行路径（command execution）是单线程的。 具体来说：  所有客户端命令，统一在 主线程 中，按顺序完成：读取 → 解析 → 执行 → 返回结果    这意味着：  不需要加锁、命令天然具备原子性、数据结构实现可以极度简化   但是，Redis 并不是整个进程只有一个线程  基于内存的设计Redis 将所有核心数据结构存放在内存中，而不是磁盘。 这带来的不仅是“快”这么简单：  避免磁盘 I/O 阻塞 单次命令执行时间高度可控 延迟分布稳定，适合单线程顺序执行模型  相比之下，频繁访问磁盘的系统（如传统关系型数据库）更容易出现阻塞点，不适合纯单线程执行所有逻辑。 关于数据不丢失的问题Redis...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://blogs.muxueavid.top/blogs/common/avator.jpg" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.gif'" alt="avatar"/></div><div class="author-info-name">暮雪Avid</div><div class="author-info-description">热爱+时间=实现</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yukinoshita52"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Yukinoshita52" target="_blank" title="Github"><i class="fab fa-github" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://https://muxueblogs.netlify.app/about/" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/1808485376?spm_id_from=333.1007.0.0" target="_blank" title="Bilibili"><i class="fa-brands fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如出现图片访问失败问题，请科学上网，诶嘿(*^▽^*)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Redis 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">1.1.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">1.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">1.3.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.3.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">1.4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.4.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset"><span class="toc-number">1.5.</span> <span class="toc-text">Zset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.5.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitMap"><span class="toc-number">1.6.</span> <span class="toc-text">BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">1.6.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.7.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-6"><span class="toc-number">1.7.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">1.7.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO"><span class="toc-number">1.8.</span> <span class="toc-text">GEO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">1.8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-7"><span class="toc-number">1.8.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="toc-number">1.8.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">1.9.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">1.9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-8"><span class="toc-number">1.9.2.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="toc-number">1.9.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" title="Redis AOF、RDB 持久化策略"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani11.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis AOF、RDB 持久化策略"/></a><div class="content"><a class="title" href="/2025/12/23/Redis/Redis-AOF%E3%80%81RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/" title="Redis AOF、RDB 持久化策略">Redis AOF、RDB 持久化策略</a><time datetime="2025-12-23T06:08:04.000Z" title="发表于 2025-12-23 14:08:04">2025-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani1.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 过期删除策略+缓存淘汰策略"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" title="Redis 过期删除策略+缓存淘汰策略">Redis 过期删除策略+缓存淘汰策略</a><time datetime="2025-12-22T12:08:37.000Z" title="发表于 2025-12-22 20:08:37">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani6.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 使用实践"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/" title="Redis 使用实践">Redis 使用实践</a><time datetime="2025-12-22T11:25:26.000Z" title="发表于 2025-12-22 19:25:26">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani7.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="Redis 线程模型"/></a><div class="content"><a class="title" href="/2025/12/22/Redis/Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" title="Redis 线程模型">Redis 线程模型</a><time datetime="2025-12-22T10:01:25.000Z" title="发表于 2025-12-22 18:01:25">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录"><img src="https://blogs.muxueavid.top/blogs/common/blog-ani5.png" onerror="this.onerror=null;this.src='https://blogs.muxueavid.top/blogs/common/error.png'" alt="docker个人实践记录"/></a><div class="content"><a class="title" href="/2025/12/16/other/docker%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/" title="docker个人实践记录">docker个人实践记录</a><time datetime="2025-12-16T07:44:45.000Z" title="发表于 2025-12-16 15:44:45">2025-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 - 2026 By 暮雪Avid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><img class="icp-icon" src="https://npm.elemecdn.com/nanshen@latest/img/icp.webp"><span>浙ICP备2025158028号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script src="/js/cursor-right.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,Yukinoshita,自由,平等,公正,诶嘿o(*￣︶￣*)o,法治,爱国,Yukino,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>